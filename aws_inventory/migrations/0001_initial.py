# Generated by Django 5.0.6 on 2024-07-07 20:41

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='AuthGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=150, unique=True)),
            ],
            options={
                'db_table': 'auth_group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AuthGroupPermissions',
            fields=[
                ('id', models.BigAutoField(primary_key=True, serialize=False)),
            ],
            options={
                'db_table': 'auth_group_permissions',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AuthPermission',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=255)),
                ('codename', models.CharField(max_length=100)),
            ],
            options={
                'db_table': 'auth_permission',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AuthUser',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128)),
                ('last_login', models.DateTimeField(blank=True, null=True)),
                ('is_superuser', models.BooleanField()),
                ('username', models.CharField(max_length=150, unique=True)),
                ('first_name', models.CharField(max_length=150)),
                ('last_name', models.CharField(max_length=150)),
                ('email', models.CharField(max_length=254)),
                ('is_staff', models.BooleanField()),
                ('is_active', models.BooleanField()),
                ('date_joined', models.DateTimeField()),
            ],
            options={
                'db_table': 'auth_user',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AuthUserGroups',
            fields=[
                ('id', models.BigAutoField(primary_key=True, serialize=False)),
            ],
            options={
                'db_table': 'auth_user_groups',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AuthUserUserPermissions',
            fields=[
                ('id', models.BigAutoField(primary_key=True, serialize=False)),
            ],
            options={
                'db_table': 'auth_user_user_permissions',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAccessanalyzerAnalyzer',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the Analyzer.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the analyzer.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the analyzer.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of analyzer, which corresponds to the zone of trust chosen for the analyzer.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='A timestamp for the time at which the analyzer was created.', null=True)),
                ('last_resource_analyzed', models.TextField(blank=True, db_comment='The resource that was most recently analyzed by the analyzer.', null=True)),
                ('last_resource_analyzed_at', models.DateTimeField(blank=True, db_comment='The time at which the most recently analyzed resource was analyzed.', null=True)),
                ('status_reason', models.TextField(blank=True, db_comment='The statusReason provides more details about the current status of the analyzer.', null=True)),
                ('findings', models.JSONField(blank=True, db_comment='[DEPRECATED] This column has been deprecated and will be removed in a future release, use table aws_accessanalyzer_finding instead. A list of findings retrieved from the analyzer that match the filter criteria specified, if any.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_accessanalyzer_analyzer',
                'db_table_comment': 'AWS Access Analyzer',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAccessanalyzerFinding',
            fields=[
                ('access_analyzer_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the analyzer that generated the finding.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The ID of the finding.', primary_key=True, serialize=False)),
                ('analyzed_at', models.DateTimeField(blank=True, db_comment='The time at which the resource-based policy that generated the finding was analyzed.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The time at which the finding was created.', null=True)),
                ('error', models.TextField(blank=True, db_comment='The error that resulted in an Error finding.', null=True)),
                ('is_public', models.BooleanField(blank=True, db_comment='Indicates whether the finding reports a resource that has a policy that allows public access.', null=True)),
                ('resource', models.TextField(blank=True, db_comment='The resource that the external principal has access to.', null=True)),
                ('resource_owner_account', models.TextField(blank=True, db_comment='The Amazon Web Services account ID that owns the resource.', null=True)),
                ('resource_type', models.TextField(blank=True, db_comment='The type of the resource that the external principal has access to.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the finding.', null=True)),
                ('updated_at', models.DateTimeField(blank=True, db_comment='The time at which the finding was most recently updated.', null=True)),
                ('action', models.JSONField(blank=True, db_comment='The action in the analyzed policy statement that an external principal has permission to use.', null=True)),
                ('sources', models.JSONField(blank=True, db_comment='The sources of the finding, indicating how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.', null=True)),
                ('principal', models.JSONField(blank=True, db_comment='The external principal that has access to a resource within the zone of trust.', null=True)),
                ('condition', models.JSONField(blank=True, db_comment='The condition in the analyzed policy statement that resulted in a finding.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_accessanalyzer_finding',
                'db_table_comment': 'AWS Access Analyzer Finding',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAccount',
            fields=[
                ('account_aliases', models.JSONField(blank=True, db_comment='A list of aliases associated with the account, if applicable.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the account.', null=True)),
                ('organization_id', models.TextField(blank=True, db_comment='The unique identifier (ID) of an organization, if applicable.', null=True)),
                ('organization_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of an organization.', null=True)),
                ('organization_feature_set', models.TextField(blank=True, db_comment='Specifies the functionality that currently is available to the organization. If set to "ALL", then all features are enabled and policies can be applied to accounts in the organization. If set to "CONSOLIDATED_BILLING", then only consolidated billing functionality is available.', null=True)),
                ('organization_master_account_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the account that is designated as the management account for the organization', null=True)),
                ('organization_master_account_email', models.TextField(blank=True, db_comment='The email address that is associated with the AWS account that is designated as the management account for the organization', null=True)),
                ('organization_master_account_id', models.TextField(blank=True, db_comment='The unique identifier (ID) of the management account of an organization', null=True)),
                ('organization_available_policy_types', models.JSONField(blank=True, db_comment='The Region opt-in status. The possible values are opt-in-not-required, opted-in, and not-opted-in', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', primary_key=True, serialize=False)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_account',
                'db_table_comment': 'AWS Account',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAccountAlternateContact',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name associated with this alternate contact.', null=True)),
                ('contact_type', models.TextField(blank=True, db_comment='The type of alternate contact.', null=True)),
                ('email_address', models.TextField(blank=True, db_comment='The email address associated with this alternate contact.', null=True)),
                ('phone_number', models.TextField(blank=True, db_comment='The phone number associated with this alternate contact.', null=True)),
                ('contact_title', models.TextField(blank=True, db_comment='The title associated with this alternate contact.', null=True)),
                ('linked_account_id', models.TextField(blank=True, db_comment='Account ID to get alternate contact details for.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_account_alternate_contact',
                'db_table_comment': 'AWS Account Alternate Contact',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAccountContact',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('full_name', models.TextField(blank=True, db_comment='The full name of the primary contact address.', null=True)),
                ('address_line_1', models.TextField(blank=True, db_comment='The first line of the primary contact address', null=True)),
                ('address_line_2', models.TextField(blank=True, db_comment='The second line of the primary contact address, if any.', null=True)),
                ('address_line_3', models.TextField(blank=True, db_comment='The third line of the primary contact address, if any.', null=True)),
                ('company_name', models.TextField(blank=True, db_comment='The name of the company associated with the primary contact information, if any.', null=True)),
                ('city', models.TextField(blank=True, db_comment='The city of the primary contact address.', null=True)),
                ('country_code', models.TextField(blank=True, db_comment='The ISO-3166 two-letter country code for the primary contact address.', null=True)),
                ('district_or_county', models.TextField(blank=True, db_comment='The district or county of the primary contact address, if any.', null=True)),
                ('phone_number', models.TextField(blank=True, db_comment='The phone number of the primary contact information. The number will be validated and, in some countries, checked for activation.', null=True)),
                ('postal_code', models.TextField(blank=True, db_comment='The postal code of the primary contact address.', null=True)),
                ('state_or_region', models.TextField(blank=True, db_comment='The state or region of the primary contact address. This field is required in selected countries.', null=True)),
                ('website_url', models.TextField(blank=True, db_comment='The URL of the website associated with the primary contact information, if any.', null=True)),
                ('linked_account_id', models.TextField(blank=True, db_comment='Account ID to get contact details for.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_account_contact',
                'db_table_comment': 'AWS Account Contact',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAcmCertificate',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('certificate_arn', models.TextField(blank=True, db_comment='Amazon Resource Name (ARN) of the certificate. This is of the form: arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012', null=True)),
                ('certificate', models.TextField(blank=True, db_comment='The ACM-issued certificate corresponding to the ARN specified as input', null=True)),
                ('certificate_chain', models.TextField(blank=True, db_comment='The ACM-issued certificate corresponding to the ARN specified as input', null=True)),
                ('domain_name', models.TextField(blank=True, db_comment='Fully qualified domain name (FQDN), such as www.example.com or example.com, for the certificate', null=True)),
                ('certificate_transparency_logging_preference', models.TextField(blank=True, db_comment='Indicates whether to opt in to or out of certificate transparency logging. Certificates that are not logged typically generate a browser error. Transparency makes it possible for you to detect SSL/TLS certificates that have been mistakenly or maliciously issued for your domain.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The time at which the certificate was requested. This value exists only when the certificate type is AMAZON_ISSUED', null=True)),
                ('subject', models.TextField(blank=True, db_comment='The name of the entity that is associated with the public key contained in the certificate', null=True)),
                ('imported_at', models.DateTimeField(blank=True, db_comment='The name of the certificate authority that issued and signed the certificate', null=True)),
                ('issuer', models.TextField(blank=True, db_comment='The name of the certificate authority that issued and signed the certificate', null=True)),
                ('signature_algorithm', models.TextField(blank=True, db_comment='The algorithm that was used to sign the certificate', null=True)),
                ('extended_key_usages', models.JSONField(blank=True, db_comment='Specify one or more ExtendedKeyUsage extension values.', null=True)),
                ('failure_reason', models.TextField(blank=True, db_comment='The reason the certificate request failed. This value exists only when the certificate status is FAILED', null=True)),
                ('issued_at', models.DateTimeField(blank=True, db_comment='A list of ARNs for the AWS resources that are using the certificate. A certificate can be used by multiple AWS resources', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the certificate', null=True)),
                ('key_algorithm', models.TextField(blank=True, db_comment='The algorithm that was used to generate the public-private key pair', null=True)),
                ('not_after', models.DateTimeField(blank=True, db_comment='The time after which the certificate is not valid', null=True)),
                ('not_before', models.DateTimeField(blank=True, db_comment='The time before which the certificate is not valid', null=True)),
                ('renewal_eligibility', models.TextField(blank=True, db_comment='Specifies whether the certificate is eligible for renewal.', null=True)),
                ('revocation_reason', models.TextField(blank=True, db_comment='The reason the certificate was revoked. This value exists only when the certificate status is REVOKED', null=True)),
                ('revoked_at', models.DateTimeField(blank=True, db_comment='The time at which the certificate was revoked. This value exists only when the certificate status is REVOKED', null=True)),
                ('serial', models.TextField(blank=True, db_comment='The serial number of the certificate', null=True)),
                ('type', models.TextField(blank=True, db_comment='The source of the certificate. For certificates provided by ACM, this value is AMAZON_ISSUED.', null=True)),
                ('domain_validation_options', models.JSONField(blank=True, db_comment='Contains information about the initial validation of each domain name that occurs as a result of the RequestCertificate request. This field exists only when the certificate type is AMAZON_ISSUED', null=True)),
                ('in_use_by', models.JSONField(blank=True, db_comment='A list of ARNs for the AWS resources that are using the certificate', null=True)),
                ('subject_alternative_names', models.JSONField(blank=True, db_comment='One or more domain names (subject alternative names) included in the certificate. This list contains the domain names that are bound to the public key that is contained in the certificate. The subject alternative names include the canonical domain name (CN) of the certificate and additional domain names that can be used to connect to the website', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with certificate', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_acm_certificate',
                'db_table_comment': 'AWS ACM Certificate',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAcmpcaCertificateAuthority',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='Amazon Resource Name (ARN) for your private certificate authority (CA). The format is 12345678-1234-1234-1234-123456789012.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='Date and time at which your private CA was created.', null=True)),
                ('failure_reason', models.TextField(blank=True, db_comment='Reason the request to create your private CA failed.', null=True)),
                ('key_storage_security_standard', models.TextField(blank=True, db_comment="Defines a cryptographic key management compliance standard used for handling CA keys. Default: FIPS_140_2_LEVEL_3_OR_HIGHER Note: Amazon Web Services Region ap-northeast-3 supports only FIPS_140_2_LEVEL_2_OR_HIGHER. You must explicitly specify this parameter and value when creating a CA in that Region. Specifying a different value (or no value) results in an InvalidArgsException with the message 'A certificate authority cannot be created in this region with the specified security standard.'", null=True)),
                ('last_state_change_at', models.DateTimeField(blank=True, db_comment='Date and time at which your private CA was last updated.', null=True)),
                ('not_after', models.DateTimeField(blank=True, db_comment='Date and time after which your private CA certificate is not valid.', null=True)),
                ('not_before', models.DateTimeField(blank=True, db_comment='Date and time before which your private CA certificate is not valid.', null=True)),
                ('owner_account', models.TextField(blank=True, db_comment='The Amazon Web Services account ID that owns the certificate authority.', null=True)),
                ('restorable_until', models.DateTimeField(blank=True, db_comment='The period during which a deleted CA can be restored. For more information, see the PermanentDeletionTimeInDays parameter of the DeleteCertificateAuthorityRequest action.', null=True)),
                ('serial', models.TextField(blank=True, db_comment='Serial number of your private CA.', null=True)),
                ('status', models.TextField(blank=True, db_comment='Status of your private CA.', null=True)),
                ('type', models.TextField(blank=True, db_comment='Type of your private CA.', null=True)),
                ('usage_mode', models.TextField(blank=True, db_comment='Specifies whether the CA issues general-purpose certificates that typically require a revocation mechanism, or short-lived certificates that may optionally omit revocation because they expire quickly. Short-lived certificate validity is limited to seven days. The default value is GENERAL_PURPOSE.', null=True)),
                ('certificate_authority_configuration', models.JSONField(blank=True, db_comment='Your private CA configuration.', null=True)),
                ('revocation_configuration', models.JSONField(blank=True, db_comment='Information about the Online Certificate Status Protocol (OCSP) configuration or certificate revocation list (CRL) created and maintained by your private CA.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with private certificate authority (CA).', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_acmpca_certificate_authority',
                'db_table_comment': 'AWS ACM Private Certificate Authority',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAmplifyApp',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('app_id', models.TextField(blank=True, db_comment='The unique ID of the Amplify app.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the Amplify app.', null=True)),
                ('name', models.TextField(blank=True, db_comment='The name for the Amplify app.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description for the Amplify app.', null=True)),
                ('create_time', models.DateTimeField(blank=True, db_comment='Creates a date and time for the Amplify app.', null=True)),
                ('update_time', models.DateTimeField(blank=True, db_comment='Updates the date and time for the Amplify app.', null=True)),
                ('basic_auth_credentials', models.TextField(blank=True, db_comment='The basic authorization credentials for branches for the Amplify app. You must base64-encode the authorization credentials and provide them in the format user:password.', null=True)),
                ('custom_headers', models.TextField(blank=True, db_comment='Describes the custom HTTP headers for the Amplify app.', null=True)),
                ('default_domain', models.TextField(blank=True, db_comment='The default domain for the Amplify app.', null=True)),
                ('enable_auto_branch_creation', models.BooleanField(blank=True, db_comment='Enables automated branch creation for the Amplify app.', null=True)),
                ('enable_basic_auth', models.BooleanField(blank=True, db_comment="Enables basic authorization for the Amplify app's branches.", null=True)),
                ('enable_branch_auto_build', models.BooleanField(blank=True, db_comment='Enables the auto-building of branches for the Amplify app.', null=True)),
                ('enable_branch_auto_deletion', models.BooleanField(blank=True, db_comment='Automatically disconnect a branch in the Amplify Console when you delete a branch from your Git repository.', null=True)),
                ('iam_service_role_arn', models.TextField(blank=True, db_comment='The AWS Identity and Access Management (IAM) service role for the Amazon Resource Name (ARN) of the Amplify app.', null=True)),
                ('platform', models.TextField(blank=True, db_comment='The platform for the Amplify app.', null=True)),
                ('repository', models.TextField(blank=True, db_comment='The Git repository for the Amplify app.', null=True)),
                ('repository_clone_method', models.TextField(blank=True, db_comment='The Amplify service uses this parameter to specify the authentication protocol to use to access the Git repository for an Amplify app. Amplify specifies TOKEN for a GitHub repository, SIGV4 for an AWS CodeCommit repository, and SSH for GitLab and Bitbucket repositories.', null=True)),
                ('auto_branch_creation_config', models.JSONField(blank=True, db_comment='Describes the automated branch creation configuration for the Amplify app.', null=True)),
                ('auto_branch_creation_patterns', models.JSONField(blank=True, db_comment='Describes the automated branch creation glob patterns for the Amplify app.', null=True)),
                ('build_spec', models.JSONField(blank=True, db_comment='Describes the content of the build specification (build spec) for the Amplify app.', null=True)),
                ('custom_rules', models.JSONField(blank=True, db_comment='Describes the custom redirect and rewrite rules for the Amplify app.', null=True)),
                ('environment_variables', models.JSONField(blank=True, db_comment='The environment variables for the Amplify app.', null=True)),
                ('production_branch', models.JSONField(blank=True, db_comment='Describes the information about a production branch of the Amplify app.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_amplify_app',
                'db_table_comment': 'AWS Amplify App',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsApiGatewayApiKey',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the API Key', null=True)),
                ('id', models.TextField(blank=True, db_comment='The identifier of the API Key', primary_key=True, serialize=False)),
                ('enabled', models.BooleanField(blank=True, db_comment='Specifies whether the API Key can be used by callers', null=True)),
                ('created_date', models.DateTimeField(blank=True, db_comment='The timestamp when the API Key was created', null=True)),
                ('last_updated_date', models.DateTimeField(blank=True, db_comment='The timestamp when the API Key was last updated', null=True)),
                ('customer_id', models.TextField(blank=True, db_comment='An AWS Marketplace customer identifier , when integrating with the AWS SaaS Marketplace', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the API Key', null=True)),
                ('value', models.TextField(blank=True, db_comment='The value of the API Key', null=True)),
                ('stage_keys', models.JSONField(blank=True, db_comment='A list of Stage resources that are associated with the ApiKey resource', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to API key', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_api_gateway_api_key',
                'db_table_comment': 'AWS API Gateway API Key',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsApiGatewayAuthorizer',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The identifier for the authorizer resource', primary_key=True, serialize=False)),
                ('name', models.TextField(blank=True, db_comment='The name of the authorizer', null=True)),
                ('rest_api_id', models.TextField(blank=True, db_comment='The id of the rest api', null=True)),
                ('auth_type', models.TextField(blank=True, db_comment='Optional customer-defined field, used in OpenAPI imports and exports without functional impact', null=True)),
                ('authorizer_credentials', models.TextField(blank=True, db_comment='Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer', null=True)),
                ('authorizer_uri', models.TextField(blank=True, db_comment="Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or REQUEST authorizers, this must be a well-formed Lambda function URI", null=True)),
                ('identity_validation_expression', models.TextField(blank=True, db_comment='A validation expression for the incoming identity token. For TOKEN authorizers, this value is a regular expression', null=True)),
                ('identity_source', models.TextField(blank=True, db_comment='The identity source for which authorization is requested', null=True)),
                ('provider_arns', models.JSONField(blank=True, db_comment='A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_api_gateway_authorizer',
                'db_table_comment': 'AWS API Gateway Authorizer',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsApiGatewayDomainName',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('domain_name', models.TextField(blank=True, db_comment='The custom domain name as an API host name.', null=True)),
                ('certificate_arn', models.TextField(blank=True, db_comment='The reference to an AWS-managed certificate that will be used by edge-optimized endpoint for this domain name.', null=True)),
                ('certificate_name', models.TextField(blank=True, db_comment='The name of the certificate that will be used by edge-optimized endpoint for this domain name.', null=True)),
                ('certificate_upload_date', models.DateTimeField(blank=True, db_comment='The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.', null=True)),
                ('distribution_domain_name', models.TextField(blank=True, db_comment='The domain name of the Amazon CloudFront distribution associated with this custom domain name for an edge-optimized endpoint.', null=True)),
                ('distribution_hosted_zone_id', models.TextField(blank=True, db_comment='The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized endpoint. The valid value is Z2FDTNDATAQYW2 for all the regions.', null=True)),
                ('domain_name_status', models.TextField(blank=True, db_comment='The status of the DomainName migration. The valid values are AVAILABLE and UPDATING. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete.', null=True)),
                ('domain_name_status_message', models.TextField(blank=True, db_comment='An optional text message containing detailed information about status of the DomainName migration.', null=True)),
                ('ownership_verification_certificate_arn', models.TextField(blank=True, db_comment='The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.', null=True)),
                ('regional_certificate_arn', models.TextField(blank=True, db_comment='The reference to an AWS-managed certificate that will be used for validating the regional domain name. AWS Certificate Manager is the only supported source.', null=True)),
                ('regional_certificate_name', models.TextField(blank=True, db_comment='The name of the certificate that will be used for validating the regional domain name.', null=True)),
                ('regional_domain_name', models.TextField(blank=True, db_comment='The domain name associated with the regional endpoint for this custom domain name. You set up this association by adding a DNS record that points the custom domain name to this regional domain name. The regional domain name is returned by API Gateway when you create a regional endpoint.', null=True)),
                ('regional_hosted_zone_id', models.TextField(blank=True, db_comment='The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint. For more information, see Set up a Regional Custom Domain Name and AWS Regions and Endpoints for API Gateway.', null=True)),
                ('security_policy', models.TextField(blank=True, db_comment='The Transport Layer Security (TLS) version + cipher suite for this DomainName. The valid values are TLS_1_0 and TLS_1_2.', null=True)),
                ('endpoint_configuration', models.JSONField(blank=True, db_comment='The endpoint configuration of this DomainName showing the endpoint types of the domain name.', null=True)),
                ('mutual_tls_authentication', models.JSONField(blank=True, db_comment='The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_api_gateway_domain_name',
                'db_table_comment': 'AWS API Gateway Domain Name',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsApiGatewayMethod',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('rest_api_id', models.TextField(blank=True, db_comment='The string identifier of the associated RestApi.', null=True)),
                ('resource_id', models.TextField(blank=True, db_comment='The Resource identifier for the Method resource.', null=True)),
                ('http_method', models.TextField(blank=True, db_comment="The method's HTTP verb.", null=True)),
                ('path', models.TextField(blank=True, db_comment='The full path for this resource.', null=True)),
                ('path_part', models.TextField(blank=True, db_comment='The last path segment for this resource.', null=True)),
                ('api_key_required', models.BooleanField(blank=True, db_comment='A boolean flag specifying whether a valid ApiKey is required to invoke this method.', null=True)),
                ('authorization_type', models.TextField(blank=True, db_comment="The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.", null=True)),
                ('authorizer_id', models.TextField(blank=True, db_comment='The identifier of an Authorizer to use on this method. The authorizationType must be CUSTOM.', null=True)),
                ('operation_name', models.TextField(blank=True, db_comment='A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in the PetStore example.', null=True)),
                ('request_validator_id', models.TextField(blank=True, db_comment='The identifier of a RequestValidator for request validation.', null=True)),
                ('authorization_scopes', models.JSONField(blank=True, db_comment='A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation.', null=True)),
                ('method_integration', models.JSONField(blank=True, db_comment="Gets the method's integration responsible for passing the client-submitted request to the back end and performing necessary transformations.", null=True)),
                ('method_responses', models.JSONField(blank=True, db_comment='Gets a method response associated with a given HTTP status code.', null=True)),
                ('request_models', models.JSONField(blank=True, db_comment='A key-value map specifying data schemas, represented by Model resources, of the request payloads of given content types.', null=True)),
                ('request_parameters', models.JSONField(blank=True, db_comment='A key-value map defining required or optional method request parameters that can be accepted by API Gateway.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_api_gateway_method',
                'db_table_comment': 'AWS API Gateway Method',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsApiGatewayRestApi',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment="The API's name", null=True)),
                ('api_id', models.TextField(blank=True, db_comment="The API's identifier. This identifier is unique across all of APIs in API Gateway", null=True)),
                ('version', models.TextField(blank=True, db_comment='A version identifier for the API', null=True)),
                ('api_key_source', models.TextField(blank=True, db_comment='The source of the API key for metering requests according to a usage plan', null=True)),
                ('created_date', models.DateTimeField(blank=True, db_comment='The timestamp when the API was created', null=True)),
                ('description', models.TextField(blank=True, db_comment="The API's description", null=True)),
                ('minimum_compression_size', models.BigIntegerField(blank=True, db_comment='A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='A stringified JSON policy document that applies to this RestApi regardless of the caller and Method configuration', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the policy in a canonical form for easier searching.', null=True)),
                ('binary_media_types', models.JSONField(blank=True, db_comment='The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads', null=True)),
                ('endpoint_configuration_types', models.JSONField(blank=True, db_comment='The endpoint configuration of this RestApi showing the endpoint types of the API', null=True)),
                ('endpoint_configuration_vpc_endpoint_ids', models.JSONField(blank=True, db_comment='The endpoint configuration of this RestApi showing the endpoint types of the API', null=True)),
                ('warnings', models.JSONField(blank=True, db_comment='The warning messages reported when failonwarnings is turned on during API import', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_api_gateway_rest_api',
                'db_table_comment': 'AWS API Gateway Rest API ',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsApiGatewayStage',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the stage.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the  stage.', null=True)),
                ('rest_api_id', models.TextField(blank=True, db_comment='The id of the rest api which contains this stage.', null=True)),
                ('deployment_id', models.TextField(blank=True, db_comment='The identifier of the Deployment that the stage points to.', null=True)),
                ('created_date', models.DateTimeField(blank=True, db_comment='The timestamp when the stage was created.', null=True)),
                ('cache_cluster_enabled', models.BooleanField(blank=True, db_comment='Specifies whether a cache cluster is enabled for the stage.', null=True)),
                ('tracing_enabled', models.BooleanField(blank=True, db_comment='Specifies whether active tracing with X-ray is enabled for the Stage.', null=True)),
                ('access_log_settings', models.JSONField(blank=True, db_comment='Settings for logging access in this stage.', null=True)),
                ('cache_cluster_size', models.TextField(blank=True, db_comment='The size of the cache cluster for the stage, if enabled.', null=True)),
                ('cache_cluster_status', models.TextField(blank=True, db_comment='The status of the cache cluster for the stage, if enabled.', null=True)),
                ('client_certificate_id', models.TextField(blank=True, db_comment='The identifier of a client certificate for an API stage.', null=True)),
                ('description', models.TextField(blank=True, db_comment="The stage's description.", null=True)),
                ('documentation_version', models.TextField(blank=True, db_comment='The version of the associated API documentation.', null=True)),
                ('last_updated_date', models.DateTimeField(blank=True, db_comment='The timestamp when the stage last updated.', null=True)),
                ('canary_settings', models.JSONField(blank=True, db_comment='A map of settings for the canary deployment in this stage.', null=True)),
                ('method_settings', models.JSONField(blank=True, db_comment='A map that defines the method settings for a Stage resource.', null=True)),
                ('variables', models.JSONField(blank=True, db_comment='A map that defines the stage variables for a Stage resource.', null=True)),
                ('web_acl_arn', models.TextField(blank=True, db_comment='The ARN of the WebAcl associated with the Stage.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_api_gateway_stage',
                'db_table_comment': 'AWS API Gateway Stage',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsApiGatewayUsagePlan',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of a usage plan', null=True)),
                ('id', models.TextField(blank=True, db_comment='The identifier of a UsagePlan resource', primary_key=True, serialize=False)),
                ('product_code', models.TextField(blank=True, db_comment='The AWS Markeplace product identifier to associate with the usage plan as a SaaS product on AWS Marketplace', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of a usage plan', null=True)),
                ('quota', models.JSONField(blank=True, db_comment='The maximum number of permitted requests per a given unit time interval', null=True)),
                ('throttle', models.JSONField(blank=True, db_comment='The request throttle limits of a usage plan', null=True)),
                ('api_stages', models.JSONField(blank=True, db_comment='The associated API stages of a usage plan', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_api_gateway_usage_plan',
                'db_table_comment': 'AWS API Gateway Usage Plan',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsApiGatewayv2Api',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the API', null=True)),
                ('api_id', models.TextField(blank=True, db_comment='The API ID', null=True)),
                ('api_endpoint', models.TextField(blank=True, db_comment='The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the API.', null=True)),
                ('protocol_type', models.TextField(blank=True, db_comment='The API protocol', null=True)),
                ('api_key_selection_expression', models.TextField(blank=True, db_comment='An API key selection expression. Supported only for WebSocket APIs', null=True)),
                ('disable_execute_api_endpoint', models.BooleanField(blank=True, db_comment='Specifies whether clients can invoke your API by using the default execute-api endpoint.', null=True)),
                ('route_selection_expression', models.TextField(blank=True, db_comment='The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs', null=True)),
                ('created_date', models.DateTimeField(blank=True, db_comment='The timestamp when the API was created', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_api_gatewayv2_api',
                'db_table_comment': 'AWS API Gateway Version 2 API',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsApiGatewayv2DomainName',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('domain_name', models.TextField(blank=True, db_comment='The name of the DomainName resource', null=True)),
                ('api_mapping_selection_expression', models.TextField(blank=True, db_comment='The API mapping selection expression.', null=True)),
                ('domain_name_configurations', models.JSONField(blank=True, db_comment='The domain name configurations', null=True)),
                ('mutual_tls_authentication', models.JSONField(blank=True, db_comment='The mutual TLS authentication configuration for a custom domain name', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_api_gatewayv2_domain_name',
                'db_table_comment': 'AWS API Gateway Version 2 Domain Name',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsApiGatewayv2Integration',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('integration_id', models.TextField(blank=True, db_comment='Represents the identifier of an integration.', null=True)),
                ('api_id', models.TextField(blank=True, db_comment='Represents the identifier of an API.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the integration.', null=True)),
                ('description', models.TextField(blank=True, db_comment='Represents the description of an integration.', null=True)),
                ('integration_method', models.TextField(blank=True, db_comment="Specifies the integration's HTTP method type.", null=True)),
                ('integration_type', models.TextField(blank=True, db_comment='Represents an API method integration type.', null=True)),
                ('integration_uri', models.TextField(blank=True, db_comment='A string representation of a URI with a length between [1-2048]. For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL.', null=True)),
                ('api_gateway_managed', models.BooleanField(blank=True, db_comment="Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.", null=True)),
                ('connection_id', models.TextField(blank=True, db_comment='The ID of the VPC link for a private integration. Supported only for HTTP APIs.', null=True)),
                ('connection_type', models.TextField(blank=True, db_comment='Represents a connection type.', null=True)),
                ('content_handling_strategy', models.TextField(blank=True, db_comment='Specifies how to handle response payload content type conversions. Supported only for WebSocket APIs.', null=True)),
                ('credentials_arn', models.TextField(blank=True, db_comment="Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN).", null=True)),
                ('integration_response_selection_expression', models.TextField(blank=True, db_comment='An expression used to extract information at runtime. See Selection Expressions(https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions for more information.', null=True)),
                ('integration_subtype', models.TextField(blank=True, db_comment='A string with a length between [1-128].', null=True)),
                ('passthrough_behavior', models.TextField(blank=True, db_comment='Represents passthrough behavior for an integration response. Supported only for WebSocket APIs.', null=True)),
                ('payload_format_version', models.TextField(blank=True, db_comment='Specifies the format of the payload sent to an integration. Required for HTTP APIs.', null=True)),
                ('template_selection_expression', models.TextField(blank=True, db_comment='The template selection expression for the integration. Supported only for WebSocket APIs.', null=True)),
                ('timeout_in_millis', models.BigIntegerField(blank=True, db_comment='Indicates custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.', null=True)),
                ('request_parameters', models.JSONField(blank=True, db_comment='For HTTP API itegrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern <action>:<header|querystring|path>.<location>. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see Transforming API requests and responses (https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).', null=True)),
                ('request_templates', models.JSONField(blank=True, db_comment='Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.', null=True)),
                ('response_parameters', models.JSONField(blank=True, db_comment='API requests and responses (https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).', null=True)),
                ('tls_config', models.JSONField(blank=True, db_comment='The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_api_gatewayv2_integration',
                'db_table_comment': 'AWS API Gateway Version 2 Integration',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsApiGatewayv2Route',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('route_key', models.TextField(blank=True, db_comment='The route key for the route.', null=True)),
                ('api_id', models.TextField(blank=True, db_comment='Represents the identifier of an API.', null=True)),
                ('route_id', models.TextField(blank=True, db_comment='The route ID.', null=True)),
                ('api_gateway_managed', models.BooleanField(blank=True, db_comment='Specifies whether a route is managed by API Gateway.', null=True)),
                ('api_key_required', models.BooleanField(blank=True, db_comment='Specifies whether an API key is required for this route. Supported only for WebSocket APIs.', null=True)),
                ('authorization_type', models.TextField(blank=True, db_comment='The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.', null=True)),
                ('authorizer_id', models.TextField(blank=True, db_comment='The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.', null=True)),
                ('model_selection_expression', models.TextField(blank=True, db_comment='The model selection expression for the route. Supported only for WebSocket APIs.', null=True)),
                ('operation_name', models.TextField(blank=True, db_comment='The operation name for the route.', null=True)),
                ('route_response_selection_expression', models.TextField(blank=True, db_comment='The route response selection expression for the route. Supported only for WebSocket APIs.', null=True)),
                ('target', models.TextField(blank=True, db_comment='The target for the route.', null=True)),
                ('authorization_scopes', models.JSONField(blank=True, db_comment='A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.', null=True)),
                ('request_models', models.JSONField(blank=True, db_comment='The request models for the route. Supported only for WebSocket APIs.', null=True)),
                ('request_parameters', models.JSONField(blank=True, db_comment='The request parameters for the route. Supported only for WebSocket APIs.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_api_gatewayv2_route',
                'db_table_comment': 'AWS API Gateway Version 2 Route',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsApiGatewayv2Stage',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('stage_name', models.TextField(blank=True, db_comment='The name of the stage', null=True)),
                ('api_id', models.TextField(blank=True, db_comment='The id of the api which contains this stage', null=True)),
                ('api_gateway_managed', models.BooleanField(blank=True, db_comment='Specifies whether a stage is managed by API Gateway', null=True)),
                ('auto_deploy', models.BooleanField(blank=True, db_comment='Specifies whether updates to an API automatically trigger a new deployment', null=True)),
                ('client_certificate_id', models.TextField(blank=True, db_comment='The identifier of a client certificate for a Stage. Supported only for WebSocket APIs', null=True)),
                ('created_date', models.TextField(blank=True, db_comment='The timestamp when the stage was created', null=True)),
                ('deployment_id', models.TextField(blank=True, db_comment='The identifier of the Deployment that the Stage is associated with', null=True)),
                ('default_route_data_trace_enabled', models.BooleanField(blank=True, db_comment='Specifies whether (true) or not (false) data trace logging is enabled for this route. This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs', null=True)),
                ('default_route_detailed_metrics_enabled', models.BooleanField(blank=True, db_comment='Specifies whether detailed metrics are enabled', null=True)),
                ('default_route_logging_level', models.TextField(blank=True, db_comment='Specifies the logging level for this route: INFO, ERROR, or OFF. This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs', null=True)),
                ('default_route_throttling_burst_limit', models.BigIntegerField(blank=True, db_comment='Throttling burst limit for default route settings', null=True)),
                ('default_route_throttling_rate_limit', models.FloatField(blank=True, db_comment='Throttling rate limit for default route settings', null=True)),
                ('last_deployment_status_message', models.TextField(blank=True, db_comment='Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled', null=True)),
                ('last_updated_date', models.TextField(blank=True, db_comment='The timestamp when the stage was last updated', null=True)),
                ('description', models.TextField(blank=True, db_comment="The stage's description", null=True)),
                ('access_log_settings', models.JSONField(blank=True, db_comment='Access log settings of the stage.', null=True)),
                ('stage_variables', models.JSONField(blank=True, db_comment='A map that defines the stage variables for a stage resource', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_api_gatewayv2_stage',
                'db_table_comment': 'AWS API Gateway Version 2 Stage',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAppconfigApplication',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The application ID.', primary_key=True, serialize=False)),
                ('name', models.TextField(blank=True, db_comment='The application name.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that identifies the application.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the application.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_appconfig_application',
                'db_table_comment': 'AWS AppConfig Application',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAppstreamFleet',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the fleet.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the fleet.', null=True)),
                ('instance_type', models.TextField(blank=True, db_comment='The instance type to use when launching fleet instances.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The current state for the fleet.', null=True)),
                ('created_time', models.DateTimeField(blank=True, db_comment='The time the fleet was created.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description to display.', null=True)),
                ('display_name', models.TextField(blank=True, db_comment='The fleet name to display.', null=True)),
                ('disconnect_timeout_in_seconds', models.BigIntegerField(blank=True, db_comment='The amount of time that a streaming session remains active after users disconnect. If they try to reconnect to the streaming session after a disconnection or network interruption within this time interval, they are connected to their previous session. Otherwise, they are connected to a new session with a new streaming instance. Specify a value between 60 and 360000.', null=True)),
                ('directory_name', models.TextField(blank=True, db_comment='The fully qualified name of the directory (for example, corp.example.com).', null=True)),
                ('organizational_unit_distinguished_name', models.TextField(blank=True, db_comment='The distinguished name of the organizational unit for computer accounts.', null=True)),
                ('enable_default_internet_access', models.BooleanField(blank=True, db_comment='Indicates whether default internet access is enabled for the fleet.', null=True)),
                ('fleet_type', models.TextField(blank=True, db_comment='The fleet type. ALWAYS_ON Provides users with instant-on access to their apps. You are charged for all running instances in your fleet, even if no users are streaming apps. ON_DEMAND Provide users with access to applications after they connect, which takes one to two minutes. You are charged for instance streaming when users are connected and a small hourly fee for instances that are not streaming apps.', null=True)),
                ('iam_role_arn', models.TextField(blank=True, db_comment='The ARN of the IAM role that is applied to the fleet.', null=True)),
                ('idle_disconnect_timeout_in_seconds', models.BigIntegerField(blank=True, db_comment='The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the DisconnectTimeoutInSeconds time interval begins.', null=True)),
                ('image_arn', models.TextField(blank=True, db_comment='The ARN for the public, private, or shared image.', null=True)),
                ('image_name', models.TextField(blank=True, db_comment='The name of the image used to create the fleet.', null=True)),
                ('max_concurrent_sessions', models.BigIntegerField(blank=True, db_comment='The maximum number of concurrent sessions for the fleet.', null=True)),
                ('max_user_duration_in_seconds', models.BigIntegerField(blank=True, db_comment='The maximum amount of time that a streaming session can remain active, in seconds. If users are still connected to a streaming instance five minutes before this limit is reached, they are prompted to save any open documents before being disconnected.', null=True)),
                ('platform', models.TextField(blank=True, db_comment='The platform of the fleet.', null=True)),
                ('stream_view', models.TextField(blank=True, db_comment='The AppStream 2.0 view that is displayed to your users when they stream from the fleet. When APP is specified, only the windows of applications opened by users display. When DESKTOP is specified, the standard desktop that is provided by the operating system displays. The default value is APP.', null=True)),
                ('compute_capacity_status', models.JSONField(blank=True, db_comment='The capacity status for the fleet.', null=True)),
                ('fleet_errors', models.JSONField(blank=True, db_comment='The fleet errors.', null=True)),
                ('session_script_s3_location', models.JSONField(blank=True, db_comment='The S3 location of the session scripts configuration zip file. This only applies to Elastic fleets.', null=True)),
                ('usb_device_filter_strings', models.JSONField(blank=True, db_comment='The USB device filter strings associated with the fleet.', null=True)),
                ('vpc_config', models.JSONField(blank=True, db_comment='The VPC configuration for the fleet.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_appstream_fleet',
                'db_table_comment': 'AWS AppStream Fleet',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAppsyncGraphqlApi',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The API name.', null=True)),
                ('api_id', models.TextField(blank=True, db_comment='The API ID.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of AppSync GraphQL API.', null=True)),
                ('api_type', models.TextField(blank=True, db_comment='The value that indicates whether the GraphQL API is a standard API ( GRAPHQL ) or merged API ( MERGED ).', null=True)),
                ('authentication_type', models.TextField(blank=True, db_comment='The authentication type.', null=True)),
                ('merged_api_execution_role_arn', models.TextField(blank=True, db_comment='The Identity and Access Management service role ARN for a merged API.', null=True)),
                ('owner', models.TextField(blank=True, db_comment='The account owner of the GraphQL API.', null=True)),
                ('owner_contact', models.TextField(blank=True, db_comment='The owner contact information for an API resource.', null=True)),
                ('visibility', models.TextField(blank=True, db_comment='Sets the value of the GraphQL API to public ( GLOBAL ) or private ( PRIVATE ).', null=True)),
                ('waf_web_acl_arn', models.TextField(blank=True, db_comment='The ARN of the WAF access control list (ACL) associated with this GraphqlApi, if one exists.', null=True)),
                ('xray_enabled', models.BooleanField(blank=True, db_comment='A flag indicating whether to use X-Ray tracing for this GraphqlApi.', null=True)),
                ('log_config', models.JSONField(blank=True, db_comment='The Amazon CloudWatch Logs configuration.', null=True)),
                ('open_id_connect_config', models.JSONField(blank=True, db_comment='The OpenID Connect configuration.', null=True)),
                ('additional_authentication_providers', models.JSONField(blank=True, db_comment='A list of additional authentication providers for the GraphqlApi API.', null=True)),
                ('dns', models.JSONField(blank=True, db_comment='The DNS records for the API.', null=True)),
                ('lambda_authorizer_config', models.JSONField(blank=True, db_comment='Configuration for Lambda function authorization.', null=True)),
                ('uris', models.JSONField(blank=True, db_comment='The URIs.', null=True)),
                ('user_pool_config', models.JSONField(blank=True, db_comment='The Amazon Cognito user pool configuration.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_appsync_graphql_api',
                'db_table_comment': 'AWS AppSync GraphQL API',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAthenaQueryExecution',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The unique identifier for each query execution.', primary_key=True, serialize=False)),
                ('workgroup', models.TextField(blank=True, db_comment='The name of the workgroup in which the query ran.', null=True)),
                ('catalog', models.TextField(blank=True, db_comment='The name of the data catalog used in the query execution.', null=True)),
                ('database', models.TextField(blank=True, db_comment='The name of the data database used in the query execution.', null=True)),
                ('query', models.TextField(blank=True, db_comment='The SQL query statements which the query execution ran.', null=True)),
                ('effective_engine_version', models.TextField(blank=True, db_comment='The engine version on which the query runs.', null=True)),
                ('selected_engine_version', models.TextField(blank=True, db_comment='The engine version requested by the users.', null=True)),
                ('execution_parameters', models.JSONField(blank=True, db_comment='A list of values for the parameters in a query.', null=True)),
                ('statement_type', models.TextField(blank=True, db_comment='The type of query statement that was run.', null=True)),
                ('substatement_type', models.TextField(blank=True, db_comment='The kind of query statement that was run.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The state of query execution.', null=True)),
                ('state_change_reason', models.TextField(blank=True, db_comment='Further detail about the status of the query.', null=True)),
                ('submission_date_time', models.DateTimeField(blank=True, db_comment='The date and time that the query was submitted.', null=True)),
                ('completion_date_time', models.DateTimeField(blank=True, db_comment='The date and time that the query completed.', null=True)),
                ('error_message', models.TextField(blank=True, db_comment='Contains a short description of the error that occurred.', null=True)),
                ('error_type', models.BigIntegerField(blank=True, db_comment='An integer value that provides specific information about an Athena query error.', null=True)),
                ('error_category', models.BigIntegerField(blank=True, db_comment='An integer value that specifies the category of a query failure error.', null=True)),
                ('retryable', models.BooleanField(blank=True, db_comment='True if the query might succeed if resubmitted.', null=True)),
                ('data_manifest_location', models.TextField(blank=True, db_comment='The location and file name of a data manifest file.', null=True)),
                ('data_scanned_in_bytes', models.BigIntegerField(blank=True, db_comment='The number of bytes in the data that was queried.', null=True)),
                ('engine_execution_time_in_millis', models.BigIntegerField(blank=True, db_comment='The number of milliseconds that the query took to execute.', null=True)),
                ('query_planning_time_in_millis', models.BigIntegerField(blank=True, db_comment='The number of milliseconds that Athena took to plan the query processing flow.', null=True)),
                ('query_queue_time_in_millis', models.BigIntegerField(blank=True, db_comment='The number of milliseconds that the query was in your query queue waiting for resources.', null=True)),
                ('service_processing_time_in_millis', models.BigIntegerField(blank=True, db_comment='The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.', null=True)),
                ('total_execution_time_in_millis', models.BigIntegerField(blank=True, db_comment='The number of milliseconds that Athena took to run the query.', null=True)),
                ('reused_previous_result', models.BooleanField(blank=True, db_comment='True if a previous query result was reused; false if the result was generated.', null=True)),
                ('s3_acl_option', models.TextField(blank=True, db_comment='The Amazon S3 canned ACL that Athena should specify when storing query results.', null=True)),
                ('encryption_option', models.TextField(blank=True, db_comment='Indicates whether Amazon S3 server-side encryption with Amazon S3-managed keys (SSE_S3), server-side encryption with KMS-managed keys (SSE_KMS), or client-side encryption with KMS-managed keys (CSE_KMS) is used.', null=True)),
                ('kms_key', models.TextField(blank=True, db_comment='For SSE_KMS and CSE_KMS, this is the KMS key ARN or ID.', null=True)),
                ('expected_bucket_owner', models.TextField(blank=True, db_comment='The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by ResultConfiguration$OutputLocation.', null=True)),
                ('output_location', models.TextField(blank=True, db_comment='The location in Amazon S3 where your query results are stored.', null=True)),
                ('result_reuse_by_age_enabled', models.BooleanField(blank=True, db_comment='True if previous query results can be reused when the query is run.', null=True)),
                ('result_reuse_by_age_mag_age_in_minutes', models.BigIntegerField(blank=True, db_comment='Specifies, in minutes, the maximum age of a previous query result that Athena should consider for reuse. The default is 60.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_athena_query_execution',
                'db_table_comment': 'AWS Athena Query Execution',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAthenaWorkgroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The workgroup name.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The workgroup description.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The date and time the workgroup was created.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The state of the workgroup.', null=True)),
                ('additional_configuration', models.JSONField(blank=True, db_comment='Specifies a user defined JSON string that is passed to the notebook engine.', null=True)),
                ('bytes_scanned_cutoff_per_query', models.BigIntegerField(blank=True, db_comment='The upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.', null=True)),
                ('customer_content_kms_key', models.TextField(blank=True, db_comment="Specifies the KMS key that is used to encrypt the user's data stores in Athena.", null=True)),
                ('enforce_workgroup_configuration', models.BooleanField(blank=True, db_comment='If set to "true", the settings for the workgroup override client-side settings.', null=True)),
                ('effective_engine_version', models.TextField(blank=True, db_comment='The engine version on which the query runs.', null=True)),
                ('selected_engine_version', models.TextField(blank=True, db_comment='The engine version requested by the user.', null=True)),
                ('execution_role', models.TextField(blank=True, db_comment="Role used in a notebook session for accessing the user's resources.", null=True)),
                ('publish_cloudwatch_metrics_enabled', models.BooleanField(blank=True, db_comment='Indicates that the Amazon CloudWatch metrics are enabled for the workgroup.', null=True)),
                ('requester_pays_enabled', models.BooleanField(blank=True, db_comment='If set to true, allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries.', null=True)),
                ('s3_acl_option', models.TextField(blank=True, db_comment='The Amazon S3 canned ACL that Athena should specify when storing query results.', null=True)),
                ('encryption_option', models.TextField(blank=True, db_comment='Indicates whether Amazon S3 server-side encryption with Amazon S3-managed keys (SSE_S3), server-side encryption with KMS-managed keys (SSE_KMS), or client-side encryption with KMS-managed keys (CSE_KMS) is used.', null=True)),
                ('result_configuration_kms_key', models.TextField(blank=True, db_comment='For SSE_KMS and CSE_KMS, this is the KMS key ARN or ID.', null=True)),
                ('expected_bucket_owner', models.TextField(blank=True, db_comment='The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by ResultConfiguration$OutputLocation.', null=True)),
                ('output_location', models.TextField(blank=True, db_comment='The location in Amazon S3 where your query results are stored.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_athena_workgroup',
                'db_table_comment': 'AWS Athena Workgroup',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAuditmanagerAssessment',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the assessment.', null=True)),
                ('id', models.TextField(blank=True, db_comment='An unique identifier for the assessment.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the assessment.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current status of the assessment.', null=True)),
                ('compliance_type', models.TextField(blank=True, db_comment='The name of the compliance standard related to the assessment.', null=True)),
                ('assessment_report_destination', models.TextField(blank=True, db_comment='The destination of the assessment report.', null=True)),
                ('assessment_report_destination_type', models.TextField(blank=True, db_comment='The destination type, such as Amazon S3.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='Specifies when the assessment was created.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the assessment.', null=True)),
                ('last_updated', models.DateTimeField(blank=True, db_comment='The time of the most recent update.', null=True)),
                ('aws_account', models.JSONField(blank=True, db_comment='The AWS account associated with the assessment.', null=True)),
                ('delegations', models.JSONField(blank=True, db_comment='The delegations associated with the assessment.', null=True)),
                ('framework', models.JSONField(blank=True, db_comment='The framework from which the assessment was created.', null=True)),
                ('scope', models.JSONField(blank=True, db_comment='The wrapper of AWS accounts and services in scope for the assessment.', null=True)),
                ('roles', models.JSONField(blank=True, db_comment='The roles associated with the assessment.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_auditmanager_assessment',
                'db_table_comment': 'AWS Audit Manager Assessment',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAuditmanagerControl',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the specified control.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the specified control.', null=True)),
                ('id', models.TextField(blank=True, db_comment='An unique identifier for the specified control.', primary_key=True, serialize=False)),
                ('type', models.TextField(blank=True, db_comment='The type of control, such as custom or standard.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='Specifies when the control was created.', null=True)),
                ('created_by', models.TextField(blank=True, db_comment='The IAM user or role that created the control.', null=True)),
                ('action_plan_title', models.TextField(blank=True, db_comment='The title of the action plan for remediating the control.', null=True)),
                ('action_plan_instructions', models.TextField(blank=True, db_comment='The recommended actions to carry out if the control is not fulfilled.', null=True)),
                ('control_sources', models.TextField(blank=True, db_comment='The data source that determines from where AWS Audit Manager collects evidence for the control.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the specified control.', null=True)),
                ('last_updated_at', models.DateTimeField(blank=True, db_comment='Specifies when the control was most recently updated.', null=True)),
                ('last_updated_by', models.TextField(blank=True, db_comment='The IAM user or role that most recently updated the control.', null=True)),
                ('testing_information', models.TextField(blank=True, db_comment='The steps to follow to determine if the control has been satisfied.', null=True)),
                ('control_mapping_sources', models.JSONField(blank=True, db_comment='The data mapping sources for the specified control.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_auditmanager_control',
                'db_table_comment': 'AWS Audit Manager Control',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAuditmanagerEvidence',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The identifier for the evidence.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the evidence.', null=True)),
                ('assessment_id', models.TextField(blank=True, db_comment='An unique identifier for the assessment.', null=True)),
                ('control_set_id', models.TextField(blank=True, db_comment='The identifier for the control set.', null=True)),
                ('evidence_folder_id', models.TextField(blank=True, db_comment='The identifier for the folder in which the evidence is stored.', null=True)),
                ('assessment_report_selection', models.TextField(blank=True, db_comment='Specifies whether the evidence is included in the assessment report.', null=True)),
                ('aws_account_id', models.TextField(blank=True, db_comment='The identifier for the specified AWS account.', null=True)),
                ('aws_organization', models.TextField(blank=True, db_comment='The AWS account from which the evidence is collected, and its AWS organization path.', null=True)),
                ('compliance_check', models.TextField(blank=True, db_comment='The evaluation status for evidence that falls under the compliance check category.', null=True)),
                ('data_source', models.TextField(blank=True, db_comment='The data source from which the specified evidence was collected.', null=True)),
                ('event_name', models.TextField(blank=True, db_comment='The name of the specified evidence event.', null=True)),
                ('event_source', models.TextField(blank=True, db_comment='The AWS service from which the evidence is collected.', null=True)),
                ('evidence_aws_account_id', models.TextField(blank=True, db_comment='The identifier for the specified AWS account.', null=True)),
                ('evidence_by_type', models.TextField(blank=True, db_comment='The type of automated evidence.', null=True)),
                ('iam_id', models.TextField(blank=True, db_comment='The unique identifier for the IAM user or role associated with the evidence.', null=True)),
                ('time', models.DateTimeField(blank=True, db_comment='The timestamp that represents when the evidence was collected.', null=True)),
                ('attributes', models.JSONField(blank=True, db_comment='The names and values used by the evidence event', null=True)),
                ('resources_included', models.JSONField(blank=True, db_comment='The list of resources assessed to generate the evidence.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_auditmanager_evidence',
                'db_table_comment': 'AWS Audit Manager Evidence',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAuditmanagerEvidenceFolder',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the specified evidence folder.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The identifier for the folder in which evidence is stored.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the evidence folder.', null=True)),
                ('assessment_id', models.TextField(blank=True, db_comment='The identifier for the specified assessment.', null=True)),
                ('control_set_id', models.TextField(blank=True, db_comment='The identifier for the control set.', null=True)),
                ('assessment_report_selection_count', models.BigIntegerField(blank=True, db_comment='The total count of evidence included in the assessment report.', null=True)),
                ('author', models.TextField(blank=True, db_comment='The name of the user who created the evidence folder.', null=True)),
                ('control_id', models.TextField(blank=True, db_comment='The unique identifier for the specified control.', null=True)),
                ('control_name', models.TextField(blank=True, db_comment='The name of the control.', null=True)),
                ('data_source', models.TextField(blank=True, db_comment='The AWS service from which the evidence was collected.', null=True)),
                ('date', models.DateTimeField(blank=True, db_comment='The date when the first evidence was added to the evidence folder.', null=True)),
                ('evidence_aws_service_source_count', models.BigIntegerField(blank=True, db_comment='The total number of AWS resources assessed to generate the evidence.', null=True)),
                ('evidence_by_type_compliance_check_count', models.BigIntegerField(blank=True, db_comment='The number of evidence that falls under the compliance check category.', null=True)),
                ('evidence_by_type_compliance_check_issues_count', models.BigIntegerField(blank=True, db_comment='The total number of issues that were reported directly from AWS Security Hub, AWS Config, or both.', null=True)),
                ('evidence_by_type_configuration_data_count', models.BigIntegerField(blank=True, db_comment='The number of evidence that falls under the configuration data category.', null=True)),
                ('evidence_by_type_manual_count', models.BigIntegerField(blank=True, db_comment='The number of evidence that falls under the manual category.', null=True)),
                ('evidence_by_type_user_activity_count', models.BigIntegerField(blank=True, db_comment='The number of evidence that falls under the user activity category.', null=True)),
                ('evidence_resources_included_count', models.BigIntegerField(blank=True, db_comment='The amount of evidence included in the evidence folder.', null=True)),
                ('total_evidence', models.BigIntegerField(blank=True, db_comment='The total amount of evidence in the evidence folder.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_auditmanager_evidence_folder',
                'db_table_comment': 'AWS Audit Manager Evidence Folder',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAuditmanagerFramework',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the specified framework.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the framework.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The unique identified for the specified framework.', primary_key=True, serialize=False)),
                ('type', models.TextField(blank=True, db_comment='The framework type, such as standard or custom.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='Specifies when the framework was created.', null=True)),
                ('created_by', models.TextField(blank=True, db_comment='The IAM user or role that created the framework.', null=True)),
                ('compliance_type', models.TextField(blank=True, db_comment='The compliance type that the new custom framework supports, such as CIS or HIPAA.', null=True)),
                ('controls_count', models.BigIntegerField(blank=True, db_comment='The number of controls associated with the specified framework.', null=True)),
                ('control_sets_count', models.BigIntegerField(blank=True, db_comment='The number of control sets associated with the specified framework.', null=True)),
                ('control_sources', models.TextField(blank=True, db_comment='The sources from which AWS Audit Manager collects evidence for the control.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the specified framework.', null=True)),
                ('last_updated_at', models.DateTimeField(blank=True, db_comment='Specifies when the framework was most recently updated.', null=True)),
                ('last_updated_by', models.TextField(blank=True, db_comment='The IAM user or role that most recently updated the framework.', null=True)),
                ('logo', models.TextField(blank=True, db_comment='The logo associated with the framework.', null=True)),
                ('control_sets', models.JSONField(blank=True, db_comment='The control sets associated with the framework.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_auditmanager_framework',
                'db_table_comment': 'AWS Audit Manager Framework',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsAvailabilityZone',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the Availability Zone, Local Zone, or Wavelength Zone', null=True)),
                ('zone_id', models.TextField(blank=True, db_comment='The ID of the Availability Zone, Local Zone, or Wavelength Zone.', null=True)),
                ('zone_type', models.TextField(blank=True, db_comment='The type of zone. The valid values are availability-zone, local-zone, and wavelength-zone.', null=True)),
                ('opt_in_status', models.TextField(blank=True, db_comment='For Availability Zones, this parameter always has the value of opt-in-not-required. For Local Zones and Wavelength Zones, this parameter is the opt-in status. The possible values are opted-in, and not-opted-in.', null=True)),
                ('group_name', models.TextField(blank=True, db_comment='For Availability Zones, this parameter has the same value as the Region name. For Local Zones, the name of the associated group, for example us-west-2-lax-1. For Wavelength Zones, the name of the associated group, for example us-east-1-wl1-bos-wlz-1.', null=True)),
                ('region_name', models.TextField(blank=True, db_comment='The name of the Region.', null=True)),
                ('parent_zone_name', models.TextField(blank=True, db_comment='The name of the zone that handles some of the Local Zone or Wavelength Zone control plane operations, such as API calls.', null=True)),
                ('parent_zone_id', models.TextField(blank=True, db_comment='The ID of the zone that handles some of the Local Zone or Wavelength Zone control plane operations, such as API calls', null=True)),
                ('messages', models.TextField(blank=True, db_comment='Any messages about the Availability Zone, Local Zone, or Wavelength Zone.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_availability_zone',
                'db_table_comment': 'AWS Availability Zone',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsBackupFramework',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('framework_name', models.TextField(blank=True, db_comment='The unique name of a backup framework.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='An Amazon Resource Name (ARN) that uniquely identifies a backup framework resource.', null=True)),
                ('framework_description', models.TextField(blank=True, db_comment='An optional description of the backup framework.', null=True)),
                ('deployment_status', models.TextField(blank=True, db_comment='The deployment status of a backup framework.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The date and time that a framework was created.', null=True)),
                ('number_of_controls', models.BigIntegerField(blank=True, db_comment='The number of controls contained by the framework.', null=True)),
                ('framework_status', models.TextField(blank=True, db_comment='The framework status based on recording statuses for resources governed by the framework (ACTIVE | PARTIALLY_ACTIVE | INACTIVE | UNAVAILABLE).', null=True)),
                ('framework_controls', models.JSONField(blank=True, db_comment='A list of the controls that make up the framework. Each control in the list has a name, input parameters, and scope.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_backup_framework',
                'db_table_comment': 'AWS Backup Framework',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsBackupJob',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('job_id', models.TextField(blank=True, db_comment='The logical id of a backup job.', null=True)),
                ('recovery_point_arn', models.TextField(blank=True, db_comment='An Amazon Resource Name (ARN) that uniquely identifies a recovery point.', null=True)),
                ('backup_vault_arn', models.TextField(blank=True, db_comment='An Amazon Resource Name (ARN) that uniquely identifies the target backup vault.', null=True)),
                ('resource_type', models.TextField(blank=True, db_comment='The type of AWS resource to be backed up.', null=True)),
                ('resource_arn', models.TextField(blank=True, db_comment='An Amazon Resource Name (ARN) that uniquely identifies the source resource in the recovery point.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current state of a backup job.', null=True)),
                ('status_message', models.TextField(blank=True, db_comment='A detailed message explaining the status of the job.', null=True)),
                ('backup_size', models.BigIntegerField(blank=True, db_comment='The size in bytes of a backup.', null=True)),
                ('backup_vault_name', models.TextField(blank=True, db_comment='The name of the target backup vault.', null=True)),
                ('backup_options', models.JSONField(blank=True, db_comment='Specifies the backup options for a selected resource.', null=True)),
                ('backup_type', models.TextField(blank=True, db_comment='Represents the type of backup for a backup job.', null=True)),
                ('bytes_transferred', models.BigIntegerField(blank=True, db_comment='The size in bytes transferred to a backup vault at the time that the job status was queried.', null=True)),
                ('completion_date', models.DateTimeField(blank=True, db_comment='The date and time a backup job is completed.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The date and time a backup job is created.', null=True)),
                ('expected_completion_date', models.DateTimeField(blank=True, db_comment='The date and time a backup job is expected to be completed.', null=True)),
                ('iam_role_arn', models.TextField(blank=True, db_comment='The ARN of the IAM role that AWS Backup uses to create the target recovery point.', null=True)),
                ('is_parent', models.BooleanField(blank=True, db_comment='A Boolean value that is returned as TRUE if the specified job is a parent job.', null=True)),
                ('parent_job_id', models.TextField(blank=True, db_comment='The ID of the parent backup job, if there is one.', null=True)),
                ('percent_done', models.TextField(blank=True, db_comment='The percentage of job completion.', null=True)),
                ('start_by', models.DateTimeField(blank=True, db_comment='The date and time a backup job must be started before it is canceled.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_backup_job',
                'db_table_comment': 'AWS Backup Job',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsBackupLegalHold',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('legal_hold_id', models.TextField(blank=True, db_comment='ID of specific legal hold on one or more recovery points.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='This is an Amazon Resource Number (ARN) that uniquely identifies the legal hold.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='This is the time in number format when legal hold was created.', null=True)),
                ('status', models.TextField(blank=True, db_comment='This is the status of the legal hold. Statuses can be ACTIVE, CREATING, CANCELED, and CANCELING.', null=True)),
                ('cancellation_date', models.DateTimeField(blank=True, db_comment='This is the time in number format when legal hold was cancelled.', null=True)),
                ('description', models.TextField(blank=True, db_comment='This is the description of a legal hold.', null=True)),
                ('retain_record_until', models.DateTimeField(blank=True, db_comment='This is the date and time until which the legal hold record will be retained.', null=True)),
                ('recovery_point_selection', models.JSONField(blank=True, db_comment='This specifies criteria to assign a set of resources, such as resource types or backup vaults.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_backup_legal_hold',
                'db_table_comment': 'AWS Backup Legal Hold',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsBackupPlan',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The display name of a saved backup plan.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='An Amazon Resource Name (ARN) that uniquely identifies a backup plan.', null=True)),
                ('backup_plan_id', models.TextField(blank=True, db_comment='Specifies the id to identify a backup plan uniquely.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The date and time a resource backup plan is created.', null=True)),
                ('deletion_date', models.DateTimeField(blank=True, db_comment='The date and time a backup plan is deleted.', null=True)),
                ('last_execution_date', models.DateTimeField(blank=True, db_comment='The last time a job to back up resources was run with this rule.', null=True)),
                ('creator_request_id', models.TextField(blank=True, db_comment='An unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.', null=True)),
                ('version_id', models.TextField(blank=True, db_comment='Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.', null=True)),
                ('backup_plan', models.JSONField(blank=True, db_comment='Specifies the body of a backup plan.', null=True)),
                ('advanced_backup_settings', models.JSONField(blank=True, db_comment='Contains a list of BackupOptions for a resource type.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_backup_plan',
                'db_table_comment': 'AWS Backup Plan',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsBackupProtectedResource',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('resource_arn', models.TextField(blank=True, db_comment='An Amazon Resource Name (ARN) that uniquely identifies a resource.', null=True)),
                ('resource_type', models.TextField(blank=True, db_comment='The type of Amazon Web Services resource.', null=True)),
                ('last_backup_time', models.DateTimeField(blank=True, db_comment='The date and time a resource was last backed up.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_backup_protected_resource',
                'db_table_comment': 'AWS Backup Protected Resource',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsBackupRecoveryPoint',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('backup_vault_name', models.TextField(blank=True, db_comment='The name of a logical container where backups are stored.', null=True)),
                ('recovery_point_arn', models.TextField(blank=True, db_comment='An ARN that uniquely identifies a recovery point.', null=True)),
                ('resource_type', models.TextField(blank=True, db_comment='The type of Amazon Web Services resource to save as a recovery point.', null=True)),
                ('status', models.TextField(blank=True, db_comment='A status code specifying the state of the recovery point.', null=True)),
                ('backup_size_in_bytes', models.BigIntegerField(blank=True, db_comment='The size, in bytes, of a backup.', null=True)),
                ('backup_vault_arn', models.TextField(blank=True, db_comment='An ARN that uniquely identifies a backup vault.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The date and time that a recovery point is created.', null=True)),
                ('completion_date', models.DateTimeField(blank=True, db_comment='The date and time that a job to create a recovery point is completed.', null=True)),
                ('encryption_key_arn', models.TextField(blank=True, db_comment='The server-side encryption key used to protect your backups.', null=True)),
                ('iam_role_arn', models.TextField(blank=True, db_comment='Specifies the IAM role ARN used to create the target recovery point.', null=True)),
                ('is_encrypted', models.BooleanField(blank=True, db_comment='A Boolean value that is returned as TRUE if the specified recovery point is encrypted, or FALSE if the recovery point is not encrypted.', null=True)),
                ('last_restore_time', models.DateTimeField(blank=True, db_comment='The date and time that a recovery point was last restored.', null=True)),
                ('resource_arn', models.TextField(blank=True, db_comment='An ARN that uniquely identifies a saved resource.', null=True)),
                ('source_backup_vault_arn', models.TextField(blank=True, db_comment='An Amazon Resource Name (ARN) that uniquely identifies the source vault where the resource was originally backed up in.', null=True)),
                ('status_message', models.TextField(blank=True, db_comment='A status message explaining the reason for the recovery point deletion failure.', null=True)),
                ('storage_class', models.TextField(blank=True, db_comment='Specifies the storage class of the recovery point. Valid values are WARM or COLD.', null=True)),
                ('calculated_lifecycle', models.JSONField(blank=True, db_comment='An object containing DeleteAt and MoveToColdStorageAt timestamps.', null=True)),
                ('created_by', models.JSONField(blank=True, db_comment='Contains identifying information about the creation of a recovery point, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan used to create it.', null=True)),
                ('lifecycle', models.JSONField(blank=True, db_comment='The lifecycle defines when a protected resource is transitioned to cold storage and when it expires.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_backup_recovery_point',
                'db_table_comment': 'AWS Backup Recovery Point',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsBackupReportPlan',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='An Amazon Resource Name (ARN) that uniquely identifies a resource.', null=True)),
                ('report_plan_name', models.TextField(blank=True, db_comment='The unique name of the report plan.', null=True)),
                ('description', models.TextField(blank=True, db_comment='An optional description of the report plan with a maximum 1,024 characters.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The date and time that a report plan is created, in Unix format and Coordinated Universal Time (UTC).', null=True)),
                ('deployment_status', models.TextField(blank=True, db_comment='The deployment status of a report plan. The statuses are CREATE_IN_PROGRESS, UPDATE_IN_PROGRESS, DELETE_IN_PROGRESS, and COMPLETED.', null=True)),
                ('last_attempted_execution_time', models.DateTimeField(blank=True, db_comment='The date and time that a report job associated with this report plan last attempted to run, in Unix format and Coordinated Universal Time (UTC).', null=True)),
                ('last_successful_execution_time', models.DateTimeField(blank=True, db_comment='The date and time that a report job associated with this report plan last successfully ran, in Unix format and Coordinated Universal Time (UTC).', null=True)),
                ('report_delivery_channel', models.JSONField(blank=True, db_comment='Contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.', null=True)),
                ('report_setting', models.JSONField(blank=True, db_comment='Identifies the report template for the report. Reports are built using a report template.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_backup_report_plan',
                'db_table_comment': 'AWS Backup Report Plan',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsBackupSelection',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('selection_name', models.TextField(blank=True, db_comment='The display name of a resource selection document.', null=True)),
                ('selection_id', models.TextField(blank=True, db_comment='Uniquely identifies a request to assign a set of resources to a backup plan.', null=True)),
                ('backup_plan_id', models.TextField(blank=True, db_comment='An ID that uniquely identifies a backup plan.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the backup selection.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The date and time a resource backup plan is created.', null=True)),
                ('creator_request_id', models.TextField(blank=True, db_comment='An unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.', null=True)),
                ('iam_role_arn', models.TextField(blank=True, db_comment='Specifies the IAM role Amazon Resource Name (ARN) to create the target recovery point.', null=True)),
                ('list_of_tags', models.JSONField(blank=True, db_comment='An array of conditions used to specify a set of resources to assign to a backup plan.', null=True)),
                ('resources', models.JSONField(blank=True, db_comment='Contains a list of BackupOptions for a resource type.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_backup_selection',
                'db_table_comment': 'AWS Backup Selection',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsBackupVault',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of a logical container where backups are stored.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='An Amazon Resource Name (ARN) that uniquely identifies a backup vault.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The date and time a resource backup is created.', null=True)),
                ('creator_request_id', models.TextField(blank=True, db_comment='An unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.', null=True)),
                ('encryption_key_arn', models.TextField(blank=True, db_comment='The server-side encryption key that is used to protect your backups.', null=True)),
                ('number_of_recovery_points', models.FloatField(blank=True, db_comment='The number of recovery points that are stored in a backup vault.', null=True)),
                ('sns_topic_arn', models.TextField(blank=True, db_comment='An ARN that uniquely identifies an Amazon Simple Notification Service.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='The backup vault access policy document in JSON format.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the backup vault access policy document in a canonical form for easier searching.', null=True)),
                ('backup_vault_events', models.JSONField(blank=True, db_comment='An array of events that indicate the status of jobs to back up resources to the backup vault.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_backup_vault',
                'db_table_comment': 'AWS Backup Vault',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudformationStack',
            fields=[
                ('id', models.TextField(blank=True, db_comment='Unique identifier of the stack.', primary_key=True, serialize=False)),
                ('name', models.TextField(blank=True, db_comment='The name associated with the stack.', null=True)),
                ('status', models.TextField(blank=True, db_comment='Current status of the stack.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The time at which the stack was created.', null=True)),
                ('disable_rollback', models.BooleanField(blank=True, db_comment='Boolean to enable or disable rollback on stack creation failures.', null=True)),
                ('enable_termination_protection', models.BooleanField(blank=True, db_comment='Specifies whether termination protection is enabled for the stack.', null=True)),
                ('last_updated_time', models.DateTimeField(blank=True, db_comment='The time the stack was last updated. This field will only be returned if the stack has been updated at least once.', null=True)),
                ('parent_id', models.TextField(blank=True, db_comment='ID of the direct parent of this stack.', null=True)),
                ('role_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that is associated with the stack.', null=True)),
                ('root_id', models.TextField(blank=True, db_comment='ID of the top-level stack to which the nested stack ultimately belongs.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A user-defined description associated with the stack.', null=True)),
                ('notification_arns', models.JSONField(blank=True, db_comment='SNS topic ARNs to which stack related events are published.', null=True)),
                ('outputs', models.JSONField(blank=True, db_comment='A list of output structures.', null=True)),
                ('rollback_configuration', models.JSONField(blank=True, db_comment='The rollback triggers for AWS CloudFormation to monitor during stack creation and updating operations, and for the specified monitoring period afterwards.', null=True)),
                ('capabilities', models.JSONField(blank=True, db_comment='The capabilities allowed in the stack.', null=True)),
                ('stack_drift_status', models.TextField(blank=True, db_comment="Status of the stack's actual configuration compared to its expected template configuration.", null=True)),
                ('parameters', models.JSONField(blank=True, db_comment='A list of Parameter structures.', null=True)),
                ('template_body', models.TextField(blank=True, db_comment='Structure containing the template body.', null=True)),
                ('template_body_json', models.JSONField(blank=True, db_comment='Structure containing the template body. Parsed into json object for better readability.', null=True)),
                ('resources', models.JSONField(blank=True, db_comment='A list of Stack resource structures.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with stack.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudformation_stack',
                'db_table_comment': 'AWS CloudFormation Stack',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudformationStackResource',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('logical_resource_id', models.TextField(blank=True, db_comment='The logical name of the resource specified in the template.', null=True)),
                ('stack_name', models.TextField(blank=True, db_comment='The name associated with the stack.', null=True)),
                ('stack_id', models.TextField(blank=True, db_comment='Unique identifier of the stack.', null=True)),
                ('last_updated_timestamp', models.DateTimeField(blank=True, db_comment='Time the status was updated.', null=True)),
                ('resource_status', models.TextField(blank=True, db_comment='Current status of the resource.', null=True)),
                ('resource_type', models.TextField(blank=True, db_comment='Type of resource.', null=True)),
                ('description', models.TextField(blank=True, db_comment='User defined description associated with the resource.', null=True)),
                ('physical_resource_id', models.TextField(blank=True, db_comment='The name or unique identifier that corresponds to a physical instance ID of a resource supported by CloudFormation.', null=True)),
                ('resource_status_reason', models.TextField(blank=True, db_comment='Success/failure message associated with the resource.', null=True)),
                ('drift_information', models.JSONField(blank=True, db_comment="Information about whether the resource's actual configuration differs, or has drifted, from its expected configuration, as defined in the stack template and any values specified as template parameters. For more information, see Detecting Unregulated Configuration Changes to Stacks and Resources.", null=True)),
                ('module_info', models.JSONField(blank=True, db_comment='Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudformation_stack_resource',
                'db_table_comment': 'AWS CloudFormation Stack Resource',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudformationStackSet',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('stack_set_id', models.TextField(blank=True, db_comment='The ID of the stack set.', null=True)),
                ('stack_set_name', models.TextField(blank=True, db_comment='The name of the stack set.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the stack set.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the stack set.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the stack set that you specify when the stack set is created or updated.', null=True)),
                ('drift_status', models.TextField(blank=True, db_comment="Status of the stack set's actual configuration compared to its expected template and parameter configuration. A stack set is considered to have drifted if one or more of its stack instances have drifted from their expected template and parameter configuration.", null=True)),
                ('last_drift_check_timestamp', models.DateTimeField(blank=True, db_comment='Most recent time when CloudFormation performed a drift detection operation on the stack set.', null=True)),
                ('permission_model', models.TextField(blank=True, db_comment='Describes how the IAM roles required for stack set operations are created.', null=True)),
                ('administration_role_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the IAM role used to create or update the stack set.', null=True)),
                ('execution_role_name', models.TextField(blank=True, db_comment='The name of the IAM execution role used to create or update the stack set.', null=True)),
                ('template_body', models.TextField(blank=True, db_comment='The structure that contains the body of the template that was used to create or update the stack set.', null=True)),
                ('auto_deployment', models.JSONField(blank=True, db_comment='Describes whether StackSets automatically deploys to Organizations accounts that are added to a target organizational unit (OU).', null=True)),
                ('capabilities', models.JSONField(blank=True, db_comment='The capabilities that are allowed in the stack set.', null=True)),
                ('organizational_unit_ids', models.JSONField(blank=True, db_comment='The organization root ID or organizational unit (OU) IDs that you specified for DeploymentTargets.', null=True)),
                ('parameters', models.JSONField(blank=True, db_comment='A list of input parameters for a stack set.', null=True)),
                ('stack_set_drift_detection_details', models.JSONField(blank=True, db_comment='Detailed information about the drift status of the stack set.', null=True)),
                ('managed_execution', models.JSONField(blank=True, db_comment='Describes whether StackSets performs non-conflicting operations concurrently and queues conflicting operations.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with stack.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudformation_stack_set',
                'db_table_comment': 'AWS CloudFormation Stack Set',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudfrontCachePolicy',
            fields=[
                ('name', models.TextField(blank=True, db_comment='A unique name to identify the cache policy.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The unique identifier for the cache policy.', primary_key=True, serialize=False)),
                ('comment', models.TextField(blank=True, db_comment='A comment to describe the cache policy.', null=True)),
                ('default_ttl', models.BigIntegerField(blank=True, db_comment='The default amount of time, in seconds, that you want objects to stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated.', null=True)),
                ('etag', models.TextField(blank=True, db_comment='The current version of the cache policy.', null=True)),
                ('max_ttl', models.BigIntegerField(blank=True, db_comment='The maximum amount of time, in seconds, that you want objects to stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated.', null=True)),
                ('min_ttl', models.BigIntegerField(blank=True, db_comment='The minimum amount of time, in seconds, that you want objects to stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated.', null=True)),
                ('last_modified_time', models.DateTimeField(blank=True, db_comment='The date and time when the cache policy was last modified.', null=True)),
                ('parameters_in_cache_key_and_forwarded_to_origin', models.JSONField(blank=True, db_comment='The HTTP headers, cookies, and URL query strings to include in the cache key. The values included in the cache key are automatically included in requests that CloudFront sends to the origin.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudfront_cache_policy',
                'db_table_comment': 'AWS CloudFront Cache Policy',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudfrontDistribution',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The identifier for the Distribution.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The ARN (Amazon Resource Name) for the distribution.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current status of the Distribution.', null=True)),
                ('caller_reference', models.TextField(blank=True, db_comment="A unique value that ensures that the request can't be replayed.", null=True)),
                ('comment', models.TextField(blank=True, db_comment='The comment originally specified when this Distribution was created.', null=True)),
                ('default_root_object', models.TextField(blank=True, db_comment='The object that you want CloudFront to request from your origin.', null=True)),
                ('domain_name', models.TextField(blank=True, db_comment='The domain name that corresponds to the Distribution.', null=True)),
                ('enabled', models.BooleanField(blank=True, db_comment='Whether the Distribution is enabled to accept user requests for content.', null=True)),
                ('e_tag', models.TextField(blank=True, db_comment='The current version of the configuration.', null=True)),
                ('http_version', models.TextField(blank=True, db_comment="Specify the maximum HTTP version that you want viewers to use to communicate with CloudFront. The default value for new web Distributions is http2. Viewers that don't support HTTP/2 will automatically use an earlier version.", null=True)),
                ('is_ipv6_enabled', models.BooleanField(blank=True, db_comment='Whether CloudFront responds to IPv6 DNS requests with an IPv6 address for your Distribution.', null=True)),
                ('in_progress_invalidation_batches', models.BigIntegerField(blank=True, db_comment='The number of invalidation batches currently in progress.', null=True)),
                ('last_modified_time', models.DateTimeField(blank=True, db_comment='The date and time the Distribution was last modified.', null=True)),
                ('price_class', models.TextField(blank=True, db_comment='A complex type that contains information about price class for this streaming Distribution.', null=True)),
                ('web_acl_id', models.TextField(blank=True, db_comment='The Web ACL Id (if any) associated with the distribution.', null=True)),
                ('active_trusted_key_groups', models.JSONField(blank=True, db_comment='CloudFront automatically adds this field to the response if you’ve configured a cache behavior in this distribution to serve private content using key groups.', null=True)),
                ('active_trusted_signers', models.JSONField(blank=True, db_comment='A list of AWS accounts and the identifiers of active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs and signed cookies.', null=True)),
                ('aliases', models.JSONField(blank=True, db_comment='A complex type that contains information about CNAMEs (alternate domain names),if any, for this distribution.', null=True)),
                ('alias_icp_recordals', models.JSONField(blank=True, db_comment="AWS services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP recordal status for CNAMEs associated with distributions.", null=True)),
                ('cache_behaviors', models.JSONField(blank=True, db_comment='The number of cache behaviors for this Distribution.', null=True)),
                ('custom_error_responses', models.JSONField(blank=True, db_comment='A complex type that contains zero or more CustomErrorResponses elements.', null=True)),
                ('default_cache_behavior', models.JSONField(blank=True, db_comment="A complex type that describes the default cache behavior if you don't specify a CacheBehavior element or if files don't match any of the values of PathPattern in CacheBehavior elements. You must create exactly one default cache behavior.", null=True)),
                ('logging', models.JSONField(blank=True, db_comment='A complex type that controls whether access logs are written for the distribution.', null=True)),
                ('origins', models.JSONField(blank=True, db_comment='A complex type that contains information about origins for this distribution.', null=True)),
                ('origin_groups', models.JSONField(blank=True, db_comment='A complex type that contains information about origin groups for this distribution.', null=True)),
                ('restrictions', models.JSONField(blank=True, db_comment='A complex type that identifies ways in which you want to restrict distribution of your content.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the Maintenance Window', null=True)),
                ('viewer_certificate', models.JSONField(blank=True, db_comment="A complex type that determines the distribution's SSL/TLS configuration for communicating with viewers.", null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudfront_distribution',
                'db_table_comment': 'AWS CloudFront Distribution',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudfrontFunction',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the CloudFront function.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The version identifier for the current version of the CloudFront function.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the CloudFront function.', null=True)),
                ('e_tag', models.TextField(blank=True, db_comment='The version identifier for the current version of the CloudFront function.', null=True)),
                ('function_config', models.JSONField(blank=True, db_comment='Contains configuration information about a CloudFront function.', null=True)),
                ('function_metadata', models.JSONField(blank=True, db_comment='Contains metadata about a CloudFront function.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudfront_function',
                'db_table_comment': 'AWS CloudFront Function',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudfrontOriginAccessIdentity',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The ID for the origin access identity.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the origin access identity.', null=True)),
                ('s3_canonical_user_id', models.TextField(blank=True, db_comment='The Amazon S3 canonical user ID for the origin access identity, which you use when giving the origin access identity read permission to an object in Amazon S3.', null=True)),
                ('caller_reference', models.TextField(blank=True, db_comment="A unique value that ensures that the request can't be replayed.", null=True)),
                ('comment', models.TextField(blank=True, db_comment='The comment for this origin access identity.', null=True)),
                ('etag', models.TextField(blank=True, db_comment="The current version of the origin access identity's information.", null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudfront_origin_access_identity',
                'db_table_comment': 'AWS CloudFront Origin Access Identity',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudfrontOriginRequestPolicy',
            fields=[
                ('name', models.TextField(blank=True, db_comment='A unique name to identify the origin request policy.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The ID for the origin request policy.', primary_key=True, serialize=False)),
                ('comment', models.TextField(blank=True, db_comment='The comment for this origin request policy.', null=True)),
                ('etag', models.TextField(blank=True, db_comment='The current version of the origin request policy.', null=True)),
                ('last_modified_time', models.DateTimeField(blank=True, db_comment='The date and time when the origin request policy was last modified.', null=True)),
                ('cookies_config', models.JSONField(blank=True, db_comment='The cookies from viewer requests to include in origin requests.', null=True)),
                ('headers_config', models.JSONField(blank=True, db_comment='The HTTP headers to include in origin requests.', null=True)),
                ('query_strings_config', models.JSONField(blank=True, db_comment='The URL query strings from viewer requests to include in origin requests.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudfront_origin_request_policy',
                'db_table_comment': 'AWS CloudFront Origin Request Policy',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudfrontResponseHeadersPolicy',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the response headers policy.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The identifier for the response headers policy.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The version identifier for the current version of the response headers policy.', null=True)),
                ('last_modified_time', models.DateTimeField(blank=True, db_comment='The date and time when the response headers policy was last modified.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of response headers policy, either managed (created by AWS) or custom (created in this AWS account).', null=True)),
                ('etag', models.TextField(blank=True, db_comment='The version identifier for the current version of the response headers policy.', null=True)),
                ('response_headers_policy_config', models.JSONField(blank=True, db_comment='A response headers policy contains information about a set of HTTP response headers and their values. CloudFront adds the headers in the policy to HTTP responses that it sends for requests that match a cache behavior that’s associated with the policy.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudfront_response_headers_policy',
                'db_table_comment': 'AWS Cloudfront Response Headers Policy',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudsearchDomain',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('domain_name', models.TextField(blank=True, db_comment='A string that represents the name of a domain.', null=True)),
                ('domain_id', models.TextField(blank=True, db_comment='An internally generated unique identifier for a domain.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the search domain.', null=True)),
                ('created', models.BooleanField(blank=True, db_comment='True if the search domain is created.', null=True)),
                ('deleted', models.BooleanField(blank=True, db_comment='True if the search domain has been deleted.', null=True)),
                ('processing', models.BooleanField(blank=True, db_comment='True if processing is being done to activate the current domain configuration.', null=True)),
                ('requires_index_documents', models.BooleanField(blank=True, db_comment='True if Index Documents need to be called to activate the current domain configuration.', null=True)),
                ('search_instance_count', models.BigIntegerField(blank=True, db_comment='The number of search instances that are available to process search requests.', null=True)),
                ('search_instance_type', models.TextField(blank=True, db_comment='The instance type that is being used to process search requests.', null=True)),
                ('search_partition_count', models.BigIntegerField(blank=True, db_comment='The number of partitions across which the search index is spread.', null=True)),
                ('doc_service', models.JSONField(blank=True, db_comment='The service endpoint for updating documents in a search domain.', null=True)),
                ('limits', models.JSONField(blank=True, db_comment='Limit details for a search domain.', null=True)),
                ('search_service', models.JSONField(blank=True, db_comment='The service endpoint for requesting search results from a search domain.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudsearch_domain',
                'db_table_comment': 'AWS CloudSearch Domain',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudtrailChannel',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the cloudtrail channel.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of a channel.', null=True)),
                ('apply_to_all_regions', models.BooleanField(blank=True, db_comment='Specifies whether the channel applies to a single region or to all regions.', null=True)),
                ('source', models.TextField(blank=True, db_comment='The event source for the cloudtrail channel.', null=True)),
                ('advanced_event_selectors', models.JSONField(blank=True, db_comment='The advanced event selectors that are configured for the channel.', null=True)),
                ('destinations', models.JSONField(blank=True, db_comment='The Amazon Web Services service that created the service-linked channel.', null=True)),
                ('source_config', models.JSONField(blank=True, db_comment='Configuration information about the channel.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudtrail_channel',
                'db_table_comment': 'AWS CloudTrail Channel',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudtrailEventDataStore',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the event data store.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the event data store.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of an event data store.', null=True)),
                ('created_timestamp', models.DateTimeField(blank=True, db_comment="The timestamp of the event data store's creation.", null=True)),
                ('multi_region_enabled', models.BooleanField(blank=True, db_comment='Indicates whether the event data store includes events from all regions, or only from the region in which it was created.', null=True)),
                ('organization_enabled', models.BooleanField(blank=True, db_comment='Indicates that an event data store is collecting logged events for an organization.', null=True)),
                ('retention_period', models.BigIntegerField(blank=True, db_comment='The retention period, in days.', null=True)),
                ('termination_protection_enabled', models.BooleanField(blank=True, db_comment='Indicates whether the event data store is protected from termination.', null=True)),
                ('updated_timestamp', models.DateTimeField(blank=True, db_comment='The timestamp showing when an event data store was updated, if applicable. UpdatedTimestamp is always either the same or newer than the time shown in CreatedTimestamp.', null=True)),
                ('advanced_event_selectors', models.JSONField(blank=True, db_comment='The advanced event selectors that were used to select events for the data store.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudtrail_event_data_store',
                'db_table_comment': 'AWS CloudTrail Event Data Store',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudtrailImport',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('import_id', models.TextField(blank=True, db_comment='The ID of the import.', null=True)),
                ('created_timestamp', models.DateTimeField(blank=True, db_comment="The timestamp of the import's creation.", null=True)),
                ('import_status', models.TextField(blank=True, db_comment='The status of the import.', null=True)),
                ('end_event_time', models.DateTimeField(blank=True, db_comment='Used with EndEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.', null=True)),
                ('start_event_time', models.DateTimeField(blank=True, db_comment='Used with StartEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.', null=True)),
                ('updated_timestamp', models.DateTimeField(blank=True, db_comment="The timestamp of the import's last update.", null=True)),
                ('destinations', models.JSONField(blank=True, db_comment='The ARN of the destination event data store.', null=True)),
                ('import_source', models.JSONField(blank=True, db_comment='The source S3 bucket.', null=True)),
                ('import_statistics', models.JSONField(blank=True, db_comment='Provides statistics for the import.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudtrail_import',
                'db_table_comment': 'AWS CloudTrail Import',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudtrailLookupEvent',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('event_id', models.TextField(blank=True, db_comment='The CloudTrail ID of the event returned.', null=True)),
                ('event_name', models.TextField(blank=True, db_comment='The name of the event returned.', null=True)),
                ('event_source', models.TextField(blank=True, db_comment='The Amazon Web Services service to which the request was made.', null=True)),
                ('read_only', models.TextField(blank=True, db_comment='Information about whether the event is a write event or a read event.', null=True)),
                ('access_key_id', models.TextField(blank=True, db_comment='The AWS access key ID that was used to sign the request. If the request was made with temporary security credentials, this is the access key ID of the temporary credentials.', null=True)),
                ('event_time', models.DateTimeField(blank=True, db_comment='The date and time of the event returned.', null=True)),
                ('end_time', models.DateTimeField(blank=True, db_comment='Specifies that only events that occur before or at the specified time are returned. If the specified end time is before the specified start time, an error is returned.', null=True)),
                ('start_time', models.DateTimeField(blank=True, db_comment='Specifies that only events that occur after or at the specified time are returned. If the specified start time is after the specified end time, an error is returned.', null=True)),
                ('resource_name', models.TextField(blank=True, db_comment='The name of the resource.', null=True)),
                ('resource_type', models.TextField(blank=True, db_comment='The resource type.', null=True)),
                ('username', models.TextField(blank=True, db_comment='A user name or role name of the requester that called the API in the event returned.', null=True)),
                ('resources', models.JSONField(blank=True, db_comment='A list of resources referenced by the event returned.', null=True)),
                ('cloud_trail_event', models.JSONField(blank=True, db_comment='A JSON string that contains a representation of the event returned.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudtrail_lookup_event',
                'db_table_comment': 'AWS CloudTrail Lookup Event',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudtrailQuery',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('query_id', models.TextField(blank=True, db_comment='The ID of the query.', null=True)),
                ('event_data_store_arn', models.TextField(blank=True, db_comment='The ID of the event data store.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The creation time of the query.', null=True)),
                ('delivery_s3_uri', models.TextField(blank=True, db_comment='The URI for the S3 bucket where CloudTrail delivered query results, if applicable.', null=True)),
                ('delivery_status', models.TextField(blank=True, db_comment='The delivery status.', null=True)),
                ('error_message', models.TextField(blank=True, db_comment='The error message returned if a query failed.', null=True)),
                ('query_status', models.TextField(blank=True, db_comment='The status of a query. Values for QueryStatus include QUEUED, RUNNING, FINISHED, FAILED, TIMED_OUT, or CANCELLED.', null=True)),
                ('bytes_scanned', models.BigIntegerField(blank=True, db_comment="Gets metadata about a query, including the number of events that were matched, the total number of events scanned, the query run time in milliseconds, and the query's creation time.", null=True)),
                ('events_matched', models.BigIntegerField(blank=True, db_comment='The number of events that matched a query.', null=True)),
                ('events_scanned', models.BigIntegerField(blank=True, db_comment='The number of events that the query scanned in the event data store.', null=True)),
                ('execution_time_in_millis', models.BigIntegerField(blank=True, db_comment="The query's run time, in milliseconds.", null=True)),
                ('query_string', models.TextField(blank=True, db_comment='The SQL code of a query.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudtrail_query',
                'db_table_comment': 'AWS CloudTrail Query',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudtrailTrail',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the trail.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the trail.', null=True)),
                ('home_region', models.TextField(blank=True, db_comment='The region in which the trail was created.', null=True)),
                ('is_multi_region_trail', models.BooleanField(blank=True, db_comment='Specifies whether the trail exists only in one region or exists in all regions.', null=True)),
                ('log_file_validation_enabled', models.BooleanField(blank=True, db_comment='Specifies whether log file validation is enabled, or not.', null=True)),
                ('is_logging', models.BooleanField(blank=True, db_comment='Specifies whether the CloudTrail is currently logging AWS API calls, or not.', null=True)),
                ('log_group_arn', models.TextField(blank=True, db_comment='Specifies an Amazon Resource Name (ARN), a unique identifier that represents the log group to which CloudTrail logs will be delivered.', null=True)),
                ('cloudwatch_logs_role_arn', models.TextField(blank=True, db_comment="Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.", null=True)),
                ('has_custom_event_selectors', models.BooleanField(blank=True, db_comment='Specifies whether the trail has custom event selectors, or not.', null=True)),
                ('has_insight_selectors', models.BooleanField(blank=True, db_comment='Specifies whether a trail has insight types specified in an InsightSelector list, or not.', null=True)),
                ('include_global_service_events', models.BooleanField(blank=True, db_comment='Specifies whether to include AWS API calls from AWS global services, or not.', null=True)),
                ('is_organization_trail', models.BooleanField(blank=True, db_comment='Specifies whether the trail is an organization trail, or not.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='Specifies the KMS key ID that encrypts the logs delivered by CloudTrail.', null=True)),
                ('s3_bucket_name', models.TextField(blank=True, db_comment='Name of the Amazon S3 bucket into which CloudTrail delivers your trail files.', null=True)),
                ('s3_key_prefix', models.TextField(blank=True, db_comment='Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery.', null=True)),
                ('sns_topic_arn', models.TextField(blank=True, db_comment='Specifies the ARN of the Amazon SNS topic that CloudTrail uses to send notifications when log files are delivered.', null=True)),
                ('latest_cloudwatch_logs_delivery_error', models.TextField(blank=True, db_comment='Displays any CloudWatch Logs error that CloudTrail encountered when attempting to deliver logs to CloudWatch Logs.', null=True)),
                ('latest_cloudwatch_logs_delivery_time', models.DateTimeField(blank=True, db_comment='Displays the most recent date and time when CloudTrail delivered logs to CloudWatch Logs.', null=True)),
                ('latest_delivery_error', models.TextField(blank=True, db_comment='Displays any Amazon S3 error that CloudTrail encountered when attempting to deliver log files to the designated bucket.', null=True)),
                ('latest_delivery_time', models.DateTimeField(blank=True, db_comment="Specifies the date and time that CloudTrail last delivered log files to an account's Amazon S3 bucket.", null=True)),
                ('latest_digest_delivery_error', models.TextField(blank=True, db_comment='Displays any Amazon S3 error that CloudTrail encountered when attempting to deliver a digest file to the designated bucket.', null=True)),
                ('latest_digest_delivery_time', models.DateTimeField(blank=True, db_comment="Specifies the date and time that CloudTrail last delivered a digest file to an account's Amazon S3 bucket.", null=True)),
                ('latest_notification_error', models.TextField(blank=True, db_comment='Displays any Amazon SNS error that CloudTrail encountered when attempting to send a notification.', null=True)),
                ('latest_notification_time', models.DateTimeField(blank=True, db_comment="Specifies the date and time of the most recent Amazon SNS notification that CloudTrail has written a new log file to an account's Amazon S3 bucket.", null=True)),
                ('start_logging_time', models.DateTimeField(blank=True, db_comment='Specifies the most recent date and time when CloudTrail started recording API calls for an AWS account.', null=True)),
                ('stop_logging_time', models.DateTimeField(blank=True, db_comment='Specifies the most recent date and time when CloudTrail stopped recording API calls for an AWS account.', null=True)),
                ('advanced_event_selectors', models.JSONField(blank=True, db_comment='Describes the advanced event selectors that are configured for the trail.', null=True)),
                ('event_selectors', models.JSONField(blank=True, db_comment='Describes the event selectors that are configured for the trail.', null=True)),
                ('insight_selectors', models.JSONField(blank=True, db_comment='A JSON string that contains the insight types you want to log on a trail.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the trail.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudtrail_trail',
                'db_table_comment': 'AWS CloudTrail Trail',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudwatchAlarm',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the alarm.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the alarm.', null=True)),
                ('state_value', models.TextField(blank=True, db_comment='The state value for the alarm.', null=True)),
                ('actions_enabled', models.BooleanField(blank=True, db_comment='Indicates whether actions should be executed during any changes to the alarm state.', null=True)),
                ('alarm_configuration_updated_timestamp', models.DateTimeField(blank=True, db_comment='The time stamp of the last update to the alarm configuration.', null=True)),
                ('alarm_description', models.TextField(blank=True, db_comment='The description of the alarm.', null=True)),
                ('comparison_operator', models.TextField(blank=True, db_comment='The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand.', null=True)),
                ('datapoints_to_alarm', models.BigIntegerField(blank=True, db_comment='The number of data points that must be breaching to trigger the alarm.', null=True)),
                ('evaluate_low_sample_count_percentile', models.TextField(blank=True, db_comment='Used only for alarms based on percentiles.', null=True)),
                ('evaluation_periods', models.BigIntegerField(blank=True, db_comment='The number of periods over which data is compared to the specified threshold.', null=True)),
                ('extended_statistic', models.TextField(blank=True, db_comment='The percentile statistic for the metric associated with the alarm. Specify a value between p0.0 and p100.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric associated with the alarm, if this is an alarm based on a single metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The namespace of the metric associated with the alarm.', null=True)),
                ('period', models.BigIntegerField(blank=True, db_comment='The period, in seconds, over which the statistic is applied.', null=True)),
                ('state_reason', models.TextField(blank=True, db_comment='An explanation for the alarm state, in text format.', null=True)),
                ('state_reason_data', models.TextField(blank=True, db_comment='An explanation for the alarm state, in JSON format.', null=True)),
                ('state_updated_timestamp', models.DateTimeField(blank=True, db_comment='The time stamp of the last update to the alarm state.', null=True)),
                ('statistic', models.TextField(blank=True, db_comment='The statistic for the metric associated with the alarm, other than percentile.', null=True)),
                ('threshold', models.FloatField(blank=True, db_comment='The value to compare with the specified statistic.', null=True)),
                ('threshold_metric_id', models.TextField(blank=True, db_comment='In an alarm based on an anomaly detection model, this is the ID of the ANOMALY_DETECTION_BAND function used as the threshold for the alarm.', null=True)),
                ('treat_missing_data', models.TextField(blank=True, db_comment='Sets how this alarm is to handle missing data points. If this parameter is omitted, the default behavior of missing is used.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The unit of the metric associated with the alarm.', null=True)),
                ('alarm_actions', models.JSONField(blank=True, db_comment='The actions to execute when this alarm transitions to the ALARM state from any other state. Each action is specified as an Amazon Resource Name (ARN).', null=True)),
                ('dimensions', models.JSONField(blank=True, db_comment='The dimensions for the metric associated with the alarm.', null=True)),
                ('insufficient_data_actions', models.JSONField(blank=True, db_comment='The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Name (ARN).', null=True)),
                ('metrics', models.JSONField(blank=True, db_comment='An array of MetricDataQuery structures, used in an alarm based on a metric math expression.', null=True)),
                ('ok_actions', models.JSONField(blank=True, db_comment='The actions to execute when this alarm transitions to the OK state from any other state. Each action is specified as an Amazon Resource Name (ARN).', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The list of tag keys and values associated with alarm.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudwatch_alarm',
                'db_table_comment': 'AWS CloudWatch Alarm',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudwatchLogGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the log group.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the log group.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The creation time of the log group.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the CMK to use when encrypting log data.', null=True)),
                ('metric_filter_count', models.BigIntegerField(blank=True, db_comment='The number of metric filters.', null=True)),
                ('retention_in_days', models.BigIntegerField(blank=True, db_comment='The number of days to retain the log events in the specified log group. Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, and 3653.', null=True)),
                ('stored_bytes', models.BigIntegerField(blank=True, db_comment='The number of bytes stored.', null=True)),
                ('data_protection', models.JSONField(blank=True, db_comment='Log group data protection policy information.', null=True)),
                ('data_protection_policy', models.JSONField(blank=True, db_comment='The data protection policy document for a log group.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudwatch_log_group',
                'db_table_comment': 'AWS CloudWatch Log Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudwatchLogMetricFilter',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the metric filter', null=True)),
                ('log_group_name', models.TextField(blank=True, db_comment='The name of the log group', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The creation time of the metric filter', null=True)),
                ('filter_pattern', models.TextField(blank=True, db_comment='A symbolic description of how CloudWatch Logs should interpret the data in each log event', null=True)),
                ('metric_transformation_name', models.TextField(blank=True, db_comment='The name of the CloudWatch metric', null=True)),
                ('metric_transformation_namespace', models.TextField(blank=True, db_comment='A custom namespace to contain metric in CloudWatch. Namespaces are used to group together metrics that are similar', null=True)),
                ('metric_transformation_value', models.TextField(blank=True, db_comment='The value to publish to the CloudWatch metric when a filter pattern matches a log event', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudwatch_log_metric_filter',
                'db_table_comment': 'AWS CloudWatch Log Metric Filter',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudwatchLogResourcePolicy',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('policy_name', models.TextField(blank=True, db_comment='The name of the resource policy.', null=True)),
                ('last_updated_time', models.DateTimeField(blank=True, db_comment='Timestamp showing when this policy was last updated.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='The details of the policy.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the policy document in a canonical form for easier searching.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudwatch_log_resource_policy',
                'db_table_comment': 'AWS CloudWatch Log Resource Policy',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudwatchLogStream',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the log stream.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the log stream.', null=True)),
                ('log_group_name', models.TextField(blank=True, db_comment='The name of the log group, in which the log stream belongs.', null=True)),
                ('log_stream_name_prefix', models.TextField(blank=True, db_comment='The prefix to match the name of the log stream.', null=True)),
                ('descending', models.BooleanField(blank=True, db_comment='If the value is true, results are returned in descending order. If the value is to false, results are returned in ascending order. The default value is false.', null=True)),
                ('order_by', models.TextField(blank=True, db_comment='If the value is LogStreamName, the results are ordered by log stream name. If the value is LastEventTime, the results are ordered by the event time. The default value is LogStreamName. If you order the results by event time, you cannot specify the logStreamNamePrefix parameter. LastEventTimestamp represents the time of the most recent log event in the log stream in CloudWatch Logs.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The creation time of the log stream.', null=True)),
                ('first_event_timestamp', models.DateTimeField(blank=True, db_comment='The time of the first event.', null=True)),
                ('last_event_timestamp', models.DateTimeField(blank=True, db_comment='The time of the most recent log event in the log stream in CloudWatch Logs.', null=True)),
                ('last_ingestion_time', models.DateTimeField(blank=True, db_comment='Specifies the last log ingestion time.', null=True)),
                ('upload_sequence_token', models.TextField(blank=True, db_comment='Specifies the log upload sequence token.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudwatch_log_stream',
                'db_table_comment': 'AWS CloudWatch Log Stream',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudwatchLogSubscriptionFilter',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the subscription filter.', null=True)),
                ('log_group_name', models.TextField(blank=True, db_comment='The name of the log group.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The creation time of the subscription filter.', null=True)),
                ('destination_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the destination.', null=True)),
                ('distribution', models.TextField(blank=True, db_comment='The method used to distribute log data to the destination.', null=True)),
                ('filter_pattern', models.TextField(blank=True, db_comment='A symbolic description of how CloudWatch Logs should interpret the data in each log event.', null=True)),
                ('role_arn', models.TextField(blank=True, db_comment='The role associated to the filter.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudwatch_log_subscription_filter',
                'db_table_comment': 'AWS CloudWatch Log Subscription Filter',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCloudwatchMetric',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The namespace for the metric.', null=True)),
                ('dimensions_filter', models.JSONField(blank=True, db_comment='The dimensions to filter against.', null=True)),
                ('dimensions', models.JSONField(blank=True, db_comment='The dimensions for the metric.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cloudwatch_metric',
                'db_table_comment': 'AWS CloudWatch Metric',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCodeartifactDomain',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the domain.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the domain.', null=True)),
                ('asset_size_bytes', models.BigIntegerField(blank=True, db_comment='The total size of all assets in the domain.', null=True)),
                ('created_time', models.DateTimeField(blank=True, db_comment='A timestamp that contains the date and time the domain was created.', null=True)),
                ('encryption_key', models.TextField(blank=True, db_comment='The key used to encrypt the domain.', null=True)),
                ('owner', models.TextField(blank=True, db_comment='The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.', null=True)),
                ('repository_count', models.BigIntegerField(blank=True, db_comment='The number of repositories in the domain.', null=True)),
                ('s3_bucket_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the Amazon S3 bucket that is used to store package assets in the domain.', null=True)),
                ('status', models.TextField(blank=True, db_comment='A string that contains the status of the domain.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='An CodeArtifact resource policy that contains a resource ARN, document details, and a revision.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the contents of the resource-based policy in a canonical form for easier searching.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_codeartifact_domain',
                'db_table_comment': 'AWS Code Artifact Domain',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCodeartifactRepository',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the repository.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the repository.', null=True)),
                ('domain_name', models.TextField(blank=True, db_comment='The name of the domain that contains the repository.', null=True)),
                ('administrator_account', models.TextField(blank=True, db_comment='The Amazon Web Services account ID that manages the repository.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the repository.', null=True)),
                ('domain_owner', models.TextField(blank=True, db_comment='The 12-digit account number of the Amazon Web Services account that owns the repository. It does not include dashes or spaces.', null=True)),
                ('external_connections', models.JSONField(blank=True, db_comment='An array of external connections associated with the repository.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='An CodeArtifact resource policy that contains a resource ARN, document details, and a revision.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the contents of the resource-based policy in a canonical form for easier searching.', null=True)),
                ('repository_endpoint', models.JSONField(blank=True, db_comment='A string that specifies the URL of the returned endpoint.', null=True)),
                ('upstreams', models.JSONField(blank=True, db_comment='A list of upstream repositories to associate with the repository.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_codeartifact_repository',
                'db_table_comment': 'AWS CodeArtifact Repository',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCodebuildBuild',
            fields=[
                ('arn', models.TextField(blank=True, db_comment='The ARN of the build.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The unique identifier of the  build.', primary_key=True, serialize=False)),
                ('build_batch_arn', models.TextField(blank=True, db_comment='The ARN of the batch build that this build is a member of, if applicable.', null=True)),
                ('build_complete', models.BooleanField(blank=True, db_comment='Indicates if the build is complete.', null=True)),
                ('build_number', models.BigIntegerField(blank=True, db_comment='The number of the build.', null=True)),
                ('build_status', models.JSONField(blank=True, db_comment='The status of the build.', null=True)),
                ('current_phase', models.TextField(blank=True, db_comment='The current build phase.', null=True)),
                ('encryption_key', models.TextField(blank=True, db_comment='The Key Management Service customer master key (CMK) to be used for encrypting the build output artifacts.', null=True)),
                ('end_time', models.DateTimeField(blank=True, db_comment='The date and time that the build process ended, expressed in Unix time format.', null=True)),
                ('initiator', models.TextField(blank=True, db_comment='The entity that started the build.', null=True)),
                ('project_name', models.TextField(blank=True, db_comment='The name of the build project.', null=True)),
                ('queued_timeout_in_minutes', models.BigIntegerField(blank=True, db_comment='Specifies the amount of time, in minutes, that a build is allowed to be queued before it times out.', null=True)),
                ('source_version', models.TextField(blank=True, db_comment='The identifier of the version of the source code to be built.', null=True)),
                ('start_time', models.DateTimeField(blank=True, db_comment='The date and time that the build started.', null=True)),
                ('timeout_in_minutes', models.BigIntegerField(blank=True, db_comment='How long, in minutes, for CodeBuild to wait before timing out this build if it does not get marked as completed.', null=True)),
                ('resolved_source_version', models.TextField(blank=True, db_comment="The identifier of the resolved version of this build's source code.", null=True)),
                ('artifacts', models.JSONField(blank=True, db_comment='A BuildArtifacts object the defines the build artifacts for this build.', null=True)),
                ('cache', models.JSONField(blank=True, db_comment='Information about the cache for the build.', null=True)),
                ('debug_session', models.JSONField(blank=True, db_comment='Contains information about the debug session for this build.', null=True)),
                ('environment', models.JSONField(blank=True, db_comment='Information about the build environment for this build project.', null=True)),
                ('exported_environment_variables', models.JSONField(blank=True, db_comment='A list of exported environment variables for this build.', null=True)),
                ('file_system_locations', models.JSONField(blank=True, db_comment='An array of ProjectFileSystemLocation objects for a CodeBuild build project.', null=True)),
                ('logs', models.JSONField(blank=True, db_comment="Information about the build's logs in CloudWatch Logs.", null=True)),
                ('network_interfaces', models.JSONField(blank=True, db_comment='Describes a network interface.', null=True)),
                ('phases', models.JSONField(blank=True, db_comment='Information about all previous build phases that are complete and information about any current build phase that is not yet complete.', null=True)),
                ('report_arns', models.JSONField(blank=True, db_comment="An array of the ARNs associated with this build's reports.", null=True)),
                ('secondary_artifacts', models.JSONField(blank=True, db_comment='An array of BuildArtifacts objects the define the build artifacts for this build.', null=True)),
                ('secondary_source_versions', models.JSONField(blank=True, db_comment='An array of ProjectSourceVersion objects.', null=True)),
                ('secondary_sources', models.JSONField(blank=True, db_comment='An array of ProjectSource objects that define the sources for the build.', null=True)),
                ('source', models.JSONField(blank=True, db_comment='Information about the build input source code for the build project.', null=True)),
                ('vpc_config', models.JSONField(blank=True, db_comment='Information about the VPC configuration that CodeBuild accesses.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_codebuild_build',
                'db_table_comment': 'AWS CodeBuild Build',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCodebuildProject',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the build project.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the build project.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description that makes the build project easy to identify.', null=True)),
                ('concurrent_build_limit', models.BigIntegerField(blank=True, db_comment='The maximum number of concurrent builds that are allowed for this project.', null=True)),
                ('created', models.DateTimeField(blank=True, db_comment='When the build project was created, expressed in Unix time format.', null=True)),
                ('last_modified', models.DateTimeField(blank=True, db_comment="When the build project's settings were last modified, expressed in Unix time format.", null=True)),
                ('encryption_key', models.TextField(blank=True, db_comment='The AWS Key Management Service (AWS KMS) customer master key (CMK) to be.', null=True)),
                ('queued_timeout_in_minutes', models.BigIntegerField(blank=True, db_comment='The number of minutes a build is allowed to be queued before it times out.', null=True)),
                ('service_role', models.TextField(blank=True, db_comment='The ARN of the AWS Identity and Access Management (IAM) role that enables AWS CodeBuild to interact with dependent AWS services on behalf of the AWS account.', null=True)),
                ('source_version', models.TextField(blank=True, db_comment='A version of the build input to be built for this project.', null=True)),
                ('timeout_in_minutes', models.BigIntegerField(blank=True, db_comment='How long, in minutes, from 5 to 480 (8 hours), for AWS CodeBuild to wait before timing out any related build that did not get marked as completed.', null=True)),
                ('artifacts', models.JSONField(blank=True, db_comment='Information about the build output artifacts for the build project.', null=True)),
                ('badge', models.JSONField(blank=True, db_comment='Information about the build badge for the build project.', null=True)),
                ('build_batch_config', models.JSONField(blank=True, db_comment='A ProjectBuildBatchConfig object that defines the batch build options for the project.', null=True)),
                ('cache', models.JSONField(blank=True, db_comment='Information about the cache for the build project.', null=True)),
                ('environment', models.JSONField(blank=True, db_comment='Information about the build environment for this build project.', null=True)),
                ('file_system_locations', models.JSONField(blank=True, db_comment='An array of ProjectFileSystemLocation objects for a CodeBuild build project.', null=True)),
                ('logs_config', models.JSONField(blank=True, db_comment='Information about logs for the build project. A project can create logs in Amazon CloudWatch Logs, an S3 bucket or both.', null=True)),
                ('project_visibility', models.TextField(blank=True, db_comment='Visibility of the build project.', null=True)),
                ('secondary_artifacts', models.JSONField(blank=True, db_comment='An array of ProjectArtifacts objects.', null=True)),
                ('secondary_source_versions', models.JSONField(blank=True, db_comment='An array of ProjectSource objects.', null=True)),
                ('secondary_sources', models.JSONField(blank=True, db_comment='An array of ProjectSource objects.', null=True)),
                ('source', models.JSONField(blank=True, db_comment='Information about the build input source code for this build project.', null=True)),
                ('vpc_config', models.JSONField(blank=True, db_comment='Information about the VPC configuration that AWS CodeBuild accesses.', null=True)),
                ('webhook', models.JSONField(blank=True, db_comment=' Information about a webhook that connects repository events to a build project in AWS CodeBuild.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tag key and value pairs associated with this build project.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_codebuild_project',
                'db_table_comment': 'AWS CodeBuild Project',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCodebuildSourceCredential',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the token.', null=True)),
                ('auth_type', models.TextField(blank=True, db_comment='The type of authentication used by the credentials. Possible values are: OAUTH, BASIC_AUTH, or PERSONAL_ACCESS_TOKEN.', null=True)),
                ('server_type', models.TextField(blank=True, db_comment='The type of source provider. Possible values are: GITHUB, GITHUB_ENTERPRISE, or BITBUCKET.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_codebuild_source_credential',
                'db_table_comment': 'AWS CodeBuild Source Credential',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCodecommitRepository',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('repository_name', models.TextField(blank=True, db_comment="The repository's name.", null=True)),
                ('repository_id', models.TextField(blank=True, db_comment='The ID of the repository.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the repository.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A comment or description about the repository.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The date and time the repository was created.', null=True)),
                ('clone_url_http', models.TextField(blank=True, db_comment='The URL to use for cloning the repository over HTTPS.', null=True)),
                ('clone_url_ssh', models.TextField(blank=True, db_comment='The URL to use for cloning the repository over SSH.', null=True)),
                ('default_branch', models.TextField(blank=True, db_comment="The repository's default branch name.", null=True)),
                ('last_modified_date', models.DateTimeField(blank=True, db_comment='The date and time the repository was last modified.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_codecommit_repository',
                'db_table_comment': 'AWS CodeCommit Repository',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCodedeployApp',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('application_id', models.TextField(blank=True, db_comment='The application ID.', null=True)),
                ('application_name', models.TextField(blank=True, db_comment='The application name.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the application.', null=True)),
                ('compute_platform', models.TextField(blank=True, db_comment='The destination platform type for deployment of the application (Lambda or Server).', null=True)),
                ('create_time', models.DateTimeField(blank=True, db_comment='The time at which the application was created.', null=True)),
                ('github_account_name', models.TextField(blank=True, db_comment='The name for a connection to a GitHub account.', null=True)),
                ('linked_to_github', models.BooleanField(blank=True, db_comment='True if the user has authenticated with GitHub for the specified application. Otherwise, false.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tag key and value pairs associated with this application.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_codedeploy_app',
                'db_table_comment': 'AWS CodeDeploy Application',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCodedeployDeploymentConfig',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the application.', null=True)),
                ('create_time', models.DateTimeField(blank=True, db_comment='The time at which the deployment configuration was created.', null=True)),
                ('deployment_config_id', models.TextField(blank=True, db_comment='The deployment configuration ID.', null=True)),
                ('deployment_config_name', models.TextField(blank=True, db_comment='The deployment configuration name.', null=True)),
                ('compute_platform', models.JSONField(blank=True, db_comment='The destination platform type for the deployment (Lambda, Server, or ECS).', null=True)),
                ('minimum_healthy_hosts', models.JSONField(blank=True, db_comment='Information about the number or percentage of minimum healthy instances.', null=True)),
                ('traffic_routing_config', models.JSONField(blank=True, db_comment='The configuration that specifies how the deployment traffic is routed. Used for deployments with a Lambda or Amazon ECS compute platform only.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_codedeploy_deployment_config',
                'db_table_comment': 'AWS CodeDeploy Deployment Config',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCodedeployDeploymentGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the application.', null=True)),
                ('application_name', models.TextField(blank=True, db_comment='The application name.', null=True)),
                ('deployment_config_name', models.TextField(blank=True, db_comment='The deployment configuration name.', null=True)),
                ('deployment_group_id', models.TextField(blank=True, db_comment='The deployment group ID.', null=True)),
                ('deployment_group_name', models.TextField(blank=True, db_comment='The deployment group name.', null=True)),
                ('service_role_arn', models.TextField(blank=True, db_comment='A service role Amazon Resource Name (ARN) that grants CodeDeploy permission to make calls to Amazon Web Services services on your behalf.', null=True)),
                ('alarm_configuration', models.JSONField(blank=True, db_comment='A list of alarms associated with the deployment group.', null=True)),
                ('auto_rollback_configuration', models.JSONField(blank=True, db_comment='Information about the automatic rollback configuration associated with the deployment group.', null=True)),
                ('auto_scaling_groups', models.JSONField(blank=True, db_comment='A list of associated Auto Scaling groups.', null=True)),
                ('blue_green_deployment_configuration', models.JSONField(blank=True, db_comment='Information about blue/green deployment options for a deployment group.', null=True)),
                ('compute_platform', models.JSONField(blank=True, db_comment='The destination platform type for the deployment (Lambda, Server, or ECS).', null=True)),
                ('deployment_style', models.JSONField(blank=True, db_comment='Information about the type of deployment, either in-place or blue/green, you want to run and whether to route deployment traffic behind a load balancer.', null=True)),
                ('ec2_tag_filters', models.JSONField(blank=True, db_comment='The Amazon EC2 tags on which to filter. The deployment group includes EC2 instances with any of the specified tags.', null=True)),
                ('ec2_tag_set', models.JSONField(blank=True, db_comment='Information about groups of tags applied to an Amazon EC2 instance.', null=True)),
                ('ecs_services', models.JSONField(blank=True, db_comment='The target Amazon ECS services in the deployment group.', null=True)),
                ('last_attempted_deployment', models.JSONField(blank=True, db_comment='Information about the most recent attempted deployment to the deployment group.', null=True)),
                ('last_successful_deployment', models.JSONField(blank=True, db_comment='Information about the most recent successful deployment to the deployment group.', null=True)),
                ('load_balancer_info', models.JSONField(blank=True, db_comment='Information about the load balancer to use in a deployment.', null=True)),
                ('on_premises_instance_tag_filters', models.JSONField(blank=True, db_comment='The on-premises instance tags on which to filter.', null=True)),
                ('on_premises_tag_set', models.JSONField(blank=True, db_comment='Information about groups of tags applied to an on-premises instance.', null=True)),
                ('outdated_instances_strategy', models.JSONField(blank=True, db_comment='Indicates what happens when new Amazon EC2 instances are launched mid-deployment and do not receive the deployed application revision.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with deployment group.', null=True)),
                ('target_revision', models.JSONField(blank=True, db_comment="Information about the deployment group's target revision, including type and location.", null=True)),
                ('trigger_configurations', models.JSONField(blank=True, db_comment='Information about triggers associated with the deployment group.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_codedeploy_deployment_group',
                'db_table_comment': 'AWS CodeDeploy Deployment Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCodepipelinePipeline',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the pipeline.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the pipeline.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The date and time the pipeline was created.', null=True)),
                ('role_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for AWS CodePipeline to use to either perform actions with no actionRoleArn, or to use to assume roles for actions with an actionRoleArn.', null=True)),
                ('updated_at', models.DateTimeField(blank=True, db_comment='The date and time of the last update to the pipeline.', null=True)),
                ('version', models.BigIntegerField(blank=True, db_comment='The version number of the pipeline.', null=True)),
                ('encryption_key', models.JSONField(blank=True, db_comment='The encryption key used to encrypt the data in the artifact store, such as an AWS Key Management Service (AWS KMS) key. If this is undefined, the default key for Amazon S3 is used.', null=True)),
                ('artifact_stores', models.JSONField(blank=True, db_comment='A mapping of artifactStore objects and their corresponding AWS Regions. There must be an artifact store for the pipeline Region and for each cross-region action in the pipeline.', null=True)),
                ('stages', models.JSONField(blank=True, db_comment='The stage in which to perform the action.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tag key and value pairs associated with this pipeline.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_codepipeline_pipeline',
                'db_table_comment': 'AWS Codepipeline Pipeline',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCodestarNotificationRule',
            fields=[
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the notification rule.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The unique ID of the notification rule.', primary_key=True, serialize=False)),
                ('name', models.TextField(blank=True, db_comment='The name of the notification rule.', null=True)),
                ('resource', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the resource associated with the notification rule.', null=True)),
                ('detail_type', models.TextField(blank=True, db_comment='The level of detail included in the notifications for this resource. BASIC will include only the contents of the event as it would appear in Amazon CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the notification rule. Valid statuses are on (sending notifications) or off (not sending notifications).', null=True)),
                ('created_by', models.TextField(blank=True, db_comment='The name or email alias of the person who created the notification rule.', null=True)),
                ('event_type_id', models.TextField(blank=True, db_comment='Specifies that only notification rules with the given event type enabled are returned.', null=True)),
                ('target_address', models.TextField(blank=True, db_comment='Specifies that only notification rules with a target with the given address are returned.', null=True)),
                ('created_timestamp', models.DateTimeField(blank=True, db_comment='The date and time the notification rule was created.', null=True)),
                ('last_modified_timestamp', models.DateTimeField(blank=True, db_comment='The date and time the notification rule was most recently updated.', null=True)),
                ('event_types', models.JSONField(blank=True, db_comment='A list of the event types associated with the notification rule.', null=True)),
                ('targets', models.JSONField(blank=True, db_comment='A list of targets associated with the notification rule.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_codestar_notification_rule',
                'db_table_comment': 'AWS CodeStar Notification Rule',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCognitoIdentityPool',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('identity_pool_id', models.TextField(blank=True, db_comment='An identity pool ID in the format REGION:GUID.', null=True)),
                ('allow_unauthenticated_identities', models.BooleanField(blank=True, db_comment='TRUE if the identity pool supports unauthenticated logins.', null=True)),
                ('identity_pool_name', models.TextField(blank=True, db_comment='A string that you provide.', null=True)),
                ('allow_classic_flow', models.BooleanField(blank=True, db_comment='Enables or disables the Basic (Classic) authentication flow.', null=True)),
                ('cognito_identity_providers', models.JSONField(blank=True, db_comment='A list representing an Amazon Cognito user pool and its client ID.', null=True)),
                ('developer_provider_name', models.TextField(blank=True, db_comment="The 'domain' by which Cognito will refer to your users.", null=True)),
                ('open_id_connect_provider_arns', models.JSONField(blank=True, db_comment='The ARNs of the OpenID Connect providers.', null=True)),
                ('saml_provider_arns', models.JSONField(blank=True, db_comment='An array of Amazon Resource Names (ARNs) of the SAML provider for your identity pool.', null=True)),
                ('supported_login_providers', models.JSONField(blank=True, db_comment='Optional key:value pairs mapping provider names to provider app IDs.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cognito_identity_pool',
                'db_table_comment': 'AWS Cognito Identity Pool',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCognitoIdentityProvider',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('provider_name', models.TextField(blank=True, db_comment='The IdP name.', null=True)),
                ('user_pool_id', models.TextField(blank=True, db_comment='The user pool ID.', null=True)),
                ('attribute_mapping', models.JSONField(blank=True, db_comment='A mapping of IdP attributes to standard and custom user pool attributes.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The date the provider was added to the user pool.', null=True)),
                ('idp_identifiers', models.JSONField(blank=True, db_comment='A list of IdP identifiers.', null=True)),
                ('last_modified_date', models.DateTimeField(blank=True, db_comment='The date the provider was last modified.', null=True)),
                ('provider_details', models.JSONField(blank=True, db_comment='The IdP details.', null=True)),
                ('provider_type', models.TextField(blank=True, db_comment='The IdP type.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cognito_identity_provider',
                'db_table_comment': 'AWS Cognito Identity Provider',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCognitoUserPool',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The ID of the user pool.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the user pool.', null=True)),
                ('account_recovery_setting', models.JSONField(blank=True, db_comment='The available verified method a user can use to recover their password when they call ForgotPassword.', null=True)),
                ('admin_create_user_config', models.JSONField(blank=True, db_comment='The configuration for AdminCreateUser requests.', null=True)),
                ('alias_attributes', models.TextField(blank=True, db_comment='The attributes that are aliased in a user pool.', null=True)),
                ('auto_verified_attributes', models.TextField(blank=True, db_comment='The attributes that are auto-verified in a user pool.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The date the user pool was created.', null=True)),
                ('custom_domain', models.TextField(blank=True, db_comment='A custom domain name that you provide to Amazon Cognito.', null=True)),
                ('deletion_protection', models.TextField(blank=True, db_comment='When active, DeletionProtection prevents accidental deletion of your user pool.', null=True)),
                ('device_configuration', models.JSONField(blank=True, db_comment='The device-remembering configuration for a user pool.', null=True)),
                ('domain', models.TextField(blank=True, db_comment='The domain prefix, if the user pool has a domain associated with it.', null=True)),
                ('email_configuration', models.JSONField(blank=True, db_comment='The email configuration of your user pool.', null=True)),
                ('estimated_number_of_users', models.BigIntegerField(blank=True, db_comment='A number estimating the size of the user pool.', null=True)),
                ('lambda_config', models.JSONField(blank=True, db_comment='The Lambda triggers associated with the user pool.', null=True)),
                ('last_modified_date', models.DateTimeField(blank=True, db_comment='The date the user pool was last modified.', null=True)),
                ('mfa_configuration', models.TextField(blank=True, db_comment='Multi-Factor Authentication (MFA) configuration for the User Pool.', null=True)),
                ('name', models.TextField(blank=True, db_comment='The name of the Cognito User Pool.', null=True)),
                ('policies', models.JSONField(blank=True, db_comment='The policies associated with the user pool.', null=True)),
                ('schema_attributes', models.JSONField(blank=True, db_comment='A container with the schema attributes of a user pool.', null=True)),
                ('sms_authentication_message', models.TextField(blank=True, db_comment='The contents of the SMS authentication message.', null=True)),
                ('sms_configuration', models.JSONField(blank=True, db_comment='The SMS configuration with the settings that your Amazon Cognito user pool must use to send an SMS message from your Amazon Web Services account through Amazon Simple Notification Service.', null=True)),
                ('sms_configuration_failure', models.TextField(blank=True, db_comment="The reason why the SMS configuration can't send the messages to your users.", null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of a user pool.', null=True)),
                ('user_attribute_update_settings', models.JSONField(blank=True, db_comment='The settings for updates to user attributes.', null=True)),
                ('user_pool_add_ons', models.JSONField(blank=True, db_comment='The user pool add-ons.', null=True)),
                ('username_attributes', models.JSONField(blank=True, db_comment='Specifies whether a user can use an email address or phone number as a username when they sign up.', null=True)),
                ('username_configuration', models.JSONField(blank=True, db_comment='Case sensitivity of the username input for the selected sign-in option.', null=True)),
                ('verification_message_template', models.JSONField(blank=True, db_comment='The template for verification messages.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cognito_user_pool',
                'db_table_comment': 'AWS Cognito User Pool',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsConfigAggregateAuthorization',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the aggregation object.', null=True)),
                ('authorized_account_id', models.TextField(blank=True, db_comment='The 12-digit account ID of the account authorized to aggregate data.', null=True)),
                ('authorized_aws_region', models.TextField(blank=True, db_comment='The region authorized to collect aggregated data.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The time stamp when the aggregation authorization was created.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the Cluster.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_config_aggregate_authorization',
                'db_table_comment': 'AWS Config Aggregate Authorization',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsConfigConfigurationRecorder',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the recorder. By default, AWS Config automatically assigns the name default when creating the configuration recorder.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the configuration recorder.', null=True)),
                ('recording_group', models.JSONField(blank=True, db_comment='Specifies the types of AWS resources for which AWS Config records configuration changes.', null=True)),
                ('role_arn', models.TextField(blank=True, db_comment='Amazon Resource Name (ARN) of the IAM role used to describe the AWS resources associated with the account.', null=True)),
                ('status_recording', models.BooleanField(blank=True, db_comment='Specifies whether or not the recorder is currently recording.', null=True)),
                ('status', models.JSONField(blank=True, db_comment='The current status of the configuration recorder.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_config_configuration_recorder',
                'db_table_comment': 'AWS Config Configuration Recorder',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsConfigConformancePack',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='Name of the conformance pack.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='Amazon Resource Name (ARN) of the conformance pack.', null=True)),
                ('conformance_pack_id', models.TextField(blank=True, db_comment='ID of the conformance pack.', null=True)),
                ('created_by', models.TextField(blank=True, db_comment='AWS service that created the conformance pack.', null=True)),
                ('delivery_s3_bucket', models.TextField(blank=True, db_comment='Amazon S3 bucket where AWS Config stores conformance pack templates.', null=True)),
                ('delivery_s3_key_prefix', models.TextField(blank=True, db_comment='The prefix for the Amazon S3 delivery bucket.', null=True)),
                ('last_update_requested_time', models.DateTimeField(blank=True, db_comment='Last update to the conformance pack.', null=True)),
                ('input_parameters', models.JSONField(blank=True, db_comment='A list of ConformancePackInputParameter objects.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_config_conformance_pack',
                'db_table_comment': 'AWS Config Conformance Pack',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsConfigRetentionConfiguration',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the retention configuration object.', null=True)),
                ('retention_period_in_days', models.BigIntegerField(blank=True, db_comment='Number of days Config stores your historical information.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_config_retention_configuration',
                'db_table_comment': 'AWS Config Retention Configuration',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsConfigRule',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name that you assign to the AWS Config rule.', null=True)),
                ('rule_id', models.TextField(blank=True, db_comment='The ID of the AWS Config rule.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the AWS Config rule.', null=True)),
                ('rule_state', models.TextField(blank=True, db_comment='It indicate the evaluation status for the AWS Config rule.', null=True)),
                ('created_by', models.TextField(blank=True, db_comment='Service principal name of the service that created the rule.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description that you provide for the AWS Config rule.', null=True)),
                ('maximum_execution_frequency', models.TextField(blank=True, db_comment='The maximum frequency with which AWS Config runs evaluations for a rule.', null=True)),
                ('compliance_by_config_rule', models.JSONField(blank=True, db_comment='The compliance information of the config rule.', null=True)),
                ('evaluation_modes', models.JSONField(blank=True, db_comment='The modes the Config rule can be evaluated in. The valid values are distinct objects. By default, the value is Detective evaluation mode only.', null=True)),
                ('input_parameters', models.JSONField(blank=True, db_comment='A string, in JSON format, that is passed to the AWS Config rule Lambda function.', null=True)),
                ('scope', models.JSONField(blank=True, db_comment='Defines which resources can trigger an evaluation for the rule. The scope can include one or more resource types, a combination of one resource type and one resource ID, or a combination of a tag key and value. Specify a scope to constrain the resources that can trigger an evaluation for the rule. If you do not specify a scope, evaluations are triggered when any resource in the recording group changes.', null=True)),
                ('source', models.JSONField(blank=True, db_comment='Provides the rule owner (AWS or customer), the rule identifier, and the notifications that cause the function to evaluate your AWS resources.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the rule.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_config_rule',
                'db_table_comment': 'AWS Config Rule',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCostByAccountDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('linked_account_id', models.TextField(blank=True, db_comment='The AWS Account ID.', null=True)),
                ('period_start', models.DateTimeField(blank=True, db_comment='Start timestamp for this cost metric.', null=True)),
                ('period_end', models.DateTimeField(blank=True, db_comment='End timestamp for this cost metric.', null=True)),
                ('estimated', models.BooleanField(blank=True, db_comment='Whether the result is estimated.', null=True)),
                ('blended_cost_amount', models.FloatField(blank=True, db_comment='This cost metric reflects the average cost of usage across the consolidated billing family. If you use the consolidated billing feature in AWS Organizations, you can view costs using blended rates.', null=True)),
                ('blended_cost_unit', models.TextField(blank=True, db_comment='Unit type for blended costs.', null=True)),
                ('unblended_cost_amount', models.FloatField(blank=True, db_comment='Unblended costs represent your usage costs on the day they are charged to you. In finance terms, they represent your costs on a cash basis of accounting.', null=True)),
                ('unblended_cost_unit', models.TextField(blank=True, db_comment='Unit type for unblended costs.', null=True)),
                ('net_unblended_cost_amount', models.FloatField(blank=True, db_comment='This cost metric reflects the unblended cost after discounts.', null=True)),
                ('net_unblended_cost_unit', models.TextField(blank=True, db_comment='Unit type for net unblended costs.', null=True)),
                ('amortized_cost_amount', models.FloatField(blank=True, db_comment="This cost metric reflects the effective cost of the upfront and monthly reservation fees spread across the billing period. By default, Cost Explorer shows the fees for Reserved Instances as a spike on the day that you're charged, but if you choose to show costs as amortized costs, the costs are amortized over the billing period. This means that the costs are broken out into the effective daily rate. AWS estimates your amortized costs by combining your unblended costs with the amortized portion of your upfront and recurring reservation fees.", null=True)),
                ('amortized_cost_unit', models.TextField(blank=True, db_comment='Unit type for amortized costs.', null=True)),
                ('net_amortized_cost_amount', models.FloatField(blank=True, db_comment='This cost metric amortizes the upfront and monthly reservation fees while including discounts such as RI volume discounts.', null=True)),
                ('net_amortized_cost_unit', models.TextField(blank=True, db_comment='Unit type for net amortized costs.', null=True)),
                ('usage_quantity_amount', models.FloatField(blank=True, db_comment="The amount of usage that you incurred. NOTE: If you return the UsageQuantity metric, the service aggregates all usage numbers without taking into account the units. For example, if you aggregate usageQuantity across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hours vs. GB).", null=True)),
                ('usage_quantity_unit', models.TextField(blank=True, db_comment='Unit type for usage quantity.', null=True)),
                ('normalized_usage_amount', models.FloatField(blank=True, db_comment='The amount of usage that you incurred, in normalized units, for size-flexible RIs. The NormalizedUsageAmount is equal to UsageAmount multiplied by NormalizationFactor.', null=True)),
                ('normalized_usage_unit', models.TextField(blank=True, db_comment='Unit type for normalized usage.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cost_by_account_daily',
                'db_table_comment': 'AWS Cost Explorer - Cost by Linked Account (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCostByAccountMonthly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('linked_account_id', models.TextField(blank=True, db_comment='The AWS Account ID.', null=True)),
                ('period_start', models.DateTimeField(blank=True, db_comment='Start timestamp for this cost metric.', null=True)),
                ('period_end', models.DateTimeField(blank=True, db_comment='End timestamp for this cost metric.', null=True)),
                ('estimated', models.BooleanField(blank=True, db_comment='Whether the result is estimated.', null=True)),
                ('blended_cost_amount', models.FloatField(blank=True, db_comment='This cost metric reflects the average cost of usage across the consolidated billing family. If you use the consolidated billing feature in AWS Organizations, you can view costs using blended rates.', null=True)),
                ('blended_cost_unit', models.TextField(blank=True, db_comment='Unit type for blended costs.', null=True)),
                ('unblended_cost_amount', models.FloatField(blank=True, db_comment='Unblended costs represent your usage costs on the day they are charged to you. In finance terms, they represent your costs on a cash basis of accounting.', null=True)),
                ('unblended_cost_unit', models.TextField(blank=True, db_comment='Unit type for unblended costs.', null=True)),
                ('net_unblended_cost_amount', models.FloatField(blank=True, db_comment='This cost metric reflects the unblended cost after discounts.', null=True)),
                ('net_unblended_cost_unit', models.TextField(blank=True, db_comment='Unit type for net unblended costs.', null=True)),
                ('amortized_cost_amount', models.FloatField(blank=True, db_comment="This cost metric reflects the effective cost of the upfront and monthly reservation fees spread across the billing period. By default, Cost Explorer shows the fees for Reserved Instances as a spike on the day that you're charged, but if you choose to show costs as amortized costs, the costs are amortized over the billing period. This means that the costs are broken out into the effective daily rate. AWS estimates your amortized costs by combining your unblended costs with the amortized portion of your upfront and recurring reservation fees.", null=True)),
                ('amortized_cost_unit', models.TextField(blank=True, db_comment='Unit type for amortized costs.', null=True)),
                ('net_amortized_cost_amount', models.FloatField(blank=True, db_comment='This cost metric amortizes the upfront and monthly reservation fees while including discounts such as RI volume discounts.', null=True)),
                ('net_amortized_cost_unit', models.TextField(blank=True, db_comment='Unit type for net amortized costs.', null=True)),
                ('usage_quantity_amount', models.FloatField(blank=True, db_comment="The amount of usage that you incurred. NOTE: If you return the UsageQuantity metric, the service aggregates all usage numbers without taking into account the units. For example, if you aggregate usageQuantity across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hours vs. GB).", null=True)),
                ('usage_quantity_unit', models.TextField(blank=True, db_comment='Unit type for usage quantity.', null=True)),
                ('normalized_usage_amount', models.FloatField(blank=True, db_comment='The amount of usage that you incurred, in normalized units, for size-flexible RIs. The NormalizedUsageAmount is equal to UsageAmount multiplied by NormalizationFactor.', null=True)),
                ('normalized_usage_unit', models.TextField(blank=True, db_comment='Unit type for normalized usage.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cost_by_account_monthly',
                'db_table_comment': 'AWS Cost Explorer - Cost by Linked Account (Monthly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCostByRecordTypeDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('linked_account_id', models.TextField(blank=True, db_comment='The linked AWS Account ID.', null=True)),
                ('record_type', models.TextField(blank=True, db_comment='The different types of charges such as RI fees, usage, costs, tax refunds, and credits.', null=True)),
                ('period_start', models.DateTimeField(blank=True, db_comment='Start timestamp for this cost metric.', null=True)),
                ('period_end', models.DateTimeField(blank=True, db_comment='End timestamp for this cost metric.', null=True)),
                ('estimated', models.BooleanField(blank=True, db_comment='Whether the result is estimated.', null=True)),
                ('blended_cost_amount', models.FloatField(blank=True, db_comment='This cost metric reflects the average cost of usage across the consolidated billing family. If you use the consolidated billing feature in AWS Organizations, you can view costs using blended rates.', null=True)),
                ('blended_cost_unit', models.TextField(blank=True, db_comment='Unit type for blended costs.', null=True)),
                ('unblended_cost_amount', models.FloatField(blank=True, db_comment='Unblended costs represent your usage costs on the day they are charged to you. In finance terms, they represent your costs on a cash basis of accounting.', null=True)),
                ('unblended_cost_unit', models.TextField(blank=True, db_comment='Unit type for unblended costs.', null=True)),
                ('net_unblended_cost_amount', models.FloatField(blank=True, db_comment='This cost metric reflects the unblended cost after discounts.', null=True)),
                ('net_unblended_cost_unit', models.TextField(blank=True, db_comment='Unit type for net unblended costs.', null=True)),
                ('amortized_cost_amount', models.FloatField(blank=True, db_comment="This cost metric reflects the effective cost of the upfront and monthly reservation fees spread across the billing period. By default, Cost Explorer shows the fees for Reserved Instances as a spike on the day that you're charged, but if you choose to show costs as amortized costs, the costs are amortized over the billing period. This means that the costs are broken out into the effective daily rate. AWS estimates your amortized costs by combining your unblended costs with the amortized portion of your upfront and recurring reservation fees.", null=True)),
                ('amortized_cost_unit', models.TextField(blank=True, db_comment='Unit type for amortized costs.', null=True)),
                ('net_amortized_cost_amount', models.FloatField(blank=True, db_comment='This cost metric amortizes the upfront and monthly reservation fees while including discounts such as RI volume discounts.', null=True)),
                ('net_amortized_cost_unit', models.TextField(blank=True, db_comment='Unit type for net amortized costs.', null=True)),
                ('usage_quantity_amount', models.FloatField(blank=True, db_comment="The amount of usage that you incurred. NOTE: If you return the UsageQuantity metric, the service aggregates all usage numbers without taking into account the units. For example, if you aggregate usageQuantity across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hours vs. GB).", null=True)),
                ('usage_quantity_unit', models.TextField(blank=True, db_comment='Unit type for usage quantity.', null=True)),
                ('normalized_usage_amount', models.FloatField(blank=True, db_comment='The amount of usage that you incurred, in normalized units, for size-flexible RIs. The NormalizedUsageAmount is equal to UsageAmount multiplied by NormalizationFactor.', null=True)),
                ('normalized_usage_unit', models.TextField(blank=True, db_comment='Unit type for normalized usage.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cost_by_record_type_daily',
                'db_table_comment': 'AWS Cost Explorer - Cost by Record Type (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCostByRecordTypeMonthly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('linked_account_id', models.TextField(blank=True, db_comment='The linked AWS Account ID.', null=True)),
                ('record_type', models.TextField(blank=True, db_comment='The different types of charges such as RI fees, usage, costs, tax refunds, and credits.', null=True)),
                ('period_start', models.DateTimeField(blank=True, db_comment='Start timestamp for this cost metric.', null=True)),
                ('period_end', models.DateTimeField(blank=True, db_comment='End timestamp for this cost metric.', null=True)),
                ('estimated', models.BooleanField(blank=True, db_comment='Whether the result is estimated.', null=True)),
                ('blended_cost_amount', models.FloatField(blank=True, db_comment='This cost metric reflects the average cost of usage across the consolidated billing family. If you use the consolidated billing feature in AWS Organizations, you can view costs using blended rates.', null=True)),
                ('blended_cost_unit', models.TextField(blank=True, db_comment='Unit type for blended costs.', null=True)),
                ('unblended_cost_amount', models.FloatField(blank=True, db_comment='Unblended costs represent your usage costs on the day they are charged to you. In finance terms, they represent your costs on a cash basis of accounting.', null=True)),
                ('unblended_cost_unit', models.TextField(blank=True, db_comment='Unit type for unblended costs.', null=True)),
                ('net_unblended_cost_amount', models.FloatField(blank=True, db_comment='This cost metric reflects the unblended cost after discounts.', null=True)),
                ('net_unblended_cost_unit', models.TextField(blank=True, db_comment='Unit type for net unblended costs.', null=True)),
                ('amortized_cost_amount', models.FloatField(blank=True, db_comment="This cost metric reflects the effective cost of the upfront and monthly reservation fees spread across the billing period. By default, Cost Explorer shows the fees for Reserved Instances as a spike on the day that you're charged, but if you choose to show costs as amortized costs, the costs are amortized over the billing period. This means that the costs are broken out into the effective daily rate. AWS estimates your amortized costs by combining your unblended costs with the amortized portion of your upfront and recurring reservation fees.", null=True)),
                ('amortized_cost_unit', models.TextField(blank=True, db_comment='Unit type for amortized costs.', null=True)),
                ('net_amortized_cost_amount', models.FloatField(blank=True, db_comment='This cost metric amortizes the upfront and monthly reservation fees while including discounts such as RI volume discounts.', null=True)),
                ('net_amortized_cost_unit', models.TextField(blank=True, db_comment='Unit type for net amortized costs.', null=True)),
                ('usage_quantity_amount', models.FloatField(blank=True, db_comment="The amount of usage that you incurred. NOTE: If you return the UsageQuantity metric, the service aggregates all usage numbers without taking into account the units. For example, if you aggregate usageQuantity across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hours vs. GB).", null=True)),
                ('usage_quantity_unit', models.TextField(blank=True, db_comment='Unit type for usage quantity.', null=True)),
                ('normalized_usage_amount', models.FloatField(blank=True, db_comment='The amount of usage that you incurred, in normalized units, for size-flexible RIs. The NormalizedUsageAmount is equal to UsageAmount multiplied by NormalizationFactor.', null=True)),
                ('normalized_usage_unit', models.TextField(blank=True, db_comment='Unit type for normalized usage.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cost_by_record_type_monthly',
                'db_table_comment': 'AWS Cost Explorer - Cost by Record Type (Monthly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCostByServiceDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('service', models.TextField(blank=True, db_comment='The name of the AWS service.', null=True)),
                ('period_start', models.DateTimeField(blank=True, db_comment='Start timestamp for this cost metric.', null=True)),
                ('period_end', models.DateTimeField(blank=True, db_comment='End timestamp for this cost metric.', null=True)),
                ('estimated', models.BooleanField(blank=True, db_comment='Whether the result is estimated.', null=True)),
                ('blended_cost_amount', models.FloatField(blank=True, db_comment='This cost metric reflects the average cost of usage across the consolidated billing family. If you use the consolidated billing feature in AWS Organizations, you can view costs using blended rates.', null=True)),
                ('blended_cost_unit', models.TextField(blank=True, db_comment='Unit type for blended costs.', null=True)),
                ('unblended_cost_amount', models.FloatField(blank=True, db_comment='Unblended costs represent your usage costs on the day they are charged to you. In finance terms, they represent your costs on a cash basis of accounting.', null=True)),
                ('unblended_cost_unit', models.TextField(blank=True, db_comment='Unit type for unblended costs.', null=True)),
                ('net_unblended_cost_amount', models.FloatField(blank=True, db_comment='This cost metric reflects the unblended cost after discounts.', null=True)),
                ('net_unblended_cost_unit', models.TextField(blank=True, db_comment='Unit type for net unblended costs.', null=True)),
                ('amortized_cost_amount', models.FloatField(blank=True, db_comment="This cost metric reflects the effective cost of the upfront and monthly reservation fees spread across the billing period. By default, Cost Explorer shows the fees for Reserved Instances as a spike on the day that you're charged, but if you choose to show costs as amortized costs, the costs are amortized over the billing period. This means that the costs are broken out into the effective daily rate. AWS estimates your amortized costs by combining your unblended costs with the amortized portion of your upfront and recurring reservation fees.", null=True)),
                ('amortized_cost_unit', models.TextField(blank=True, db_comment='Unit type for amortized costs.', null=True)),
                ('net_amortized_cost_amount', models.FloatField(blank=True, db_comment='This cost metric amortizes the upfront and monthly reservation fees while including discounts such as RI volume discounts.', null=True)),
                ('net_amortized_cost_unit', models.TextField(blank=True, db_comment='Unit type for net amortized costs.', null=True)),
                ('usage_quantity_amount', models.FloatField(blank=True, db_comment="The amount of usage that you incurred. NOTE: If you return the UsageQuantity metric, the service aggregates all usage numbers without taking into account the units. For example, if you aggregate usageQuantity across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hours vs. GB).", null=True)),
                ('usage_quantity_unit', models.TextField(blank=True, db_comment='Unit type for usage quantity.', null=True)),
                ('normalized_usage_amount', models.FloatField(blank=True, db_comment='The amount of usage that you incurred, in normalized units, for size-flexible RIs. The NormalizedUsageAmount is equal to UsageAmount multiplied by NormalizationFactor.', null=True)),
                ('normalized_usage_unit', models.TextField(blank=True, db_comment='Unit type for normalized usage.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cost_by_service_daily',
                'db_table_comment': 'AWS Cost Explorer - Cost by Service (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCostByServiceMonthly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('service', models.TextField(blank=True, db_comment='The name of the AWS service.', null=True)),
                ('period_start', models.DateTimeField(blank=True, db_comment='Start timestamp for this cost metric.', null=True)),
                ('period_end', models.DateTimeField(blank=True, db_comment='End timestamp for this cost metric.', null=True)),
                ('estimated', models.BooleanField(blank=True, db_comment='Whether the result is estimated.', null=True)),
                ('blended_cost_amount', models.FloatField(blank=True, db_comment='This cost metric reflects the average cost of usage across the consolidated billing family. If you use the consolidated billing feature in AWS Organizations, you can view costs using blended rates.', null=True)),
                ('blended_cost_unit', models.TextField(blank=True, db_comment='Unit type for blended costs.', null=True)),
                ('unblended_cost_amount', models.FloatField(blank=True, db_comment='Unblended costs represent your usage costs on the day they are charged to you. In finance terms, they represent your costs on a cash basis of accounting.', null=True)),
                ('unblended_cost_unit', models.TextField(blank=True, db_comment='Unit type for unblended costs.', null=True)),
                ('net_unblended_cost_amount', models.FloatField(blank=True, db_comment='This cost metric reflects the unblended cost after discounts.', null=True)),
                ('net_unblended_cost_unit', models.TextField(blank=True, db_comment='Unit type for net unblended costs.', null=True)),
                ('amortized_cost_amount', models.FloatField(blank=True, db_comment="This cost metric reflects the effective cost of the upfront and monthly reservation fees spread across the billing period. By default, Cost Explorer shows the fees for Reserved Instances as a spike on the day that you're charged, but if you choose to show costs as amortized costs, the costs are amortized over the billing period. This means that the costs are broken out into the effective daily rate. AWS estimates your amortized costs by combining your unblended costs with the amortized portion of your upfront and recurring reservation fees.", null=True)),
                ('amortized_cost_unit', models.TextField(blank=True, db_comment='Unit type for amortized costs.', null=True)),
                ('net_amortized_cost_amount', models.FloatField(blank=True, db_comment='This cost metric amortizes the upfront and monthly reservation fees while including discounts such as RI volume discounts.', null=True)),
                ('net_amortized_cost_unit', models.TextField(blank=True, db_comment='Unit type for net amortized costs.', null=True)),
                ('usage_quantity_amount', models.FloatField(blank=True, db_comment="The amount of usage that you incurred. NOTE: If you return the UsageQuantity metric, the service aggregates all usage numbers without taking into account the units. For example, if you aggregate usageQuantity across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hours vs. GB).", null=True)),
                ('usage_quantity_unit', models.TextField(blank=True, db_comment='Unit type for usage quantity.', null=True)),
                ('normalized_usage_amount', models.FloatField(blank=True, db_comment='The amount of usage that you incurred, in normalized units, for size-flexible RIs. The NormalizedUsageAmount is equal to UsageAmount multiplied by NormalizationFactor.', null=True)),
                ('normalized_usage_unit', models.TextField(blank=True, db_comment='Unit type for normalized usage.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cost_by_service_monthly',
                'db_table_comment': 'AWS Cost Explorer - Cost by Service (Monthly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCostByServiceUsageTypeDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('service', models.TextField(blank=True, db_comment='The name of the AWS service.', null=True)),
                ('usage_type', models.TextField(blank=True, db_comment='The usage type of this metric.', null=True)),
                ('period_start', models.DateTimeField(blank=True, db_comment='Start timestamp for this cost metric.', null=True)),
                ('period_end', models.DateTimeField(blank=True, db_comment='End timestamp for this cost metric.', null=True)),
                ('estimated', models.BooleanField(blank=True, db_comment='Whether the result is estimated.', null=True)),
                ('blended_cost_amount', models.FloatField(blank=True, db_comment='This cost metric reflects the average cost of usage across the consolidated billing family. If you use the consolidated billing feature in AWS Organizations, you can view costs using blended rates.', null=True)),
                ('blended_cost_unit', models.TextField(blank=True, db_comment='Unit type for blended costs.', null=True)),
                ('unblended_cost_amount', models.FloatField(blank=True, db_comment='Unblended costs represent your usage costs on the day they are charged to you. In finance terms, they represent your costs on a cash basis of accounting.', null=True)),
                ('unblended_cost_unit', models.TextField(blank=True, db_comment='Unit type for unblended costs.', null=True)),
                ('net_unblended_cost_amount', models.FloatField(blank=True, db_comment='This cost metric reflects the unblended cost after discounts.', null=True)),
                ('net_unblended_cost_unit', models.TextField(blank=True, db_comment='Unit type for net unblended costs.', null=True)),
                ('amortized_cost_amount', models.FloatField(blank=True, db_comment="This cost metric reflects the effective cost of the upfront and monthly reservation fees spread across the billing period. By default, Cost Explorer shows the fees for Reserved Instances as a spike on the day that you're charged, but if you choose to show costs as amortized costs, the costs are amortized over the billing period. This means that the costs are broken out into the effective daily rate. AWS estimates your amortized costs by combining your unblended costs with the amortized portion of your upfront and recurring reservation fees.", null=True)),
                ('amortized_cost_unit', models.TextField(blank=True, db_comment='Unit type for amortized costs.', null=True)),
                ('net_amortized_cost_amount', models.FloatField(blank=True, db_comment='This cost metric amortizes the upfront and monthly reservation fees while including discounts such as RI volume discounts.', null=True)),
                ('net_amortized_cost_unit', models.TextField(blank=True, db_comment='Unit type for net amortized costs.', null=True)),
                ('usage_quantity_amount', models.FloatField(blank=True, db_comment="The amount of usage that you incurred. NOTE: If you return the UsageQuantity metric, the service aggregates all usage numbers without taking into account the units. For example, if you aggregate usageQuantity across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hours vs. GB).", null=True)),
                ('usage_quantity_unit', models.TextField(blank=True, db_comment='Unit type for usage quantity.', null=True)),
                ('normalized_usage_amount', models.FloatField(blank=True, db_comment='The amount of usage that you incurred, in normalized units, for size-flexible RIs. The NormalizedUsageAmount is equal to UsageAmount multiplied by NormalizationFactor.', null=True)),
                ('normalized_usage_unit', models.TextField(blank=True, db_comment='Unit type for normalized usage.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cost_by_service_usage_type_daily',
                'db_table_comment': 'AWS Cost Explorer - Cost by Service and Usage Type (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsCostByServiceUsageTypeMonthly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('service', models.TextField(blank=True, db_comment='The name of the AWS service.', null=True)),
                ('usage_type', models.TextField(blank=True, db_comment='The usage type of this metric.', null=True)),
                ('period_start', models.DateTimeField(blank=True, db_comment='Start timestamp for this cost metric.', null=True)),
                ('period_end', models.DateTimeField(blank=True, db_comment='End timestamp for this cost metric.', null=True)),
                ('estimated', models.BooleanField(blank=True, db_comment='Whether the result is estimated.', null=True)),
                ('blended_cost_amount', models.FloatField(blank=True, db_comment='This cost metric reflects the average cost of usage across the consolidated billing family. If you use the consolidated billing feature in AWS Organizations, you can view costs using blended rates.', null=True)),
                ('blended_cost_unit', models.TextField(blank=True, db_comment='Unit type for blended costs.', null=True)),
                ('unblended_cost_amount', models.FloatField(blank=True, db_comment='Unblended costs represent your usage costs on the day they are charged to you. In finance terms, they represent your costs on a cash basis of accounting.', null=True)),
                ('unblended_cost_unit', models.TextField(blank=True, db_comment='Unit type for unblended costs.', null=True)),
                ('net_unblended_cost_amount', models.FloatField(blank=True, db_comment='This cost metric reflects the unblended cost after discounts.', null=True)),
                ('net_unblended_cost_unit', models.TextField(blank=True, db_comment='Unit type for net unblended costs.', null=True)),
                ('amortized_cost_amount', models.FloatField(blank=True, db_comment="This cost metric reflects the effective cost of the upfront and monthly reservation fees spread across the billing period. By default, Cost Explorer shows the fees for Reserved Instances as a spike on the day that you're charged, but if you choose to show costs as amortized costs, the costs are amortized over the billing period. This means that the costs are broken out into the effective daily rate. AWS estimates your amortized costs by combining your unblended costs with the amortized portion of your upfront and recurring reservation fees.", null=True)),
                ('amortized_cost_unit', models.TextField(blank=True, db_comment='Unit type for amortized costs.', null=True)),
                ('net_amortized_cost_amount', models.FloatField(blank=True, db_comment='This cost metric amortizes the upfront and monthly reservation fees while including discounts such as RI volume discounts.', null=True)),
                ('net_amortized_cost_unit', models.TextField(blank=True, db_comment='Unit type for net amortized costs.', null=True)),
                ('usage_quantity_amount', models.FloatField(blank=True, db_comment="The amount of usage that you incurred. NOTE: If you return the UsageQuantity metric, the service aggregates all usage numbers without taking into account the units. For example, if you aggregate usageQuantity across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hours vs. GB).", null=True)),
                ('usage_quantity_unit', models.TextField(blank=True, db_comment='Unit type for usage quantity.', null=True)),
                ('normalized_usage_amount', models.FloatField(blank=True, db_comment='The amount of usage that you incurred, in normalized units, for size-flexible RIs. The NormalizedUsageAmount is equal to UsageAmount multiplied by NormalizationFactor.', null=True)),
                ('normalized_usage_unit', models.TextField(blank=True, db_comment='Unit type for normalized usage.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_cost_by_service_usage_type_monthly',
                'db_table_comment': 'AWS Cost Explorer - Cost by Service and Usage Type (Monthly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDaxCluster',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cluster_name', models.TextField(blank=True, db_comment='The name of the DAX cluster.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that uniquely identifies the cluster.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the cluster.', null=True)),
                ('active_nodes', models.BigIntegerField(blank=True, db_comment='The number of nodes in the cluster that are active.', null=True)),
                ('iam_role_arn', models.TextField(blank=True, db_comment='A valid Amazon Resource Name (ARN) that identifies an IAM role.', null=True)),
                ('node_type', models.TextField(blank=True, db_comment='The node type for the nodes in the cluster.', null=True)),
                ('preferred_maintenance_window', models.TextField(blank=True, db_comment='A range of time when maintenance of DAX cluster software will be performed.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current status of the cluster.', null=True)),
                ('subnet_group', models.TextField(blank=True, db_comment='The subnet group where the DAX cluster is running.', null=True)),
                ('total_nodes', models.TextField(blank=True, db_comment='The total number of nodes in the cluster.', null=True)),
                ('cluster_discovery_endpoint', models.JSONField(blank=True, db_comment='The configuration endpoint for this DAX cluster, consisting of a DNS name and a port number.', null=True)),
                ('node_ids_to_remove', models.JSONField(blank=True, db_comment='A list of nodes to be removed from the cluster.', null=True)),
                ('nodes', models.JSONField(blank=True, db_comment='A list of nodes that are currently in the cluster.', null=True)),
                ('notification_configuration', models.JSONField(blank=True, db_comment='Describes a notification topic and its status.', null=True)),
                ('parameter_group', models.JSONField(blank=True, db_comment='The parameter group being used by nodes in the cluster.', null=True)),
                ('sse_description', models.JSONField(blank=True, db_comment='The description of the server-side encryption status on the specified DAX cluster.', null=True)),
                ('security_groups', models.JSONField(blank=True, db_comment='A list of security groups, and the status of each, for the nodes in the cluster.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags currently associated with the DAX cluster.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_dax_cluster',
                'db_table_comment': 'AWS DAX Cluster',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDaxParameter',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('parameter_name', models.TextField(blank=True, db_comment='The name of the parameter.', null=True)),
                ('parameter_group_name', models.TextField(blank=True, db_comment='The name of the parameter group.', null=True)),
                ('parameter_value', models.TextField(blank=True, db_comment='The value of the parameter.', null=True)),
                ('description', models.TextField(blank=True, db_comment='Description of the parameter.', null=True)),
                ('allowed_values', models.TextField(blank=True, db_comment='A range of values within which the parameter can be set.', null=True)),
                ('change_type', models.TextField(blank=True, db_comment="The conditions under which changes to this parameter can be applied. Possible values are 'IMMEDIATE', 'REQUIRES_REBOOT'.", null=True)),
                ('data_type', models.TextField(blank=True, db_comment='The data type of the parameter.', null=True)),
                ('is_modifiable', models.TextField(blank=True, db_comment="Whether the customer is allowed to modify the parameter. Possible values are 'TRUE', 'FALSE' 'CONDITIONAL'.", null=True)),
                ('parameter_type', models.TextField(blank=True, db_comment="Determines whether the parameter can be applied to any node or only nodes of a particular type. Possible values are 'DEFAULT', 'NODE_TYPE_SPECIFIC'.", null=True)),
                ('source', models.TextField(blank=True, db_comment='How the parameter is defined. For example, system denotes a system-defined parameter.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_dax_parameter',
                'db_table_comment': 'AWS DAX Parameter',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDaxParameterGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('parameter_group_name', models.TextField(blank=True, db_comment='The name of the parameter group.', null=True)),
                ('description', models.TextField(blank=True, db_comment='Description of the parameter group.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_dax_parameter_group',
                'db_table_comment': 'AWS DAX Parameter Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDaxSubnetGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('subnet_group_name', models.TextField(blank=True, db_comment='The name of the subnet group.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the subnet group.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The Amazon Virtual Private Cloud identifier (VPC ID) of the subnet group.', null=True)),
                ('subnets', models.JSONField(blank=True, db_comment='A list of subnets associated with the subnet group.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_dax_subnet_group',
                'db_table_comment': 'AWS DAX Subnet Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDirectoryServiceCertificate',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('directory_id', models.TextField(blank=True, db_comment='The directory identifier.', null=True)),
                ('certificate_id', models.TextField(blank=True, db_comment='The identifier of the certificate.', null=True)),
                ('common_name', models.TextField(blank=True, db_comment='The common name for the certificate.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The function that the registered certificate performs. Valid values include ClientLDAPS or ClientCertAuth. The default value is ClientLDAPS.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The state of the certificate. Valid values: Registering | Registered | RegisterFailed | Deregistering | Deregistered | DeregisterFailed.', null=True)),
                ('expiry_date_time', models.DateTimeField(blank=True, db_comment='The date and time when the certificate will expire.', null=True)),
                ('registered_date_time', models.DateTimeField(blank=True, db_comment='The date and time that the certificate was registered.', null=True)),
                ('state_reason', models.TextField(blank=True, db_comment='Describes a state change for the certificate.', null=True)),
                ('client_cert_auth_settings', models.JSONField(blank=True, db_comment='A ClientCertAuthSettings object that contains client certificate authentication settings.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_directory_service_certificate',
                'db_table_comment': 'AWS Directory Service Certificate',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDirectoryServiceDirectory',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The fully qualified name of the directory.', null=True)),
                ('directory_id', models.TextField(blank=True, db_comment='The directory identifier.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that uniquely identifies the directory.', null=True)),
                ('stage', models.TextField(blank=True, db_comment='The current stage of the directory.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The directory type.', null=True)),
                ('access_url', models.TextField(blank=True, db_comment='The access URL for the directory, such as http://<alias>.awsapps.com.', null=True)),
                ('alias', models.TextField(blank=True, db_comment='The alias for the directory.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description for the directory.', null=True)),
                ('desired_number_of_domain_controllers', models.BigIntegerField(blank=True, db_comment='The desired number of domain controllers in the directory if the directory is Microsoft AD.', null=True)),
                ('edition', models.TextField(blank=True, db_comment='The edition associated with this directory.', null=True)),
                ('launch_time', models.DateTimeField(blank=True, db_comment='Specifies when the directory was created.', null=True)),
                ('radius_status', models.TextField(blank=True, db_comment='The status of the RADIUS MFA server connection.', null=True)),
                ('share_method', models.TextField(blank=True, db_comment='The method used when sharing a directory to determine whether the directory should be shared within your AWS organization (ORGANIZATIONS) or with any AWS account by sending a shared directory request (HANDSHAKE).', null=True)),
                ('share_notes', models.TextField(blank=True, db_comment='A directory share request that is sent by the directory owner to the directory consumer.', null=True)),
                ('share_status', models.TextField(blank=True, db_comment='Current directory status of the shared AWS Managed Microsoft AD directory.', null=True)),
                ('short_name', models.TextField(blank=True, db_comment='The short name of the directory.', null=True)),
                ('size', models.TextField(blank=True, db_comment='The directory size.', null=True)),
                ('sso_enabled', models.BooleanField(blank=True, db_comment='Indicates if single sign-on is enabled for the directory. For more information, see EnableSso and DisableSso.', null=True)),
                ('stage_last_updated_date_time', models.DateTimeField(blank=True, db_comment='The date and time that the stage was last updated.', null=True)),
                ('stage_reason', models.TextField(blank=True, db_comment='Additional information about the directory stage.', null=True)),
                ('connect_settings', models.JSONField(blank=True, db_comment='A DirectoryConnectSettingsDescription object that contains additional information about an AD Connector directory.', null=True)),
                ('dns_ip_addrs', models.JSONField(blank=True, db_comment='The IP addresses of the DNS servers for the directory.', null=True)),
                ('event_topics', models.JSONField(blank=True, db_comment='Amazon SNS topic names that receive status messages from the specified Directory ID.', null=True)),
                ('snapshot_limit', models.JSONField(blank=True, db_comment='Obtains the manual snapshot limits for a directory.', null=True)),
                ('owner_directory_description', models.JSONField(blank=True, db_comment='Describes the AWS Managed Microsoft AD directory in the directory owner account.', null=True)),
                ('radius_settings', models.JSONField(blank=True, db_comment='A RadiusSettings object that contains information about the RADIUS server.', null=True)),
                ('regions_info', models.JSONField(blank=True, db_comment='Lists the Regions where the directory has replicated.', null=True)),
                ('shared_directories', models.JSONField(blank=True, db_comment='Details about the shared directory in the directory owner account for which the share request in the directory consumer account has been accepted.', null=True)),
                ('vpc_settings', models.JSONField(blank=True, db_comment='A DirectoryVpcSettingsDescription object that contains additional information about a directory.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags currently associated with the Directory Service Directory.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_directory_service_directory',
                'db_table_comment': 'AWS Directory Service Directory',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDirectoryServiceLogSubscription',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('directory_id', models.TextField(blank=True, db_comment='Identifier (ID) of the directory that you want to associate with the log subscription.', null=True)),
                ('log_group_name', models.TextField(blank=True, db_comment='The name of the log group.', null=True)),
                ('subscription_created_date_time', models.DateTimeField(blank=True, db_comment='The date and time that the log subscription was created.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_directory_service_log_subscription',
                'db_table_comment': 'AWS Directory Service Log Subscription',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDlmLifecyclePolicy',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('policy_id', models.TextField(blank=True, db_comment='The identifier of the lifecycle policy.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the policy.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the lifecycle policy.', null=True)),
                ('date_created', models.DateTimeField(blank=True, db_comment='The local date and time when the lifecycle policy was created.', null=True)),
                ('date_modified', models.DateTimeField(blank=True, db_comment='The local date and time when the lifecycle policy was last modified.', null=True)),
                ('execution_role_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the IAM role used to run the operations specified by the lifecycle policy.', null=True)),
                ('policy_type', models.TextField(blank=True, db_comment='The type of policy.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The activation state of the lifecycle policy.', null=True)),
                ('status_message', models.TextField(blank=True, db_comment='The description of the status.', null=True)),
                ('policy_details', models.JSONField(blank=True, db_comment='The configuration of the lifecycle policy.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_dlm_lifecycle_policy',
                'db_table_comment': 'AWS DLM Lifecycle Policy',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDmsCertificate',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('certificate_identifier', models.TextField(blank=True, db_comment="A customer-assigned name for the certificate. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.", null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the certificate.', null=True)),
                ('certificate_creation_date', models.DateTimeField(blank=True, db_comment='The date that the certificate was created.', null=True)),
                ('certificate_owner', models.TextField(blank=True, db_comment='The owner of the certificate.', null=True)),
                ('certificate_pem', models.TextField(blank=True, db_comment='The contents of a .pem file, which contains an X.509 certificate.', null=True)),
                ('certificate_wallet', models.TextField(blank=True, db_comment='The location of an imported Oracle Wallet certificate for use with SSL.', null=True)),
                ('key_length', models.BigIntegerField(blank=True, db_comment='The key length of the cryptographic algorithm being used.', null=True)),
                ('signing_algorithm', models.TextField(blank=True, db_comment='The signing algorithm for the certificate.', null=True)),
                ('valid_from_date', models.DateTimeField(blank=True, db_comment='The beginning date that the certificate is valid.', null=True)),
                ('valid_to_date', models.DateTimeField(blank=True, db_comment='The final date that the certificate is valid.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags currently associated with the certificate.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_dms_certificate',
                'db_table_comment': 'AWS DMS Certificate',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDmsEndpoint',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('endpoint_identifier', models.TextField(blank=True, db_comment='The database endpoint identifier.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.', null=True)),
                ('certificate_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) used for SSL connection to the endpoint.', null=True)),
                ('database_name', models.TextField(blank=True, db_comment='The name of the database at the endpoint.', null=True)),
                ('endpoint_type', models.TextField(blank=True, db_comment='The type of endpoint. Valid values are source and target.', null=True)),
                ('engine_display_name', models.TextField(blank=True, db_comment="The expanded name for the engine name. For example, if the EngineName parameter is 'aurora', this value would be 'Amazon Aurora MySQL'.", null=True)),
                ('engine_name', models.TextField(blank=True, db_comment="The database engine name. Valid values, depending on the EndpointType, include 'mysql', 'oracle', 'postgres', 'mariadb', 'aurora', 'aurora-postgresql', 'redshift', 's3', 'db2', 'db2-zos', 'azuredb', 'sybase', 'dynamodb', 'mongodb', 'kinesis', 'kafka', 'elasticsearch', 'documentdb', 'sqlserver', 'neptune', and 'babelfish'.", null=True)),
                ('external_id', models.TextField(blank=True, db_comment='Value returned by a call to CreateEndpoint that can be used for cross-account validation.', null=True)),
                ('external_table_definition', models.TextField(blank=True, db_comment='The external table definition.', null=True)),
                ('extra_connection_attributes', models.TextField(blank=True, db_comment='Additional connection attributes used to connect to the endpoint.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='An KMS key identifier that is used to encrypt the connection parameters for the endpoint.', null=True)),
                ('server_name', models.TextField(blank=True, db_comment='The name of the server at the endpoint.', null=True)),
                ('service_access_role_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) used by the service to access the IAM role.', null=True)),
                ('ssl_mode', models.TextField(blank=True, db_comment='The SSL mode used to connect to the endpoint. The default value is none.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the endpoint.', null=True)),
                ('username', models.TextField(blank=True, db_comment='The user name used to connect to the endpoint.', null=True)),
                ('port', models.BigIntegerField(blank=True, db_comment='The port value used to access the endpoint.', null=True)),
                ('dms_transfer_settings', models.JSONField(blank=True, db_comment='The settings for the DMS Transfer type source.', null=True)),
                ('doc_db_settings', models.JSONField(blank=True, db_comment='Provides information that defines a DocumentDB endpoint.', null=True)),
                ('dynamo_db_settings', models.JSONField(blank=True, db_comment='The settings for the DynamoDB target endpoint.', null=True)),
                ('elasticsearch_settings', models.JSONField(blank=True, db_comment='The settings for the OpenSearch source endpoint.', null=True)),
                ('gcp_my_sql_settings', models.JSONField(blank=True, db_comment='Settings in JSON format for the source GCP MySQL endpoint.', null=True)),
                ('ibm_db2_settings', models.JSONField(blank=True, db_comment='The settings for the IBM Db2 LUW source endpoint.', null=True)),
                ('kafka_settings', models.JSONField(blank=True, db_comment='The settings for the Apache Kafka target endpoint.', null=True)),
                ('kinesis_settings', models.JSONField(blank=True, db_comment='The settings for the Amazon Kinesis target endpoint.', null=True)),
                ('microsoft_sql_server_settings', models.JSONField(blank=True, db_comment='The settings for the Microsoft SQL Server source and target endpoint.', null=True)),
                ('mongo_db_settings', models.JSONField(blank=True, db_comment='The settings for the MongoDB source endpoint.', null=True)),
                ('my_sql_settings', models.JSONField(blank=True, db_comment='The settings for the MySQL source and target endpoint.', null=True)),
                ('neptune_settings', models.JSONField(blank=True, db_comment='The settings for the Amazon Neptune target endpoint.', null=True)),
                ('oracle_settings', models.JSONField(blank=True, db_comment='The settings for the Oracle source and target endpoint.', null=True)),
                ('postgre_sql_settings', models.JSONField(blank=True, db_comment='The settings for the PostgreSQL source and target endpoint.', null=True)),
                ('redis_settings', models.JSONField(blank=True, db_comment='The settings for the Redis target endpoint.', null=True)),
                ('redshift_settings', models.JSONField(blank=True, db_comment='Settings for the Amazon Redshift endpoint.', null=True)),
                ('s3_settings', models.JSONField(blank=True, db_comment='The settings for the S3 target endpoint.', null=True)),
                ('sybase_settings', models.JSONField(blank=True, db_comment='The settings for the SAP ASE source and target endpoint.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags currently associated with the replication instance.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_dms_endpoint',
                'db_table_comment': 'AWS DMS Endpoint',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDmsReplicationInstance',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('replication_instance_identifier', models.TextField(blank=True, db_comment='The identifier of the replication instance.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the replication instance.', null=True)),
                ('replication_instance_class', models.TextField(blank=True, db_comment='The compute and memory capacity of the replication instance as defined for the specified replication instance class.', null=True)),
                ('engine_version', models.TextField(blank=True, db_comment='The engine version number of the replication instance.', null=True)),
                ('publicly_accessible', models.BooleanField(blank=True, db_comment='Specifies the accessibility options for the replication instance.', null=True)),
                ('allocated_storage', models.BigIntegerField(blank=True, db_comment='The amount of storage (in gigabytes) that is allocated for the replication instance.', null=True)),
                ('auto_minor_version_upgrade', models.BooleanField(blank=True, db_comment='Boolean value indicating if minor version upgrades will be automatically applied to the instance.', null=True)),
                ('availability_zone', models.TextField(blank=True, db_comment='The Availability Zone for the instance.', null=True)),
                ('dns_name_servers', models.TextField(blank=True, db_comment='The DNS name servers supported for the replication instance to access your on-premise source or target database.', null=True)),
                ('free_until', models.DateTimeField(blank=True, db_comment='The expiration date of the free replication instance that is part of the Free DMS program.', null=True)),
                ('instance_create_time', models.DateTimeField(blank=True, db_comment='The time the replication instance was created.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='An AWS KMS key identifier that is used to encrypt the data on the replication instance.', null=True)),
                ('multi_az', models.BooleanField(blank=True, db_comment='Specifies whether the replication instance is a Multi-AZ deployment.', null=True)),
                ('preferred_maintenance_window', models.TextField(blank=True, db_comment='The maintenance window times for the replication instance.', null=True)),
                ('replication_instance_private_ip_address', models.TextField(blank=True, db_comment='The private IP address of the replication instance.', null=True)),
                ('replication_instance_public_ip_address', models.TextField(blank=True, db_comment='The public IP address of the replication instance.', null=True)),
                ('replication_instance_status', models.TextField(blank=True, db_comment='The status of the replication instance.', null=True)),
                ('secondary_availability_zone', models.TextField(blank=True, db_comment='The Availability Zone of the standby replication instance in a Multi-AZ deployment.', null=True)),
                ('pending_modified_values', models.JSONField(blank=True, db_comment='The pending modification values.', null=True)),
                ('replication_instance_private_ip_addresses', models.JSONField(blank=True, db_comment='One or more private IP addresses for the replication instance.', null=True)),
                ('replication_instance_public_ip_addresses', models.JSONField(blank=True, db_comment='One or more public IP addresses for the replication instance.', null=True)),
                ('replication_subnet_group', models.JSONField(blank=True, db_comment='The subnet group for the replication instance.', null=True)),
                ('vpc_security_groups', models.JSONField(blank=True, db_comment='The VPC security group for the instance.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags currently associated with the replication instance.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_dms_replication_instance',
                'db_table_comment': 'AWS DMS Replication Instance',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDmsReplicationTask',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('replication_task_identifier', models.TextField(blank=True, db_comment='The user-assigned replication task identifier or name.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the replication task.', null=True)),
                ('cdc_start_position', models.TextField(blank=True, db_comment='Indicates when you want a change data capture (CDC) operation to start.', null=True)),
                ('cdc_stop_position', models.TextField(blank=True, db_comment='Indicates when you want a change data capture (CDC) operation to stop.', null=True)),
                ('last_failure_message', models.TextField(blank=True, db_comment='The last error (failure) message generated for the replication task.', null=True)),
                ('migration_type', models.TextField(blank=True, db_comment='The type of migration.', null=True)),
                ('recovery_checkpoint', models.TextField(blank=True, db_comment='Indicates the last checkpoint that occurred during a change data capture (CDC) operation.', null=True)),
                ('replication_instance_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the replication instance.', null=True)),
                ('replication_task_creation_date', models.DateTimeField(blank=True, db_comment='The date the replication task was created.', null=True)),
                ('replication_task_start_date', models.DateTimeField(blank=True, db_comment='The date the replication task is scheduled to start.', null=True)),
                ('source_endpoint_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that uniquely identifies the endpoint.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the replication task.', null=True)),
                ('stop_reason', models.TextField(blank=True, db_comment='The reason the replication task was stopped.', null=True)),
                ('table_mappings', models.TextField(blank=True, db_comment='Table mappings specified in the task.', null=True)),
                ('target_endpoint_arn', models.TextField(blank=True, db_comment='The ARN that uniquely identifies the endpoint.', null=True)),
                ('target_replication_instance_arn', models.TextField(blank=True, db_comment='The ARN of the replication instance to which this task is moved in response to running the MoveReplicationTask operation.', null=True)),
                ('task_data', models.TextField(blank=True, db_comment='Supplemental information that the task requires to migrate the data for certain source and target endpoints.', null=True)),
                ('replication_task_settings', models.JSONField(blank=True, db_comment='The settings for the replication task.', null=True)),
                ('replication_task_stats', models.JSONField(blank=True, db_comment='The statistics for the task, including elapsed time, tables loaded, and table errors.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags currently associated with the replication instance.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_dms_replication_task',
                'db_table_comment': 'AWS DMS Replication Task',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDocdbCluster',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_cluster_identifier', models.TextField(blank=True, db_comment='Contains a user-supplied cluster identifier. This identifier is the unique key that identifies a cluster.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the Cluster.', null=True)),
                ('status', models.TextField(blank=True, db_comment='Specifies the current state of this cluster.', null=True)),
                ('cluster_create_time', models.DateTimeField(blank=True, db_comment='Specifies the time when the cluster was created.', null=True)),
                ('backup_retention_period', models.BigIntegerField(blank=True, db_comment='Specifies the number of days for which automatic snapshots are retained.', null=True)),
                ('clone_group_id', models.TextField(blank=True, db_comment='Identifies the clone group to which the DB cluster is associated.', null=True)),
                ('db_cluster_parameter_group', models.TextField(blank=True, db_comment='Specifies the name of the cluster parameter group for the cluster.', null=True)),
                ('db_cluster_resource_id', models.TextField(blank=True, db_comment='The Region-unique, immutable identifier for the cluster.', null=True)),
                ('db_subnet_group', models.TextField(blank=True, db_comment='Specifies information on the subnet group associated with the cluster.', null=True)),
                ('deletion_protection', models.BooleanField(blank=True, db_comment='Specifies whether the cluster has deletion protection enabled, or not.', null=True)),
                ('earliest_restorable_time', models.DateTimeField(blank=True, db_comment='The earliest time to which a database can be restored with point-in-time restore.', null=True)),
                ('endpoint', models.TextField(blank=True, db_comment='Specifies the connection endpoint for the primary instance of the DB cluster.', null=True)),
                ('engine', models.TextField(blank=True, db_comment='The name of the database engine to be used for this DB cluster.', null=True)),
                ('engine_version', models.TextField(blank=True, db_comment='Indicates the database engine version.', null=True)),
                ('hosted_zone_id', models.TextField(blank=True, db_comment='Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The AWS KMS key identifier for the encrypted cluster.', null=True)),
                ('latest_restorable_time', models.DateTimeField(blank=True, db_comment='Specifies the latest time to which a database can be restored with point-in-time restore.', null=True)),
                ('master_user_name', models.TextField(blank=True, db_comment='Contains the master username for the cluster.', null=True)),
                ('multi_az', models.BooleanField(blank=True, db_comment='Specifies whether the cluster has instances in multiple Availability Zones, or not.', null=True)),
                ('percent_progress', models.TextField(blank=True, db_comment='Specifies the progress of the operation as a percentage.', null=True)),
                ('port', models.BigIntegerField(blank=True, db_comment='Specifies the port that the database engine is listening on.', null=True)),
                ('preferred_backup_window', models.TextField(blank=True, db_comment='Specifies the daily time range during which automated backups are created.', null=True)),
                ('preferred_maintenance_window', models.TextField(blank=True, db_comment='Specifies the weekly time range during which system maintenance can occur', null=True)),
                ('reader_endpoint', models.TextField(blank=True, db_comment='The reader endpoint for the DB cluster.', null=True)),
                ('replication_source_identifier', models.TextField(blank=True, db_comment='Contains the identifier of the source cluster if this cluster is a secondary cluster.', null=True)),
                ('storage_encrypted', models.BooleanField(blank=True, db_comment='Specifies whether the cluster is encrypted, or not.', null=True)),
                ('associated_roles', models.JSONField(blank=True, db_comment='A list of AWS IAM roles that are associated with the cluster.', null=True)),
                ('availability_zones', models.JSONField(blank=True, db_comment='A list of Availability Zones (AZs) where instances in the cluster can be created.', null=True)),
                ('enabled_cloudwatch_logs_exports', models.JSONField(blank=True, db_comment='A list of log types that this cluster is configured to export to Amazon CloudWatch Logs.', null=True)),
                ('members', models.JSONField(blank=True, db_comment='A list of instances that make up the cluster.', null=True)),
                ('read_replica_identifiers', models.JSONField(blank=True, db_comment='A list of identifiers of the read replicas associated with this cluster.', null=True)),
                ('vpc_security_groups', models.JSONField(blank=True, db_comment='A list of VPC security groups that the DB cluster belongs to.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the Cluster.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_docdb_cluster',
                'db_table_comment': 'AWS DocumentDB Cluster',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDocdbClusterInstance',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_instance_identifier', models.TextField(blank=True, db_comment='Contains a user-provided database identifier. This identifier is the unique key that identifies an instance.', null=True)),
                ('db_instance_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the instance.', null=True)),
                ('db_cluster_identifier', models.TextField(blank=True, db_comment='Contains the name of the cluster that the instance is a member of if the instance is a member of a cluster.', null=True)),
                ('db_instance_status', models.TextField(blank=True, db_comment='Specifies the current state of this database.', null=True)),
                ('db_instance_class', models.TextField(blank=True, db_comment='Contains the name of the compute and memory capacity class of the instance.', null=True)),
                ('dbi_resource_id', models.TextField(blank=True, db_comment='The Amazon Web Services Region-unique, immutable identifier for the instance.', null=True)),
                ('availability_zone', models.TextField(blank=True, db_comment='Specifies the name of the availability zone the instance is located in.', null=True)),
                ('backup_retention_period', models.BigIntegerField(blank=True, db_comment='Specifies the number of days for which automatic snapshots are retained.', null=True)),
                ('ca_certificate_identifier', models.TextField(blank=True, db_comment='The identifier of the CA certificate for this DB instance.', null=True)),
                ('copy_tags_to_snapshot', models.BooleanField(blank=True, db_comment='Specifies whether tags are copied from the DB instance to snapshots of the DB instance, or not.', null=True)),
                ('db_subnet_group_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the DB subnet group.', null=True)),
                ('db_subnet_group_description', models.TextField(blank=True, db_comment='Provides the description of the DB subnet group.', null=True)),
                ('db_subnet_group_name', models.TextField(blank=True, db_comment='The name of the DB subnet group.', null=True)),
                ('db_subnet_group_status', models.TextField(blank=True, db_comment='Provides the status of the DB subnet group.', null=True)),
                ('endpoint_address', models.TextField(blank=True, db_comment='Specifies the DNS address of the instance.', null=True)),
                ('endpoint_hosted_zone_id', models.TextField(blank=True, db_comment='Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.', null=True)),
                ('endpoint_port', models.BigIntegerField(blank=True, db_comment='Specifies the port that the database engine is listening on.', null=True)),
                ('engine', models.TextField(blank=True, db_comment='The name of the database engine to be used for this instance.', null=True)),
                ('engine_version', models.TextField(blank=True, db_comment='Indicates the database engine version.', null=True)),
                ('instance_create_time', models.DateTimeField(blank=True, db_comment='Provides the date and time the instance was created.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='If StorageEncrypted is true, the KMS key identifier for the encrypted instance.', null=True)),
                ('latest_restorable_time', models.DateTimeField(blank=True, db_comment='Specifies the latest time to which a database can be restored with point-in-time restore.', null=True)),
                ('preferred_backup_window', models.TextField(blank=True, db_comment='Specifies the daily time range during which automated backups are created.', null=True)),
                ('preferred_maintenance_window', models.TextField(blank=True, db_comment='Specifies the weekly time range during which system maintenance can occur.', null=True)),
                ('promotion_tier', models.BigIntegerField(blank=True, db_comment='A value that specifies the order in which an Amazon DocumentDB replica is promoted to the primary instance after a failure of the existing primary instance.', null=True)),
                ('publicly_accessible', models.BooleanField(blank=True, db_comment='Specifies the accessibility options for the DB instance.', null=True)),
                ('storage_encrypted', models.BooleanField(blank=True, db_comment='Specifies whether or not the instance is encrypted.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='Provides the VpcId of the DB subnet group.', null=True)),
                ('enabled_cloudwatch_logs_exports', models.JSONField(blank=True, db_comment='A list of log types that this instance is configured to export to CloudWatch Logs.', null=True)),
                ('pending_modified_values', models.JSONField(blank=True, db_comment='Specifies that changes to the instance are pending.', null=True)),
                ('status_infos', models.JSONField(blank=True, db_comment='The status of a read replica.', null=True)),
                ('subnets', models.JSONField(blank=True, db_comment='A list of subnet elements.', null=True)),
                ('vpc_security_groups', models.JSONField(blank=True, db_comment='A list of VPC security group elements that the instance belongs to.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the Instance.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_docdb_cluster_instance',
                'db_table_comment': 'AWS DocumentDB Cluster Instance',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDocdbClusterSnapshot',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_cluster_snapshot_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the cluster snapshot.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the cluster snapshot.', null=True)),
                ('snapshot_type', models.TextField(blank=True, db_comment='The type of the cluster snapshot.', null=True)),
                ('status', models.TextField(blank=True, db_comment='Specifies the status of this cluster snapshot.', null=True)),
                ('include_public', models.BooleanField(blank=True, db_comment='Set to true to include manual cluster snapshots that are public and can be copied or restored by any Amazon Web Services account, and otherwise false.', null=True)),
                ('include_shared', models.BooleanField(blank=True, db_comment='Set to true to include shared manual cluster snapshots from other Amazon Web Services accounts that this Amazon Web Services account has been given permission to copy or restore, and otherwise false.', null=True)),
                ('db_cluster_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the cluster, that the snapshot snapshot was created from.', null=True)),
                ('snapshot_create_time', models.DateTimeField(blank=True, db_comment='The time when the snapshot was taken.', null=True)),
                ('cluster_create_time', models.DateTimeField(blank=True, db_comment='Specifies the time when the cluster was created.', null=True)),
                ('engine', models.TextField(blank=True, db_comment='Specifies the name of the database engine.', null=True)),
                ('engine_version', models.TextField(blank=True, db_comment='Specifies the version of the database engine for this cluster snapshot.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The AWS KMS key identifier for the AWS KMS customer master key (CMK).', null=True)),
                ('master_user_name', models.TextField(blank=True, db_comment='Provides the master username for the cluster snapshot.', null=True)),
                ('percent_progress', models.BigIntegerField(blank=True, db_comment='Specifies the percentage of the estimated data that has been transferred.', null=True)),
                ('port', models.BigIntegerField(blank=True, db_comment='Specifies the port that the cluster was listening on at the time of the snapshot.', null=True)),
                ('source_db_cluster_snapshot_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the source cluster snapshot, if the cluster snapshot was copied from a source cluster snapshot.', null=True)),
                ('storage_encrypted', models.BooleanField(blank=True, db_comment='Specifies whether the cluster snapshot is encrypted, or not.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='Provides the VPC ID associated with the cluster snapshot.', null=True)),
                ('availability_zones', models.JSONField(blank=True, db_comment='A list of Availability Zones (AZs) where instances in the cluster snapshot can be restored.', null=True)),
                ('db_cluster_snapshot_attributes', models.JSONField(blank=True, db_comment='A list of DB cluster snapshot attribute names and values for a manual cluster snapshot.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the cluster snapshot.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_docdb_cluster_snapshot',
                'db_table_comment': 'AWS DocumentDB Cluster Snapshot',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDrsJob',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('job_id', models.TextField(blank=True, db_comment='The ID of the job.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of a Job.', null=True)),
                ('initiated_by', models.TextField(blank=True, db_comment='A string representing who initiated the Job.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the Job.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of the Job.', null=True)),
                ('creation_date_time', models.DateTimeField(blank=True, db_comment='The date and time of when the Job was created.', null=True)),
                ('end_date_time', models.DateTimeField(blank=True, db_comment='The date and time of when the Job ended.', null=True)),
                ('participating_servers', models.JSONField(blank=True, db_comment='A list of servers that the Job is acting upon.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_drs_job',
                'db_table_comment': 'AWS DRS Job',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDrsRecoveryInstance',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('recovery_instance_id', models.TextField(blank=True, db_comment='The ID of the recovery instance.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the recovery instance.', null=True)),
                ('source_server_id', models.TextField(blank=True, db_comment='The source server ID that this recovery instance is associated with.', null=True)),
                ('ec2_instance_id', models.TextField(blank=True, db_comment='The EC2 instance ID of the recovery instance.', null=True)),
                ('ec2_instance_state', models.TextField(blank=True, db_comment='The state of the EC2 instance for this recovery instance.', null=True)),
                ('is_drill', models.BooleanField(blank=True, db_comment='Whether this recovery instance was created for a drill or for an actual recovery event.', null=True)),
                ('job_id', models.TextField(blank=True, db_comment='The ID of the Job that created the recovery instance.', null=True)),
                ('origin_environment', models.TextField(blank=True, db_comment='Environment (On Premises/AWS) of the instance that the recovery instance originated from.', null=True)),
                ('point_in_time_snapshot_date_time', models.TextField(blank=True, db_comment='The date and time of the Point in Time (PIT) snapshot that this recovery instance was launched from.', null=True)),
                ('data_replication_info', models.JSONField(blank=True, db_comment='The Data Replication Info of the recovery instance.', null=True)),
                ('failback', models.JSONField(blank=True, db_comment='An object representing failback related information of the recovery instance.', null=True)),
                ('recovery_instance_properties', models.JSONField(blank=True, db_comment='Properties of the recovery instance machine.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_drs_recovery_instance',
                'db_table_comment': 'AWS DRS recovery instance',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDrsRecoverySnapshot',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('snapshot_id', models.TextField(blank=True, db_comment='The ID of the snapshot.', null=True)),
                ('source_server_id', models.TextField(blank=True, db_comment='The ID of the source server that the snapshot was taken for.', null=True)),
                ('expected_timestamp', models.DateTimeField(blank=True, db_comment='The timestamp of when we expect the snapshot to be taken.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The actual timestamp when the snapshot was taken.', null=True)),
                ('ebs_snapshots', models.JSONField(blank=True, db_comment='A list of EBS snapshots.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_drs_recovery_snapshot',
                'db_table_comment': 'AWS DRS Recovery Snapshot',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDrsSourceServer',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('source_server_id', models.TextField(blank=True, db_comment='The ID of the Source Server.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the Source Server.', null=True)),
                ('recovery_instance_id', models.TextField(blank=True, db_comment='The ID of the Recovery Instance associated with this Source Server.', null=True)),
                ('source_properties', models.JSONField(blank=True, db_comment='The source properties of the Source Server.', null=True)),
                ('data_replication_info', models.JSONField(blank=True, db_comment='The Data Replication Info of the Source Server.', null=True)),
                ('last_launch_result', models.TextField(blank=True, db_comment='The status of the last recovery launch of this Source Server.', null=True)),
                ('life_cycle', models.JSONField(blank=True, db_comment='The lifecycle information of this Source Server.', null=True)),
                ('replication_direction', models.TextField(blank=True, db_comment='Replication direction of the Source Server.', null=True)),
                ('reversed_direction_source_server_arn', models.TextField(blank=True, db_comment='For EC2-originated Source Servers which have been failed over and then failed back, this value will mean the ARN of the Source Server on the opposite replication direction.', null=True)),
                ('source_cloud_properties', models.JSONField(blank=True, db_comment='Source cloud properties of the Source Server.', null=True)),
                ('staging_area', models.JSONField(blank=True, db_comment='The staging area of the source server.', null=True)),
                ('staging_account_id', models.TextField(blank=True, db_comment='The staging account ID that extended source servers belong to.', null=True)),
                ('launch_configuration', models.JSONField(blank=True, db_comment='The launch configuration settings of the source server.', null=True)),
                ('hardware_id', models.TextField(blank=True, db_comment='An ID that describes the hardware of the Source Server. This is either an EC2 instance id, a VMware uuid or a mac address.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_drs_source_server',
                'db_table_comment': 'AWS DRS Source Server',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDynamodbBackup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='Name of the backup.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='Amazon Resource Name associated with the backup.', null=True)),
                ('table_name', models.TextField(blank=True, db_comment='Unique identifier for the table to which backup belongs.', null=True)),
                ('table_arn', models.TextField(blank=True, db_comment='Name of the table to which backup belongs.', null=True)),
                ('table_id', models.TextField(blank=True, db_comment='ARN associated with the table to which backup belongs.', null=True)),
                ('backup_status', models.TextField(blank=True, db_comment='Current status of the backup. Backup can be in one of the following states: CREATING, ACTIVE, DELETED.', null=True)),
                ('backup_type', models.TextField(blank=True, db_comment='Backup type (USER | SYSTEM | AWS_BACKUP).', null=True)),
                ('backup_creation_datetime', models.DateTimeField(blank=True, db_comment='Time at which the backup was created.', null=True)),
                ('backup_expiry_datetime', models.DateTimeField(blank=True, db_comment='Time at which the automatic on-demand backup created by DynamoDB will expire.', null=True)),
                ('backup_size_bytes', models.BigIntegerField(blank=True, db_comment='Size of the backup in bytes.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_dynamodb_backup',
                'db_table_comment': 'AWS DynamoDB Backup',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDynamodbGlobalTable',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('global_table_name', models.TextField(blank=True, db_comment='The global table name.', null=True)),
                ('global_table_arn', models.TextField(blank=True, db_comment='The unique identifier of the global table.', null=True)),
                ('global_table_status', models.TextField(blank=True, db_comment='The current state of the global table.', null=True)),
                ('creation_date_time', models.DateTimeField(blank=True, db_comment='The creation time of the global table.', null=True)),
                ('replication_group', models.JSONField(blank=True, db_comment='The Regions where the global table has replicas.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_dynamodb_global_table',
                'db_table_comment': 'AWS DynamoDB Global Table',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDynamodbMetricAccountProvisionedReadCapacityUtil',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_dynamodb_metric_account_provisioned_read_capacity_util',
                'db_table_comment': 'AWS DynamoDB Metric Account Provisioned Read Capacity Utilization',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDynamodbMetricAccountProvisionedWriteCapacityUtil',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_dynamodb_metric_account_provisioned_write_capacity_util',
                'db_table_comment': 'AWS DynamoDB Metric Account Provisioned Write Capacity Utilization',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDynamodbTable',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the table.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that uniquely identifies the table.', null=True)),
                ('table_id', models.TextField(blank=True, db_comment='Unique identifier for the table.', null=True)),
                ('creation_date_time', models.DateTimeField(blank=True, db_comment='The date and time when the table was created.', null=True)),
                ('table_class', models.TextField(blank=True, db_comment='The table class of the specified table. Valid values are STANDARD and STANDARD_INFREQUENT_ACCESS.', null=True)),
                ('table_status', models.TextField(blank=True, db_comment='The current state of the table.', null=True)),
                ('billing_mode', models.TextField(blank=True, db_comment='Controls how AWS charges for read and write throughput and manage capacity.', null=True)),
                ('item_count', models.BigIntegerField(blank=True, db_comment='Number of items in the table. Note that this is an approximate value.', null=True)),
                ('global_table_version', models.TextField(blank=True, db_comment='Represents the version of global tables (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GlobalTables.html) in use, if the table is replicated across AWS Regions.', null=True)),
                ('read_capacity', models.BigIntegerField(blank=True, db_comment='The maximum number of strongly consistent reads consumed per second before DynamoDB returns a ThrottlingException.', null=True)),
                ('write_capacity', models.BigIntegerField(blank=True, db_comment='The maximum number of writes consumed per second before DynamoDB returns a ThrottlingException.', null=True)),
                ('latest_stream_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that uniquely identifies the latest stream for this table.', null=True)),
                ('latest_stream_label', models.TextField(blank=True, db_comment='A timestamp, in ISO 8601 format, for this stream.', null=True)),
                ('table_size_bytes', models.BigIntegerField(blank=True, db_comment='Size of the table in bytes. Note that this is an approximate value.', null=True)),
                ('archival_summary', models.JSONField(blank=True, db_comment='Contains information about the table archive.', null=True)),
                ('attribute_definitions', models.JSONField(blank=True, db_comment='An array of AttributeDefinition objects. Each of these objects describes one attribute in the table and index key schema.', null=True)),
                ('key_schema', models.JSONField(blank=True, db_comment='The primary key structure for the table.', null=True)),
                ('sse_description', models.JSONField(blank=True, db_comment='The description of the server-side encryption status on the specified table.', null=True)),
                ('deletion_protection_enabled', models.BooleanField(blank=True, db_comment='Indicates whether deletion protection is enabled (true) or disabled (false) on the table.', null=True)),
                ('continuous_backups_status', models.TextField(blank=True, db_comment='The continuous backups status of the table. ContinuousBackupsStatus can be one of the following states: ENABLED, DISABLED.', null=True)),
                ('streaming_destination', models.JSONField(blank=True, db_comment='Provides information about the status of Kinesis streaming.', null=True)),
                ('point_in_time_recovery_description', models.JSONField(blank=True, db_comment='The description of the point in time recovery settings applied to the table.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the table.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_dynamodb_table',
                'db_table_comment': 'AWS DynamoDB Table',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsDynamodbTableExport',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the export.', null=True)),
                ('export_status', models.TextField(blank=True, db_comment='Export can be in one of the following states: IN_PROGRESS, COMPLETED, or FAILED.', null=True)),
                ('billed_size_bytes', models.BigIntegerField(blank=True, db_comment='The billable size of the table export.', null=True)),
                ('client_token', models.TextField(blank=True, db_comment='The client token that was provided for the export task. A client token makes calls to ExportTableToPointInTimeInput idempotent, meaning that multiple identical calls have the same effect as one single call.', null=True)),
                ('end_time', models.DateTimeField(blank=True, db_comment='The time at which the export task completed.', null=True)),
                ('export_format', models.TextField(blank=True, db_comment='The format of the exported data. Valid values for ExportFormat are DYNAMODB_JSON or ION.', null=True)),
                ('export_manifest', models.TextField(blank=True, db_comment='The name of the manifest file for the export task.', null=True)),
                ('export_time', models.DateTimeField(blank=True, db_comment='Point in time from which table data was exported.', null=True)),
                ('failure_code', models.TextField(blank=True, db_comment='Status code for the result of the failed export.', null=True)),
                ('failure_message', models.TextField(blank=True, db_comment='Export failure reason description.', null=True)),
                ('item_count', models.BigIntegerField(blank=True, db_comment='The number of items exported.', null=True)),
                ('s3_bucket', models.TextField(blank=True, db_comment='The name of the Amazon S3 bucket containing the export.', null=True)),
                ('s3_bucket_owner', models.TextField(blank=True, db_comment='The ID of the Amazon Web Services account that owns the bucket containing the export.', null=True)),
                ('s3_prefix', models.TextField(blank=True, db_comment='The Amazon S3 bucket prefix used as the file name and path of the exported snapshot.', null=True)),
                ('s3_sse_algorithm', models.TextField(blank=True, db_comment='Type of encryption used on the bucket where export data is stored.', null=True)),
                ('s3_sse_kms_key_id', models.TextField(blank=True, db_comment='The ID of the KMS managed key used to encrypt the S3 bucket where export data is stored (if applicable).', null=True)),
                ('start_time', models.DateTimeField(blank=True, db_comment='The time at which the export task began.', null=True)),
                ('table_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the table that was exported.', null=True)),
                ('table_id', models.TextField(blank=True, db_comment='Unique ID of the table that was exported.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_dynamodb_table_export',
                'db_table_comment': 'AWS DynamoDB Table Export',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEbsSnapshot',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('snapshot_id', models.TextField(blank=True, db_comment='The ID of the snapshot. Each snapshot receives a unique identifier when it is created.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the snapshot.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The snapshot state.', null=True)),
                ('volume_size', models.BigIntegerField(blank=True, db_comment='The size of the volume, in GiB.', null=True)),
                ('volume_id', models.TextField(blank=True, db_comment='The ID of the volume that was used to create the snapshot. Snapshots created by the CopySnapshot action have an arbitrary volume ID that should not be used for any purpose.', null=True)),
                ('encrypted', models.BooleanField(blank=True, db_comment='Indicates whether the snapshot is encrypted.', null=True)),
                ('start_time', models.DateTimeField(blank=True, db_comment='The time stamp when the snapshot was initiated.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description for the snapshot.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the parent volume.', null=True)),
                ('data_encryption_key_id', models.TextField(blank=True, db_comment='The data encryption key identifier for the snapshot. This value is a unique identifier that corresponds to the data encryption key that was used to encrypt the original volume or snapshot copy. Because data encryption keys are inherited by volumes created from snapshots, and vice versa, if snapshots share the same data encryption key identifier, then they belong to the same volume/snapshot lineage.', null=True)),
                ('progress', models.TextField(blank=True, db_comment='The progress of the snapshot, as a percentage.', null=True)),
                ('state_message', models.TextField(blank=True, db_comment='Encrypted Amazon EBS snapshots are copied asynchronously. If a snapshot copy operation fails this field displays error state details to help you diagnose why the error occurred.', null=True)),
                ('owner_alias', models.TextField(blank=True, db_comment='The AWS owner alias, from an Amazon-maintained list (amazon). This is not the user-configured AWS account alias set using the IAM console.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='The AWS account ID of the EBS snapshot owner.', null=True)),
                ('create_volume_permissions', models.JSONField(blank=True, db_comment='The users and groups that have the permissions for creating volumes from the snapshot.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the snapshot.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ebs_snapshot',
                'db_table_comment': 'AWS EBS Snapshot',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEbsVolume',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('volume_id', models.TextField(blank=True, db_comment='The ID of the volume.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the volume.', null=True)),
                ('volume_type', models.TextField(blank=True, db_comment='The volume type. This can be gp2 for General Purpose SSD, io1 or io2 for Provisioned IOPS SSD, st1 for Throughput Optimized HDD, sc1 for Cold HDD, or standard for Magnetic volumes.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The volume state.', null=True)),
                ('create_time', models.DateTimeField(blank=True, db_comment='The time stamp when volume creation was initiated.', null=True)),
                ('auto_enable_io', models.BooleanField(blank=True, db_comment='The state of autoEnableIO attribute.', null=True)),
                ('availability_zone', models.TextField(blank=True, db_comment='The Availability Zone for the volume.', null=True)),
                ('encrypted', models.BooleanField(blank=True, db_comment='Indicates whether the volume is encrypted.', null=True)),
                ('fast_restored', models.BooleanField(blank=True, db_comment='Indicates whether the volume was created using fast snapshot restore.', null=True)),
                ('iops', models.BigIntegerField(blank=True, db_comment='The number of I/O operations per second (IOPS) that the volume supports.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the volume.', null=True)),
                ('multi_attach_enabled', models.BooleanField(blank=True, db_comment='Indicates whether Amazon EBS Multi-Attach is enabled.', null=True)),
                ('outpost_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the Outpost.', null=True)),
                ('size', models.BigIntegerField(blank=True, db_comment='The size of the volume, in GiBs.', null=True)),
                ('snapshot_id', models.TextField(blank=True, db_comment='The snapshot from which the volume was created, if applicable.', null=True)),
                ('attachments', models.JSONField(blank=True, db_comment='Information about the volume attachments.', null=True)),
                ('product_codes', models.JSONField(blank=True, db_comment='A list of product codes.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the volume.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ebs_volume',
                'db_table_comment': 'AWS EBS Volume',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEbsVolumeMetricReadOps',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('volume_id', models.TextField(blank=True, db_comment='The EBS Volume ID.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ebs_volume_metric_read_ops',
                'db_table_comment': 'AWS EBS Volume Cloudwatch Metrics - Read Ops',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEbsVolumeMetricReadOpsDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('volume_id', models.TextField(blank=True, db_comment='The EBS Volume ID.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ebs_volume_metric_read_ops_daily',
                'db_table_comment': 'AWS EBS Volume Cloudwatch Metrics - Read Ops (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEbsVolumeMetricReadOpsHourly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('volume_id', models.TextField(blank=True, db_comment='The EBS Volume ID.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ebs_volume_metric_read_ops_hourly',
                'db_table_comment': 'AWS EBS Volume Cloudwatch Metrics - Read Ops (Hourly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEbsVolumeMetricWriteOps',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('volume_id', models.TextField(blank=True, db_comment='The EBS Volume ID.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ebs_volume_metric_write_ops',
                'db_table_comment': 'AWS EBS Volume Cloudwatch Metrics - Write Ops',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEbsVolumeMetricWriteOpsDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('volume_id', models.TextField(blank=True, db_comment='The EBS Volume ID.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ebs_volume_metric_write_ops_daily',
                'db_table_comment': 'AWS EBS Volume Cloudwatch Metrics - Write Ops (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEbsVolumeMetricWriteOpsHourly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('volume_id', models.TextField(blank=True, db_comment='The EBS Volume ID.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ebs_volume_metric_write_ops_hourly',
                'db_table_comment': 'AWS EBS Volume Cloudwatch Metrics - Write Ops (Hourly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2Ami',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the AMI that was provided during image creation.', null=True)),
                ('image_id', models.TextField(blank=True, db_comment='The ID of the AMI.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The current state of the AMI. If the state is available, the image is successfully registered and can be used to launch an instance.', null=True)),
                ('image_type', models.TextField(blank=True, db_comment='The type of image.', null=True)),
                ('image_location', models.TextField(blank=True, db_comment='The location of the AMI.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The date and time when the image was created.', null=True)),
                ('architecture', models.TextField(blank=True, db_comment='The architecture of the image.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the AMI that was provided during image creation.', null=True)),
                ('ena_support', models.BooleanField(blank=True, db_comment='Specifies whether enhanced networking with ENA is enabled.', null=True)),
                ('hypervisor', models.TextField(blank=True, db_comment='The hypervisor type of the image.', null=True)),
                ('image_owner_alias', models.TextField(blank=True, db_comment='The AWS account alias (for example, amazon, self) or the AWS account ID of the AMI owner.', null=True)),
                ('imds_support', models.TextField(blank=True, db_comment='If v2.0, it indicates that IMDSv2 is specified in the AMI.', null=True)),
                ('kernel_id', models.TextField(blank=True, db_comment='The kernel associated with the image, if any. Only applicable for machine images.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='The AWS account ID of the image owner.', null=True)),
                ('platform', models.TextField(blank=True, db_comment='This value is set to windows for Windows AMIs; otherwise, it is blank.', null=True)),
                ('platform_details', models.TextField(blank=True, db_comment='The platform details associated with the billing code of the AMI. For more information, see Obtaining Billing Information (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-billing-info.html) in the Amazon Elastic Compute Cloud User Guide.', null=True)),
                ('public', models.BooleanField(blank=True, db_comment='Indicates whether the image has public launch permissions. The value is true if this image has public launch permissions or false if it has only implicit and explicit launch permissions.', null=True)),
                ('ramdisk_id', models.TextField(blank=True, db_comment='The RAM disk associated with the image, if any. Only applicable for machine images.', null=True)),
                ('root_device_name', models.TextField(blank=True, db_comment='The device name of the root device volume (for example, /dev/sda1).', null=True)),
                ('root_device_type', models.TextField(blank=True, db_comment='The type of root device used by the AMI. The AMI can use an EBS volume or an instance store volume.', null=True)),
                ('sriov_net_support', models.TextField(blank=True, db_comment='Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.', null=True)),
                ('usage_operation', models.TextField(blank=True, db_comment='The operation of the Amazon EC2 instance and the billing code that is associated with the AMI. For the list of UsageOperation codes, see Platform Details and [Usage Operation Billing Codes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-billing-info.html#billing-info) in the Amazon Elastic Compute Cloud User Guide.', null=True)),
                ('virtualization_type', models.TextField(blank=True, db_comment='The type of virtualization of the AMI.', null=True)),
                ('block_device_mappings', models.JSONField(blank=True, db_comment='Any block device mapping entries.', null=True)),
                ('product_codes', models.JSONField(blank=True, db_comment='Any product codes associated with the AMI.', null=True)),
                ('launch_permissions', models.JSONField(blank=True, db_comment='The users and groups that have the permissions for creating instances from the AMI.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the AMI.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_ami',
                'db_table_comment': 'AWS EC2 AMI',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2ApplicationLoadBalancer',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The friendly name of the Load Balancer that was provided during resource creation.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the load balancer.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of load balancer.', null=True)),
                ('scheme', models.TextField(blank=True, db_comment='The load balancing scheme of load balancer.', null=True)),
                ('canonical_hosted_zone_id', models.TextField(blank=True, db_comment='The ID of the Amazon Route 53 hosted zone associated with the load balancer.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The ID of the VPC for the load balancer.', null=True)),
                ('created_time', models.DateTimeField(blank=True, db_comment='The date and time the load balancer was created.', null=True)),
                ('customer_owned_ipv4_pool', models.TextField(blank=True, db_comment='The ID of the customer-owned address pool.', null=True)),
                ('dns_name', models.TextField(blank=True, db_comment='The public DNS name of the load balancer.', null=True)),
                ('ip_address_type', models.TextField(blank=True, db_comment='The type of IP addresses used by the subnets for your load balancer.', null=True)),
                ('state_code', models.TextField(blank=True, db_comment='Current state of the load balancer.', null=True)),
                ('state_reason', models.TextField(blank=True, db_comment='A description of the state.', null=True)),
                ('availability_zones', models.JSONField(blank=True, db_comment='The subnets for the load balancer.', null=True)),
                ('security_groups', models.JSONField(blank=True, db_comment='The IDs of the security groups for the load balancer.', null=True)),
                ('load_balancer_attributes', models.JSONField(blank=True, db_comment='The AWS account ID of the image owner.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the load balancer.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_application_load_balancer',
                'db_table_comment': 'AWS EC2 Application Load Balancer',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2ApplicationLoadBalancerMetricRequestCount',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The friendly name of the Load Balancer that was provided during resource creation.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_application_load_balancer_metric_request_count',
                'db_table_comment': 'AWS EC2 Application Load Balancer Metrics - Request Count',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2ApplicationLoadBalancerMetricRequestCountDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The friendly name of the Load Balancer that was provided during resource creation.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_application_load_balancer_metric_request_count_daily',
                'db_table_comment': 'AWS EC2 Application Load Balancer Metrics - Request Count (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2AutoscalingGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the Auto Scaling group.', null=True)),
                ('autoscaling_group_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the Auto Scaling group.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current state of the group when the DeleteAutoScalingGroup operation is in progress.', null=True)),
                ('created_time', models.DateTimeField(blank=True, db_comment='The date and time group was created.', null=True)),
                ('new_instances_protected_from_scale_in', models.BooleanField(blank=True, db_comment='Indicates whether newly launched instances are protected from termination by Amazon EC2 Auto Scaling when scaling in.', null=True)),
                ('launch_configuration_name', models.TextField(blank=True, db_comment='The name of the associated launch configuration.', null=True)),
                ('default_cooldown', models.BigIntegerField(blank=True, db_comment='The duration of the default cooldown period, in seconds.', null=True)),
                ('desired_capacity', models.BigIntegerField(blank=True, db_comment='The desired size of the group.', null=True)),
                ('max_instance_lifetime', models.BigIntegerField(blank=True, db_comment='The maximum amount of time, in seconds, that an instance can be in service.', null=True)),
                ('max_size', models.BigIntegerField(blank=True, db_comment='The maximum size of the group.', null=True)),
                ('min_size', models.BigIntegerField(blank=True, db_comment='The minimum size of the group.', null=True)),
                ('health_check_grace_period', models.BigIntegerField(blank=True, db_comment='The amount of time, in seconds, that Amazon EC2 Auto Scaling waits before checking the health status of an EC2 instance that has come into service.', null=True)),
                ('health_check_type', models.TextField(blank=True, db_comment='The service to use for the health checks. The valid values are EC2 and ELB. If you configure an Auto Scaling group to use ELB health checks, it considers the instance unhealthy if it fails either the EC2 status checks or the load balancer health checks.', null=True)),
                ('placement_group', models.TextField(blank=True, db_comment='The name of the placement group into which to launch your instances, if any.', null=True)),
                ('service_linked_role_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the service-linked role that the Auto Scaling group uses to call other AWS services on your behalf.', null=True)),
                ('vpc_zone_identifier', models.TextField(blank=True, db_comment='One or more subnet IDs, if applicable, separated by commas.', null=True)),
                ('launch_template_name', models.TextField(blank=True, db_comment='The launch template name for the group.', null=True)),
                ('launch_template_id', models.TextField(blank=True, db_comment='The ID of the launch template.', null=True)),
                ('launch_template_version', models.TextField(blank=True, db_comment='The version number, $Latest, or $Default.', null=True)),
                ('on_demand_allocation_strategy', models.TextField(blank=True, db_comment='Indicates how to allocate instance types to fulfill On-Demand capacity. The only valid value is prioritized, which is also the default value. This strategy uses the order of instance types in the overrides to define the launch priority of each instance type.', null=True)),
                ('on_demand_base_capacity', models.BigIntegerField(blank=True, db_comment="The minimum amount of the Auto Scaling group's capacity that must be fulfilled by On-Demand Instances. This base portion is provisioned first as group scales. Defaults to 0 if not specified.", null=True)),
                ('on_demand_percentage_above_base_capacity', models.BigIntegerField(blank=True, db_comment='Controls the percentages of On-Demand Instances and Spot Instances for your additional capacity beyond OnDemandBaseCapacity. Expressed as a number (for example, 20 specifies 20% On-Demand Instances, 80% Spot Instances). Defaults to 100 if not specified. If set to 100, only On-Demand Instances are provisioned.', null=True)),
                ('spot_allocation_strategy', models.TextField(blank=True, db_comment='Indicates how to allocate instances across Spot Instance pools. If the allocation strategy is lowest-price, the Auto Scaling group launches instances using the Spot pools with the lowest price, and evenly allocates your instances across the number of Spot pools that you specify. If the allocation strategy is capacity-optimized, the Auto Scaling group launches instances using Spot pools that are optimally chosen based on the available Spot capacity. Defaults to lowest-price if not specified.', null=True)),
                ('spot_instance_pools', models.BigIntegerField(blank=True, db_comment='The number of Spot Instance pools across which to allocate your Spot Instances.', null=True)),
                ('spot_max_price', models.TextField(blank=True, db_comment='The maximum price per unit hour that user is willing to pay for a Spot Instance. If the value of this parameter is blank (which is the default), the maximum Spot price is set at the On-Demand price.', null=True)),
                ('mixed_instances_policy_launch_template_name', models.TextField(blank=True, db_comment='The ID of the launch template for mixed instances policy.', null=True)),
                ('mixed_instances_policy_launch_template_id', models.TextField(blank=True, db_comment='The name of the launch template for mixed instances policy.', null=True)),
                ('mixed_instances_policy_launch_template_version', models.TextField(blank=True, db_comment='The version of the launch template for mixed instances policy.', null=True)),
                ('mixed_instances_policy_launch_template_overrides', models.JSONField(blank=True, db_comment='Any parameters that is specified in the list override the same parameters in the launch template.', null=True)),
                ('availability_zones', models.JSONField(blank=True, db_comment='One or more Availability Zones for the group.', null=True)),
                ('load_balancer_names', models.JSONField(blank=True, db_comment='One or more load balancers associated with the group.', null=True)),
                ('target_group_arns', models.JSONField(blank=True, db_comment='The Amazon Resource Names (ARN) of the target groups for your load balancer.', null=True)),
                ('instances', models.JSONField(blank=True, db_comment='The EC2 instances associated with the group.', null=True)),
                ('enabled_metrics', models.JSONField(blank=True, db_comment='The metrics enabled for the group.', null=True)),
                ('policies', models.JSONField(blank=True, db_comment='A set of scaling policies for the specified Auto Scaling group.', null=True)),
                ('termination_policies', models.JSONField(blank=True, db_comment='The termination policies for the group.', null=True)),
                ('suspended_processes', models.JSONField(blank=True, db_comment='The suspended processes associated with the group.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the Auto Scaling Group.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_autoscaling_group',
                'db_table_comment': 'AWS EC2 Autoscaling Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2CapacityReservation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('capacity_reservation_id', models.TextField(blank=True, db_comment='The ID of the capacity reservation.', null=True)),
                ('capacity_reservation_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the capacity reservation.', null=True)),
                ('instance_type', models.TextField(blank=True, db_comment='The type of instance for which the capacity reservation reserves capacity.', null=True)),
                ('state', models.TextField(blank=True, db_comment="The current state of the capacity reservation. A capacity reservation can be in one of the following states: 'active', 'expired', 'cancelled', 'pending', 'failed'.", null=True)),
                ('availability_zone', models.TextField(blank=True, db_comment='The availability zone in which the capacity is reserved.', null=True)),
                ('availability_zone_id', models.TextField(blank=True, db_comment='The availability zone ID of the capacity reservation.', null=True)),
                ('available_instance_count', models.BigIntegerField(blank=True, db_comment='The remaining capacity. Indicates the number of instances that can be launched in the capacity reservation.', null=True)),
                ('create_date', models.DateTimeField(blank=True, db_comment='The date and time at which the capacity reservation was created.', null=True)),
                ('ebs_optimized', models.BooleanField(blank=True, db_comment='Indicates whether the capacity reservation supports EBS-optimized instances.', null=True)),
                ('end_date', models.DateTimeField(blank=True, db_comment='The date and time at which the capacity reservation expires.', null=True)),
                ('end_date_type', models.TextField(blank=True, db_comment="Indicates the way in which the capacity reservation ends. A capacity reservation can have one of the following end types: 'unlimited', 'limited'.", null=True)),
                ('ephemeral_storage', models.BooleanField(blank=True, db_comment='Indicates whether the capacity reservation supports instances with temporary, block-level storage.', null=True)),
                ('instance_match_criteria', models.TextField(blank=True, db_comment="Indicates the type of instance launches that the capacity reservation accepts. The options include: 'open', 'targeted'.", null=True)),
                ('instance_platform', models.TextField(blank=True, db_comment='The type of operating system for which the capacity reservation reserves capacity.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='The ID of the AWS account that owns the capacity reservation.', null=True)),
                ('start_date', models.DateTimeField(blank=True, db_comment='The date and time at which the capacity reservation was started.', null=True)),
                ('tenancy', models.TextField(blank=True, db_comment="Indicates the tenancy of the capacity reservation. A capacity reservation can have one of the following tenancy settings: 'default', 'dedicated'.", null=True)),
                ('total_instance_count', models.BigIntegerField(blank=True, db_comment='The total number of instances for which the capacity reservation reserves capacity.', null=True)),
                ('capacity_allocations', models.JSONField(blank=True, db_comment='Information about instance capacity usage.', null=True)),
                ('tag_src', models.JSONField(blank=True, db_comment='Any tags assigned to the capacity reservation.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_capacity_reservation',
                'db_table_comment': 'AWS EC2 Capacity Reservation',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2ClassicLoadBalancer',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The friendly name of the Load Balancer.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the classic load balancer.', null=True)),
                ('scheme', models.TextField(blank=True, db_comment='The load balancing scheme of load balancer.', null=True)),
                ('created_time', models.DateTimeField(blank=True, db_comment='The date and time the load balancer was created.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The ID of the VPC for the load balancer.', null=True)),
                ('access_log_emit_interval', models.BigIntegerField(blank=True, db_comment='The interval for publishing the access logs.', null=True)),
                ('access_log_enabled', models.BooleanField(blank=True, db_comment='Specifies whether access logs are enabled for the load balancer.', null=True)),
                ('access_log_s3_bucket_name', models.TextField(blank=True, db_comment='The name of the Amazon S3 bucket where the access logs are stored.', null=True)),
                ('access_log_s3_bucket_prefix', models.TextField(blank=True, db_comment='The logical hierarchy you created for your Amazon S3 bucket.', null=True)),
                ('canonical_hosted_zone_name', models.TextField(blank=True, db_comment='The name of the Amazon Route 53 hosted zone for the load balancer.', null=True)),
                ('canonical_hosted_zone_name_id', models.TextField(blank=True, db_comment='The ID of the Amazon Route 53 hosted zone for the load balancer.', null=True)),
                ('connection_draining_enabled', models.BooleanField(blank=True, db_comment='Specifies whether connection draining is enabled for the load balancer.', null=True)),
                ('connection_draining_timeout', models.BigIntegerField(blank=True, db_comment='The maximum time, in seconds, to keep the existing connections open before deregistering the instances.', null=True)),
                ('connection_settings_idle_timeout', models.BigIntegerField(blank=True, db_comment='The time, in seconds, that the connection is allowed to be idle (no data has been sent over the connection) before it is closed by the load balancer.', null=True)),
                ('cross_zone_load_balancing_enabled', models.BooleanField(blank=True, db_comment='Specifies whether cross-zone load balancing is enabled for the load balancer.', null=True)),
                ('dns_name', models.TextField(blank=True, db_comment='The DNS name of the load balancer.', null=True)),
                ('health_check_interval', models.BigIntegerField(blank=True, db_comment='The approximate interval, in seconds, between health checks of an individual instance.', null=True)),
                ('health_check_timeout', models.BigIntegerField(blank=True, db_comment='The amount of time, in seconds, during which no response means a failed health check.', null=True)),
                ('healthy_threshold', models.BigIntegerField(blank=True, db_comment='The number of consecutive health checks successes required before moving the instance to the Healthy state.', null=True)),
                ('health_check_target', models.TextField(blank=True, db_comment='The instance being checked. The protocol is either TCP, HTTP, HTTPS, or SSL. The range of valid ports is one (1) through 65535.', null=True)),
                ('source_security_group_name', models.TextField(blank=True, db_comment='The name of the security group.', null=True)),
                ('source_security_group_owner_alias', models.TextField(blank=True, db_comment='The owner of the security group.', null=True)),
                ('unhealthy_threshold', models.BigIntegerField(blank=True, db_comment='The number of consecutive health check failures required before moving the instance to the Unhealthy state.', null=True)),
                ('additional_attributes', models.JSONField(blank=True, db_comment='A list of additional attributes.', null=True)),
                ('app_cookie_stickiness_policies', models.JSONField(blank=True, db_comment='A list of the stickiness policies created using CreateAppCookieStickinessPolicy.', null=True)),
                ('availability_zones', models.JSONField(blank=True, db_comment='A list of the Availability Zones for the load balancer.', null=True)),
                ('backend_server_descriptions', models.JSONField(blank=True, db_comment='A list of information about your EC2 instances.', null=True)),
                ('instances', models.JSONField(blank=True, db_comment='A list of the IDs of the instances for the load balancer.', null=True)),
                ('lb_cookie_stickiness_policies', models.JSONField(blank=True, db_comment='A list of the stickiness policies created using CreateLBCookieStickinessPolicy.', null=True)),
                ('listener_descriptions', models.JSONField(blank=True, db_comment='A list of the listeners for the load balancer', null=True)),
                ('other_policies', models.JSONField(blank=True, db_comment='A list of policies other than the stickiness policies.', null=True)),
                ('security_groups', models.JSONField(blank=True, db_comment='A list of the security groups for the load balancer.', null=True)),
                ('subnets', models.JSONField(blank=True, db_comment='A list of the IDs of the subnets for the load balancer.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the load balancer.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_classic_load_balancer',
                'db_table_comment': 'AWS EC2 Classic Load Balancer',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2ClientVpnEndpoint',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('client_vpn_endpoint_id', models.TextField(blank=True, db_comment='The ID of the client VPN endpoint.', null=True)),
                ('transport_protocol', models.TextField(blank=True, db_comment='The transport protocol.', null=True)),
                ('client_cidr_block', models.TextField(blank=True, db_comment='The IPv4 address range, in CIDR notation, from which client IP addresses are assigned.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The date and time when the Client VPN endpoint was created.', null=True)),
                ('deletion_time', models.DateTimeField(blank=True, db_comment='The date and time when the Client VPN endpoint was deleted.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A brief description of the endpoint.', null=True)),
                ('dns_name', models.TextField(blank=True, db_comment='The DNS name to be used by clients when connecting to the Client VPN endpoint.', null=True)),
                ('self_service_portal_url', models.TextField(blank=True, db_comment='The URL of the self-service portal.', null=True)),
                ('server_certificate_arn', models.TextField(blank=True, db_comment='The ARN of the server certificate.', null=True)),
                ('session_timeout_hours', models.BigIntegerField(blank=True, db_comment='The maximum VPN session duration time in hours. Valid values: 8, 10, 12, 24. Defaults to 24.', null=True)),
                ('split_tunnel', models.BooleanField(blank=True, db_comment='Indicates whether split-tunnel is enabled in the Client VPN endpoint.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The ID of the VPC.', null=True)),
                ('vpn_port', models.BigIntegerField(blank=True, db_comment='The port number for the Client VPN endpoint.', null=True)),
                ('authentication_options', models.JSONField(blank=True, db_comment='Information about the authentication method used by the Client VPN endpoint.', null=True)),
                ('client_connect_options', models.JSONField(blank=True, db_comment='The options for managing connection authorization for new client connections.', null=True)),
                ('connection_log_options', models.JSONField(blank=True, db_comment='Information about the client connection logging options for the Client VPN endpoint.', null=True)),
                ('client_login_banner_options', models.JSONField(blank=True, db_comment='Options for enabling a customizable text banner that will be displayed on Amazon Web Services provided clients when a VPN session is established.', null=True)),
                ('dns_servers', models.JSONField(blank=True, db_comment='Information about the DNS servers to be used for DNS resolution.', null=True)),
                ('security_group_ids', models.JSONField(blank=True, db_comment='The IDs of the security groups for the target network.', null=True)),
                ('status', models.JSONField(blank=True, db_comment='The current state of the Client VPN endpoint.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='Any tags assigned to the Client VPN endpoint.', null=True)),
                ('vpn_protocol', models.JSONField(blank=True, db_comment='The protocol used by the VPN session.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_client_vpn_endpoint',
                'db_table_comment': 'AWS EC2 Client VPN Endpoint',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2GatewayLoadBalancer',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the load balancer.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the load balancer.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of load balancer.', null=True)),
                ('state_code', models.TextField(blank=True, db_comment='The state of the load balancer.', null=True)),
                ('scheme', models.TextField(blank=True, db_comment='The load balancing scheme of gateway load balancer.', null=True)),
                ('dns_name', models.TextField(blank=True, db_comment='The public DNS name of the gateway load balancer.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The ID of the VPC for the gateway load balancer.', null=True)),
                ('created_time', models.DateTimeField(blank=True, db_comment='The date and time the load balancer was created.', null=True)),
                ('ip_address_type', models.TextField(blank=True, db_comment='The type of IP addresses used by the subnets for your load balancer.', null=True)),
                ('availability_zones', models.JSONField(blank=True, db_comment='The subnets for the gateway load balancer.', null=True)),
                ('canonical_hosted_zone_id', models.TextField(blank=True, db_comment='The ID of the Amazon Route 53 hosted zone associated with the gateway load balancer.', null=True)),
                ('customer_owned_ipv4_pool', models.TextField(blank=True, db_comment='The ID of the customer-owned address pool.', null=True)),
                ('security_groups', models.JSONField(blank=True, db_comment='The IDs of the security groups for the gateway load balancer.', null=True)),
                ('load_balancer_attributes', models.JSONField(blank=True, db_comment='Attributes deletion protection and cross_zone of gateway load balancer.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the load balancer.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_gateway_load_balancer',
                'db_table_comment': 'AWS EC2 Gateway Load Balancer',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2Instance',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('instance_id', models.TextField(blank=True, db_comment='The ID of the instance.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the instance.', null=True)),
                ('instance_type', models.TextField(blank=True, db_comment='The instance type.', null=True)),
                ('instance_state', models.TextField(blank=True, db_comment='The state of the instance (pending | running | shutting-down | terminated | stopping | stopped).', null=True)),
                ('monitoring_state', models.TextField(blank=True, db_comment='Indicates whether detailed monitoring is enabled (disabled | enabled).', null=True)),
                ('disable_api_termination', models.BooleanField(blank=True, db_comment="If the value is true, instance can't be terminated through the Amazon EC2 console, CLI, or API.", null=True)),
                ('ami_launch_index', models.BigIntegerField(blank=True, db_comment='The AMI launch index, which can be used to find this instance in the launch group.', null=True)),
                ('architecture', models.TextField(blank=True, db_comment='The architecture of the image.', null=True)),
                ('boot_mode', models.TextField(blank=True, db_comment='The boot mode of the instance.', null=True)),
                ('capacity_reservation_id', models.TextField(blank=True, db_comment='The ID of the Capacity Reservation.', null=True)),
                ('capacity_reservation_specification', models.JSONField(blank=True, db_comment='Information about the Capacity Reservation targeting option.', null=True)),
                ('client_token', models.TextField(blank=True, db_comment='The idempotency token you provided when you launched the instance, if applicable.', null=True)),
                ('cpu_options_core_count', models.BigIntegerField(blank=True, db_comment='The number of CPU cores for the instance.', null=True)),
                ('cpu_options_threads_per_core', models.BigIntegerField(blank=True, db_comment='The number of threads per CPU core.', null=True)),
                ('ebs_optimized', models.BooleanField(blank=True, db_comment="Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types.", null=True)),
                ('ena_support', models.BooleanField(blank=True, db_comment='Specifies whether enhanced networking with ENA is enabled.', null=True)),
                ('hypervisor', models.TextField(blank=True, db_comment='The hypervisor type of the instance. The value xen is used for both Xen and Nitro hypervisors.', null=True)),
                ('iam_instance_profile_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of IAM instance profile associated with the instance, if applicable.', null=True)),
                ('iam_instance_profile_id', models.TextField(blank=True, db_comment='The ID of the instance profile associated with the instance, if applicable.', null=True)),
                ('image_id', models.TextField(blank=True, db_comment='The ID of the AMI used to launch the instance.', null=True)),
                ('instance_initiated_shutdown_behavior', models.TextField(blank=True, db_comment='Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).', null=True)),
                ('instance_lifecycle', models.TextField(blank=True, db_comment='Indicates whether this is a spot instance or a scheduled instance.', null=True)),
                ('kernel_id', models.TextField(blank=True, db_comment='The kernel ID', null=True)),
                ('key_name', models.TextField(blank=True, db_comment='The name of the key pair, if this instance was launched with an associated key pair.', null=True)),
                ('launch_time', models.DateTimeField(blank=True, db_comment='The time the instance was launched.', null=True)),
                ('outpost_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the Outpost, if applicable.', null=True)),
                ('placement_affinity', models.TextField(blank=True, db_comment='The affinity setting for the instance on the Dedicated Host.', null=True)),
                ('placement_availability_zone', models.TextField(blank=True, db_comment='The Availability Zone of the instance.', null=True)),
                ('placement_group_id', models.TextField(blank=True, db_comment='The ID of the placement group that the instance is in.', null=True)),
                ('placement_group_name', models.TextField(blank=True, db_comment='The name of the placement group the instance is in.', null=True)),
                ('placement_host_id', models.TextField(blank=True, db_comment='The ID of the Dedicated Host on which the instance resides.', null=True)),
                ('placement_host_resource_group_arn', models.TextField(blank=True, db_comment='The ARN of the host resource group in which to launch the instances.', null=True)),
                ('placement_partition_number', models.BigIntegerField(blank=True, db_comment='The ARN of the host resource group in which to launch the instances.', null=True)),
                ('placement_tenancy', models.TextField(blank=True, db_comment='The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware.', null=True)),
                ('platform', models.TextField(blank=True, db_comment="The value is 'Windows' for Windows instances; otherwise blank.", null=True)),
                ('platform_details', models.TextField(blank=True, db_comment='The platform details value for the instance.', null=True)),
                ('private_ip_address', models.GenericIPAddressField(blank=True, db_comment='The private IPv4 address assigned to the instance.', null=True)),
                ('private_dns_name', models.TextField(blank=True, db_comment='The private DNS hostname name assigned to the instance. This DNS hostname can only be used inside the Amazon EC2 network. This name is not available until the instance enters the running state.', null=True)),
                ('public_dns_name', models.TextField(blank=True, db_comment='The public DNS name assigned to the instance. This name is not available until the instance enters the running state.', null=True)),
                ('public_ip_address', models.GenericIPAddressField(blank=True, db_comment='The public IPv4 address, or the Carrier IP address assigned to the instance, if applicable.', null=True)),
                ('ram_disk_id', models.TextField(blank=True, db_comment='The RAM disk ID.', null=True)),
                ('root_device_name', models.TextField(blank=True, db_comment='The device name of the root device volume (for example, /dev/sda1).', null=True)),
                ('root_device_type', models.TextField(blank=True, db_comment='The root device type used by the AMI. The AMI can use an EBS volume or an instance store volume.', null=True)),
                ('source_dest_check', models.BooleanField(blank=True, db_comment='Specifies whether to enable an instance launched in a VPC to perform NAT. This controls whether source/destination checking is enabled on the instance.', null=True)),
                ('spot_instance_request_id', models.TextField(blank=True, db_comment='If the request is a Spot Instance request, the ID of the request.', null=True)),
                ('sriov_net_support', models.TextField(blank=True, db_comment='Indicates whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.', null=True)),
                ('state_code', models.BigIntegerField(blank=True, db_comment='The reason code for the state change.', null=True)),
                ('state_transition_reason', models.TextField(blank=True, db_comment='The reason for the most recent state transition.', null=True)),
                ('state_transition_time', models.DateTimeField(blank=True, db_comment='The date and time, the instance state was last modified.', null=True)),
                ('subnet_id', models.TextField(blank=True, db_comment='The ID of the subnet in which the instance is running.', null=True)),
                ('tpm_support', models.TextField(blank=True, db_comment='If the instance is configured for NitroTPM support, the value is v2.0.', null=True)),
                ('usage_operation', models.TextField(blank=True, db_comment='The usage operation value for the instance.', null=True)),
                ('usage_operation_update_time', models.TextField(blank=True, db_comment='The time that the usage operation was last updated.', null=True)),
                ('user_data', models.TextField(blank=True, db_comment='The user data of the instance.', null=True)),
                ('virtualization_type', models.TextField(blank=True, db_comment='The virtualization type of the instance.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The ID of the VPC in which the instance is running.', null=True)),
                ('block_device_mappings', models.JSONField(blank=True, db_comment='Block device mapping entries for the instance.', null=True)),
                ('elastic_gpu_associations', models.JSONField(blank=True, db_comment='The Elastic GPU associated with the instance.', null=True)),
                ('elastic_inference_accelerator_associations', models.JSONField(blank=True, db_comment='The elastic inference accelerator associated with the instance.', null=True)),
                ('enclave_options', models.JSONField(blank=True, db_comment='Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves.', null=True)),
                ('hibernation_options', models.JSONField(blank=True, db_comment='Indicates whether the instance is enabled for hibernation.', null=True)),
                ('launch_template_data', models.JSONField(blank=True, db_comment='The configuration data of the specified instance.', null=True)),
                ('licenses', models.JSONField(blank=True, db_comment='The license configurations for the instance.', null=True)),
                ('maintenance_options', models.JSONField(blank=True, db_comment='The metadata options for the instance.', null=True)),
                ('metadata_options', models.JSONField(blank=True, db_comment='The metadata options for the instance.', null=True)),
                ('network_interfaces', models.JSONField(blank=True, db_comment='The network interfaces for the instance.', null=True)),
                ('private_dns_name_options', models.JSONField(blank=True, db_comment='The options for the instance hostname.', null=True)),
                ('product_codes', models.JSONField(blank=True, db_comment='The product codes attached to this instance, if applicable.', null=True)),
                ('security_groups', models.JSONField(blank=True, db_comment='The security groups for the instance.', null=True)),
                ('instance_status', models.JSONField(blank=True, db_comment='The status of an instance. Instance status includes scheduled events, status checks and instance state information.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the instance.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_instance',
                'db_table_comment': 'AWS EC2 Instance',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2InstanceAvailability',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('instance_type', models.TextField(blank=True, db_comment='The instance type. For more information, see [ Instance Types ](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the Amazon Elastic Compute Cloud User Guide.', null=True)),
                ('location', models.TextField(blank=True, db_comment='The identifier for the location. This depends on the location type. For example, if the location type is region, the location is the Region code (for example, us-east-2.)', null=True)),
                ('location_type', models.TextField(blank=True, db_comment='The type of location.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_instance_availability',
                'db_table_comment': 'AWS EC2 Instance Availability',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2InstanceMetricCpuUtilization',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('instance_id', models.TextField(blank=True, db_comment='The ID of the instance.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_instance_metric_cpu_utilization',
                'db_table_comment': 'AWS EC2 Instance Cloudwatch Metrics - CPU Utilization',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2InstanceMetricCpuUtilizationDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('instance_id', models.TextField(blank=True, db_comment='The ID of the instance.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_instance_metric_cpu_utilization_daily',
                'db_table_comment': 'AWS EC2 Instance Cloudwatch Metrics - CPU Utilization (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2InstanceMetricCpuUtilizationHourly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('instance_id', models.TextField(blank=True, db_comment='The ID of the instance.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_instance_metric_cpu_utilization_hourly',
                'db_table_comment': 'AWS EC2 Instance Cloudwatch Metrics - CPU Utilization (Hourly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2InstanceType',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('instance_type', models.TextField(blank=True, db_comment='The instance type. For more information, see [ Instance Types ](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the Amazon Elastic Compute Cloud User Guide.', null=True)),
                ('auto_recovery_supported', models.BooleanField(blank=True, db_comment='Indicates whether auto recovery is supported.', null=True)),
                ('bare_metal', models.BooleanField(blank=True, db_comment='Indicates whether the instance is a bare metal instance type.', null=True)),
                ('burstable_performance_supported', models.BooleanField(blank=True, db_comment='Indicates whether the instance type is a burstable performance instance type.', null=True)),
                ('current_generation', models.BooleanField(blank=True, db_comment='Indicates whether the instance type is current generation.', null=True)),
                ('dedicated_hosts_supported', models.BooleanField(blank=True, db_comment='Indicates whether Dedicated Hosts are supported on the instance type.', null=True)),
                ('free_tier_eligible', models.BooleanField(blank=True, db_comment='Indicates whether the instance type is eligible for the free tier.', null=True)),
                ('hibernation_supported', models.BooleanField(blank=True, db_comment='Indicates whether On-Demand hibernation is supported.', null=True)),
                ('hypervisor', models.TextField(blank=True, db_comment='The hypervisor for the instance type.', null=True)),
                ('instance_storage_supported', models.TextField(blank=True, db_comment='Describes the instance storage for the instance type.', null=True)),
                ('ebs_info', models.JSONField(blank=True, db_comment='Describes the Amazon EBS settings for the instance type.', null=True)),
                ('memory_info', models.JSONField(blank=True, db_comment='Describes the memory for the instance type.', null=True)),
                ('network_info', models.JSONField(blank=True, db_comment='Describes the network settings for the instance type.', null=True)),
                ('placement_group_info', models.JSONField(blank=True, db_comment='Describes the placement group settings for the instance type.', null=True)),
                ('processor_info', models.JSONField(blank=True, db_comment='Describes the processor.', null=True)),
                ('supported_root_device_types', models.JSONField(blank=True, db_comment='The supported root device types.', null=True)),
                ('supported_usage_classes', models.JSONField(blank=True, db_comment='Indicates whether the instance type is offered for spot or On-Demand.', null=True)),
                ('supported_virtualization_types', models.JSONField(blank=True, db_comment='The supported virtualization types.', null=True)),
                ('v_cpu_info', models.JSONField(blank=True, db_comment='Describes the vCPU configurations for the instance type.', null=True)),
                ('gpu_info', models.JSONField(blank=True, db_comment='Describes the GPU accelerator settings for the instance type.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_instance_type',
                'db_table_comment': 'AWS EC2 Instance Type',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2KeyPair',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('key_name', models.TextField(blank=True, db_comment='The name of the key pair', null=True)),
                ('key_pair_id', models.TextField(blank=True, db_comment='The ID of the key pair', null=True)),
                ('key_fingerprint', models.TextField(blank=True, db_comment='If key pair was created using CreateKeyPair, this is the SHA-1 digest of the DER encoded private key. If key pair was created using ImportKeyPair to provide AWS the public key, this is the MD5 public key fingerprint as specified in section 4 of RFC4716', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the key pair', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('create_time', models.DateTimeField(blank=True, db_comment='The time that the keypair was created or imported', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_key_pair',
                'db_table_comment': 'AWS EC2 Key Pair',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2LaunchConfiguration',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the launch configuration.', null=True)),
                ('launch_configuration_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the launch configuration.', null=True)),
                ('created_time', models.DateTimeField(blank=True, db_comment='The creation date and time for the launch configuration.', null=True)),
                ('image_id', models.TextField(blank=True, db_comment='The ID of the Amazon Machine Image (AMI) to use to launch EC2 instances.', null=True)),
                ('instance_type', models.TextField(blank=True, db_comment='The instance type for the instances.', null=True)),
                ('associate_public_ip_address', models.BooleanField(blank=True, db_comment="For Auto Scaling groups that are running in a VPC, specifies whether to assign a public IP address to the group's instances.", null=True)),
                ('kernel_id', models.TextField(blank=True, db_comment='The ID of the kernel associated with the AMI.', null=True)),
                ('key_name', models.TextField(blank=True, db_comment='The name of the key pair to be associated with instances.', null=True)),
                ('ramdisk_id', models.TextField(blank=True, db_comment='The ID of the RAM disk associated with the AMI.', null=True)),
                ('ebs_optimized', models.BooleanField(blank=True, db_comment='Specifies whether the launch configuration is optimized for EBS I/O (true) or not (false).', null=True)),
                ('classic_link_vpc_id', models.TextField(blank=True, db_comment='The ID of a ClassicLink-enabled VPC to link EC2-Classic instances to.', null=True)),
                ('spot_price', models.TextField(blank=True, db_comment='The maximum hourly price to be paid for any Spot Instance launched to fulfill the request. Spot Instances are launched when the price you specified exceeds the current Spot price.', null=True)),
                ('user_data', models.TextField(blank=True, db_comment='The Base64-encoded user data to make available to the launched EC2 instances.', null=True)),
                ('placement_tenancy', models.TextField(blank=True, db_comment='The tenancy of the instance, either default or dedicated. An instance with dedicated tenancy runs on isolated, single-tenant hardware and can only be launched into a VPC.', null=True)),
                ('iam_instance_profile', models.TextField(blank=True, db_comment='The name or the Amazon Resource Name (ARN) of the instance profile associated with the IAM role for the instance.', null=True)),
                ('instance_monitoring_enabled', models.BooleanField(blank=True, db_comment='Describes whether detailed monitoring is enabled for the Auto Scaling instances.', null=True)),
                ('metadata_options_http_endpoint', models.TextField(blank=True, db_comment='This parameter enables or disables the HTTP metadata endpoint on instances. If the parameter is not specified, the default state is enabled.', null=True)),
                ('metadata_options_put_response_hop_limit', models.BigIntegerField(blank=True, db_comment='The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.', null=True)),
                ('metadata_options_http_tokens', models.TextField(blank=True, db_comment='The state of token usage for your instance metadata requests. If the parameter is not specified in the request, the default state is optional.', null=True)),
                ('block_device_mappings', models.JSONField(blank=True, db_comment='A block device mapping, which specifies the block devices for the instance.', null=True)),
                ('classic_link_vpc_security_groups', models.JSONField(blank=True, db_comment='The IDs of one or more security groups for the VPC specified in ClassicLinkVPCId.', null=True)),
                ('security_groups', models.JSONField(blank=True, db_comment='A list that contains the security groups to assign to the instances in the Auto Scaling group.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_launch_configuration',
                'db_table_comment': 'AWS EC2 Launch Configuration',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2LaunchTemplate',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('launch_template_name', models.TextField(blank=True, db_comment='The name of the launch template.', null=True)),
                ('launch_template_id', models.TextField(blank=True, db_comment='The ID of the launch template.', null=True)),
                ('create_time', models.DateTimeField(blank=True, db_comment='The time launch template was created.', null=True)),
                ('created_by', models.TextField(blank=True, db_comment='The principal that created the launch template.', null=True)),
                ('default_version_number', models.BigIntegerField(blank=True, db_comment='The version number of the default version of the launch template.', null=True)),
                ('latest_version_number', models.BigIntegerField(blank=True, db_comment='The name of the Application-Layer Protocol Negotiation (ALPN) policy.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The tags for the launch template.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_launch_template',
                'db_table_comment': 'AWS EC2 Launch Template',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2LaunchTemplateVersion',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('launch_template_name', models.TextField(blank=True, db_comment='The name of the launch template.', null=True)),
                ('launch_template_id', models.TextField(blank=True, db_comment='The ID of the launch template.', null=True)),
                ('create_time', models.DateTimeField(blank=True, db_comment='The time the version was created.', null=True)),
                ('created_by', models.TextField(blank=True, db_comment='The principal that created the version.', null=True)),
                ('default_version', models.BooleanField(blank=True, db_comment='Indicates whether the version is the default version.', null=True)),
                ('disable_api_stop', models.BooleanField(blank=True, db_comment='Indicates whether the instance is enabled for stop protection.', null=True)),
                ('disable_api_termination', models.BooleanField(blank=True, db_comment='If set to true, indicates that the instance cannot be terminated using the Amazon EC2 console, command line tool, or API.', null=True)),
                ('ebs_optimized', models.BooleanField(blank=True, db_comment='Indicates whether the instance is optimized for Amazon EBS I/O.', null=True)),
                ('image_id', models.TextField(blank=True, db_comment='The ID of the AMI or a Systems Manager parameter.', null=True)),
                ('instance_type', models.TextField(blank=True, db_comment='The instance type.', null=True)),
                ('kernel_id', models.TextField(blank=True, db_comment='The ID of the kernel, if applicable.', null=True)),
                ('key_name', models.TextField(blank=True, db_comment='The name of the key pair.', null=True)),
                ('ram_disk_id', models.TextField(blank=True, db_comment='The ID of the RAM disk, if applicable.', null=True)),
                ('security_groups', models.TextField(blank=True, db_comment='The security group names.', null=True)),
                ('security_group_ids', models.TextField(blank=True, db_comment='The security group IDs.', null=True)),
                ('version_description', models.TextField(blank=True, db_comment='The description for the version.', null=True)),
                ('version_number', models.BigIntegerField(blank=True, db_comment='The version number.', null=True)),
                ('user_data', models.TextField(blank=True, db_comment='The user data of the launch template.', null=True)),
                ('launch_template_data', models.JSONField(blank=True, db_comment='Information about the launch template.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_launch_template_version',
                'db_table_comment': 'AWS EC2 Launch Template Version',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2LoadBalancerListener',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the listener.', null=True)),
                ('load_balancer_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the load balancer.', null=True)),
                ('port', models.BigIntegerField(blank=True, db_comment='The port on which the load balancer is listening.', null=True)),
                ('protocol', models.TextField(blank=True, db_comment='The protocol for connections from clients to the load balancer.', null=True)),
                ('ssl_policy', models.TextField(blank=True, db_comment='The security policy that defines which protocols and ciphers are supported.', null=True)),
                ('alpn_policy', models.JSONField(blank=True, db_comment='The name of the Application-Layer Protocol Negotiation (ALPN) policy.', null=True)),
                ('certificates', models.JSONField(blank=True, db_comment='The default certificate for the listener.', null=True)),
                ('default_actions', models.JSONField(blank=True, db_comment='The default actions for the listener.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_load_balancer_listener',
                'db_table_comment': 'AWS EC2 Load Balancer Listener',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2ManagedPrefixList',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the prefix list.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The ID of the prefix list.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the prefix list.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The current state of the prefix list.', null=True)),
                ('address_family', models.TextField(blank=True, db_comment='The IP address version of the prefix list.', null=True)),
                ('max_entries', models.BigIntegerField(blank=True, db_comment='The maximum number of entries for the prefix list.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='The ID of the owner of the prefix list.', null=True)),
                ('state_message', models.TextField(blank=True, db_comment='The message regarding the current state of the prefix list.', null=True)),
                ('version', models.BigIntegerField(blank=True, db_comment='The version of the prefix list.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The tags for the prefix list.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_managed_prefix_list',
                'db_table_comment': 'AWS EC2 Managed Prefix List',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2ManagedPrefixListEntry',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('prefix_list_id', models.TextField(blank=True, db_comment='The ID of the prefix list.', null=True)),
                ('cidr', models.TextField(blank=True, db_comment='The CIDR block.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the entry.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_managed_prefix_list_entry',
                'db_table_comment': 'AWS EC2 Managed Prefix List Entry',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2NetworkInterface',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('network_interface_id', models.TextField(blank=True, db_comment='The ID of the network interface.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the network interface.', null=True)),
                ('interface_type', models.TextField(blank=True, db_comment='The type of network interface.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description.', null=True)),
                ('availability_zone', models.TextField(blank=True, db_comment='The Availability Zone.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='The AWS account ID of the owner of the network interface.', null=True)),
                ('association_allocation_id', models.TextField(blank=True, db_comment='Allocation id for the association. Association can be an Elastic IP address (IPv4 only), or a Carrier IP address.', null=True)),
                ('association_carrier_ip', models.GenericIPAddressField(blank=True, db_comment='The carrier IP address associated with the network interface.', null=True)),
                ('association_customer_owned_ip', models.GenericIPAddressField(blank=True, db_comment='The customer-owned IP address associated with the network interface.', null=True)),
                ('association_id', models.TextField(blank=True, db_comment='The association ID.', null=True)),
                ('association_ip_owner_id', models.TextField(blank=True, db_comment='The ID of the Elastic IP address owner.', null=True)),
                ('association_public_dns_name', models.TextField(blank=True, db_comment='The public DNS name of the association.', null=True)),
                ('association_public_ip', models.GenericIPAddressField(blank=True, db_comment='The address of the Elastic IP address bound to the network interface.', null=True)),
                ('attached_instance_id', models.TextField(blank=True, db_comment='The ID of the attached instance.', null=True)),
                ('attached_instance_owner_id', models.TextField(blank=True, db_comment='The AWS account ID of the owner of the attached instance.', null=True)),
                ('attachment_id', models.TextField(blank=True, db_comment='The ID of the network interface attachment.', null=True)),
                ('attachment_status', models.TextField(blank=True, db_comment='The attachment state.', null=True)),
                ('attachment_time', models.DateTimeField(blank=True, db_comment='The timestamp indicating when the attachment initiated.', null=True)),
                ('delete_on_instance_termination', models.BooleanField(blank=True, db_comment='Indicates whether the network interface is deleted when the instance is terminated.', null=True)),
                ('device_index', models.BigIntegerField(blank=True, db_comment='The device index of the network interface attachment on the instance.', null=True)),
                ('mac_address', models.TextField(blank=True, db_comment='The MAC address of the interface.', null=True)),
                ('outpost_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the Outpost, if applicable.', null=True)),
                ('private_dns_name', models.TextField(blank=True, db_comment='The private DNS name', null=True)),
                ('private_ip_address', models.GenericIPAddressField(blank=True, db_comment='The IPv4 address of the network interface within the subnet.', null=True)),
                ('requester_id', models.TextField(blank=True, db_comment='The ID of the entity that launched the instance on your behalf (for example, AWS Management Console or Auto Scaling).', null=True)),
                ('requester_managed', models.BooleanField(blank=True, db_comment='Indicates whether the network interface is being managed by AWS.', null=True)),
                ('source_dest_check', models.BooleanField(blank=True, db_comment='Indicates whether traffic to or from the instance is validated.', null=True)),
                ('subnet_id', models.TextField(blank=True, db_comment='The ID of the subnet.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The ID of the VPC.', null=True)),
                ('groups', models.JSONField(blank=True, db_comment='Any security groups for the network interface.', null=True)),
                ('ipv6_addresses', models.JSONField(blank=True, db_comment='The IPv6 addresses associated with the network interface.', null=True)),
                ('private_ip_addresses', models.JSONField(blank=True, db_comment='The IPv4 address of the network interface within the subnet.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are attached to the network interface.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_network_interface',
                'db_table_comment': 'AWS EC2 Network Interface',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2NetworkLoadBalancer',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The friendly name of the Load Balancer', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the load balancer', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of load balancer', null=True)),
                ('scheme', models.TextField(blank=True, db_comment='The load balancing scheme of load balancer', null=True)),
                ('canonical_hosted_zone_id', models.TextField(blank=True, db_comment='The ID of the Amazon Route 53 hosted zone associated with the load balancer', null=True)),
                ('created_time', models.DateTimeField(blank=True, db_comment='The date and time the load balancer was created', null=True)),
                ('customer_owned_ipv4_pool', models.TextField(blank=True, db_comment='The ID of the customer-owned address pool', null=True)),
                ('dns_name', models.TextField(blank=True, db_comment='The public DNS name of the load balancer', null=True)),
                ('ip_address_type', models.TextField(blank=True, db_comment='The type of IP addresses used by the subnets for your load balancer', null=True)),
                ('state_code', models.TextField(blank=True, db_comment='Current state of the load balancer', null=True)),
                ('state_reason', models.TextField(blank=True, db_comment='A description of the state', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The ID of the VPC for the load balancer', null=True)),
                ('availability_zones', models.JSONField(blank=True, db_comment='The subnets for the load balancer', null=True)),
                ('security_groups', models.JSONField(blank=True, db_comment='The IDs of the security groups for the load balancer', null=True)),
                ('load_balancer_attributes', models.JSONField(blank=True, db_comment='The AWS account ID of the image owner', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the load balancer', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_network_load_balancer',
                'db_table_comment': 'AWS EC2 Network Load Balancer',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2NetworkLoadBalancerMetricNetFlowCount',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The friendly name of the Load Balancer.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_network_load_balancer_metric_net_flow_count',
                'db_table_comment': 'AWS EC2 Network Load Balancer Metrics - Net Flow Count',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2NetworkLoadBalancerMetricNetFlowCountDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The friendly name of the Load Balancer.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_network_load_balancer_metric_net_flow_count_daily',
                'db_table_comment': 'AWS EC2 Network Load Balancer Metrics - Net Flow Count (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2RegionalSettings',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('default_ebs_encryption_enabled', models.BooleanField(blank=True, db_comment='Indicates whether encryption by default is enabled.', null=True)),
                ('default_ebs_encryption_key', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) or alias of the default CMK for encryption by default.', null=True)),
                ('snapshot_block_public_access_state', models.TextField(blank=True, db_comment='Gets the current state of block public access for snapshots setting for the account and Region.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_regional_settings',
                'db_table_comment': 'AWS EC2 Regional Settings',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2ReservedInstance',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('reserved_instance_id', models.TextField(blank=True, db_comment='The ID of the Reserved instance.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the instance.', null=True)),
                ('instance_type', models.TextField(blank=True, db_comment='The instance type on which the Reserved Instance can be used.', null=True)),
                ('instance_state', models.TextField(blank=True, db_comment='The state of the Reserved Instance purchase.', null=True)),
                ('availability_zone', models.TextField(blank=True, db_comment='The Availability Zone in which the Reserved Instance can be used.', null=True)),
                ('currency_code', models.TextField(blank=True, db_comment="The currency of the Reserved Instance. It's specified using ISO 4217 standard currency codes. At this time, the only supported currency is USD.", null=True)),
                ('duration', models.BigIntegerField(blank=True, db_comment='The duration of the Reserved Instance, in seconds.', null=True)),
                ('end_time', models.DateTimeField(blank=True, db_comment='The time when the Reserved Instance expires.', null=True)),
                ('fixed_price', models.FloatField(blank=True, db_comment='The purchase price of the Reserved Instance.', null=True)),
                ('instance_count', models.BigIntegerField(blank=True, db_comment='The number of reservations purchased.', null=True)),
                ('instance_tenancy', models.TextField(blank=True, db_comment='The tenancy of the instance.', null=True)),
                ('offering_class', models.TextField(blank=True, db_comment='The offering class of the Reserved Instance.', null=True)),
                ('offering_type', models.TextField(blank=True, db_comment='The Reserved Instance offering type.', null=True)),
                ('product_description', models.TextField(blank=True, db_comment='The Reserved Instance product platform description.', null=True)),
                ('scope', models.TextField(blank=True, db_comment='The scope of the Reserved Instance.', null=True)),
                ('start_time', models.DateTimeField(blank=True, db_comment='The date and time the Reserved Instance started.', null=True)),
                ('usage_price', models.FloatField(blank=True, db_comment='The usage price of the Reserved Instance, per hour.', null=True)),
                ('reserved_instances_modifications', models.JSONField(blank=True, db_comment='The Reserved Instance modification information.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the reserved instance.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_reserved_instance',
                'db_table_comment': 'AWS EC2 Reserved Instance',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2SpotPrice',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('availability_zone', models.TextField(blank=True, db_comment='The Availability Zone.', null=True)),
                ('instance_type', models.TextField(blank=True, db_comment='The instance type.', null=True)),
                ('product_description', models.TextField(blank=True, db_comment='A general description of the AMI.', null=True)),
                ('spot_price', models.TextField(blank=True, db_comment='The maximum price per unit hour that you are willing to pay for a Spot Instance.', null=True)),
                ('create_timestamp', models.DateTimeField(blank=True, db_comment='The time stamp of the Spot price history.', null=True)),
                ('start_time', models.DateTimeField(blank=True, db_comment='The date and time, up to the past 90 days, from which to start retrieving the price history data.', null=True)),
                ('end_time', models.DateTimeField(blank=True, db_comment='The date and time, up to the current date, from which to stop retrieving the price history data.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_spot_price',
                'db_table_comment': 'AWS EC2 Spot Price History',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2SslPolicy',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the policy.', null=True)),
                ('ciphers', models.JSONField(blank=True, db_comment='A list of ciphers.', null=True)),
                ('ssl_protocols', models.JSONField(blank=True, db_comment='A list of protocols.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_ssl_policy',
                'db_table_comment': 'AWS EC2 SSL Policy',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2TargetGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('target_group_name', models.TextField(blank=True, db_comment='The name of the target group.', null=True)),
                ('target_group_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the target group.', null=True)),
                ('target_type', models.TextField(blank=True, db_comment='The type of target that is specified when registering targets with this target group. The possible values are instance (register targets by instance ID), ip (register targets by IP address), or lambda (register a single Lambda function as a target).', null=True)),
                ('load_balancer_arns', models.JSONField(blank=True, db_comment='The Amazon Resource Names (ARN) of the load balancers that route traffic to this target group.', null=True)),
                ('port', models.BigIntegerField(blank=True, db_comment='The port on which the targets are listening. Not used if the target is a Lambda function.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The ID of the VPC for the target.', null=True)),
                ('protocol', models.TextField(blank=True, db_comment='The protocol to use for routing traffic to the target.', null=True)),
                ('matcher_http_code', models.TextField(blank=True, db_comment='The HTTP codes to use when checking for a successful response from a target.', null=True)),
                ('matcher_grpc_code', models.TextField(blank=True, db_comment='The gRPC codes to use when checking for a successful response from a target.', null=True)),
                ('healthy_threshold_count', models.BigIntegerField(blank=True, db_comment='The number of consecutive health checks successes required before considering an unhealthy target healthy.', null=True)),
                ('unhealthy_threshold_count', models.BigIntegerField(blank=True, db_comment='The number of consecutive health checks successes required before considering an unhealthy target healthy.', null=True)),
                ('health_check_enabled', models.BooleanField(blank=True, db_comment='Indicates whether health checks are enabled.', null=True)),
                ('health_check_interval_seconds', models.BigIntegerField(blank=True, db_comment='The approximate amount of time, in seconds, between health checks of an individual target.', null=True)),
                ('health_check_path', models.TextField(blank=True, db_comment='The destination for health checks on the target.', null=True)),
                ('health_check_port', models.TextField(blank=True, db_comment='The port to use to connect with the target.', null=True)),
                ('health_check_protocol', models.TextField(blank=True, db_comment='The protocol to use to connect with the target. The GENEVE, TLS, UDP, and TCP_UDP protocols are not supported for health checks.', null=True)),
                ('health_check_timeout_seconds', models.BigIntegerField(blank=True, db_comment='The amount of time, in seconds, during which no response means a failed health check.', null=True)),
                ('target_health_descriptions', models.JSONField(blank=True, db_comment='Contains information about the health of the target.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with target group.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_target_group',
                'db_table_comment': 'AWS EC2 Target Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2TransitGateway',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('transit_gateway_id', models.TextField(blank=True, db_comment='The ID of the transit gateway.', null=True)),
                ('transit_gateway_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the transit gateway.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The state of the transit gateway.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='The ID of the AWS account ID that owns the transit gateway.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the transit gateway.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The date and time when transit gateway was created.', null=True)),
                ('amazon_side_asn', models.BigIntegerField(blank=True, db_comment='A private Autonomous System Number (ASN) for the Amazon side of a BGP session. The range is 64512 to 65534 for 16-bit ASNs and 4200000000 to 4294967294 for 32-bit ASNs.', null=True)),
                ('association_default_route_table_id', models.TextField(blank=True, db_comment='The ID of the default association route table.', null=True)),
                ('auto_accept_shared_attachments', models.TextField(blank=True, db_comment='Indicates whether attachment requests are automatically accepted.', null=True)),
                ('default_route_table_association', models.TextField(blank=True, db_comment='Indicates whether resource attachments are automatically associated with the default association route table.', null=True)),
                ('default_route_table_propagation', models.TextField(blank=True, db_comment='Indicates whether resource attachments are automatically associated with the default association route table.', null=True)),
                ('dns_support', models.TextField(blank=True, db_comment='Indicates whether DNS support is enabled.', null=True)),
                ('multicast_support', models.TextField(blank=True, db_comment='Indicates whether multicast is enabled on the transit gateway.', null=True)),
                ('propagation_default_route_table_id', models.TextField(blank=True, db_comment='The ID of the default propagation route table.', null=True)),
                ('vpn_ecmp_support', models.TextField(blank=True, db_comment='Indicates whether Equal Cost Multipath Protocol support is enabled.', null=True)),
                ('cidr_blocks', models.JSONField(blank=True, db_comment='A list of transit gateway CIDR blocks.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are assigned to the transit gateway.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_transit_gateway',
                'db_table_comment': 'AWS EC2 Transit Gateway',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2TransitGatewayRoute',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('transit_gateway_route_table_id', models.TextField(blank=True, db_comment='The ID of the transit gateway route table.', null=True)),
                ('destination_cidr_block', models.TextField(blank=True, db_comment='The CIDR block used for destination matches.', null=True)),
                ('prefix_list_id', models.TextField(blank=True, db_comment='The ID of the prefix list used for destination matches.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The state of the route.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The route type.', null=True)),
                ('transit_gateway_attachments', models.JSONField(blank=True, db_comment='The attachments.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_transit_gateway_route',
                'db_table_comment': 'AWS EC2 Transit Gateway Route',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2TransitGatewayRouteTable',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('transit_gateway_route_table_id', models.TextField(blank=True, db_comment='The ID of the transit gateway route table.', null=True)),
                ('transit_gateway_id', models.TextField(blank=True, db_comment='The ID of the transit gateway.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The state of the transit gateway route table.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The creation time of transit gateway route table.', null=True)),
                ('default_association_route_table', models.BooleanField(blank=True, db_comment='Indicates whether this is the default association route table for the transit gateway.', null=True)),
                ('default_propagation_route_table', models.BooleanField(blank=True, db_comment='Indicates whether this is the default propagation route table for the transit gateway.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_transit_gateway_route_table',
                'db_table_comment': 'AWS EC2 Transit Gateway Route Table',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEc2TransitGatewayVpcAttachment',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('transit_gateway_attachment_id', models.TextField(blank=True, db_comment='The ID of the transit gateway attachment.', null=True)),
                ('transit_gateway_id', models.TextField(blank=True, db_comment='The ID of the transit gateway.', null=True)),
                ('transit_gateway_owner_id', models.TextField(blank=True, db_comment='The ID of the AWS account that owns the transit gateway.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The attachment state of the transit gateway attachment.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The creation time of the transit gateway attachment.', null=True)),
                ('resource_id', models.TextField(blank=True, db_comment='The ID of the resource.', null=True)),
                ('resource_type', models.TextField(blank=True, db_comment='The resource type of the transit gateway attachment.', null=True)),
                ('resource_owner_id', models.TextField(blank=True, db_comment='The ID of the AWS account that owns the resource.', null=True)),
                ('association_state', models.TextField(blank=True, db_comment='The state of the association.', null=True)),
                ('association_transit_gateway_route_table_id', models.TextField(blank=True, db_comment='The ID of the route table for the transit gateway.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ec2_transit_gateway_vpc_attachment',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEcrImage',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('repository_name', models.TextField(blank=True, db_comment='The name of the repository.', null=True)),
                ('artifact_media_type', models.TextField(blank=True, db_comment='The artifact media type of the image.', null=True)),
                ('image_digest', models.TextField(blank=True, db_comment='The sha256 digest of the image manifest.', null=True)),
                ('image_uri', models.TextField(blank=True, db_comment='The URI for the image.', null=True)),
                ('image_manifest_media_type', models.TextField(blank=True, db_comment='The media type of the image manifest.', null=True)),
                ('image_pushed_at', models.DateTimeField(blank=True, db_comment='The date and time, expressed in standard JavaScript date format, at which the current image was pushed to the repository.', null=True)),
                ('image_size_in_bytes', models.BigIntegerField(blank=True, db_comment='The size, in bytes, of the image in the repository.', null=True)),
                ('last_recorded_pull_time', models.DateTimeField(blank=True, db_comment='The date and time, expressed in standard JavaScript date format, when Amazon ECR recorded the last image pull.', null=True)),
                ('registry_id', models.TextField(blank=True, db_comment='The Amazon Web Services account ID associated with the registry to which this image belongs.', null=True)),
                ('image_scan_findings_summary', models.JSONField(blank=True, db_comment='A summary of the last completed image scan.', null=True)),
                ('image_scan_status', models.JSONField(blank=True, db_comment='The current state of the scan.', null=True)),
                ('image_tags', models.JSONField(blank=True, db_comment='The list of tags associated with this image.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ecr_image',
                'db_table_comment': 'AWS ECR Image',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEcrpublicRepository',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('repository_name', models.TextField(blank=True, db_comment='The name of the repository.', null=True)),
                ('registry_id', models.TextField(blank=True, db_comment='The AWS account ID associated with the public registry that contains the repository.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that identifies the repository.', null=True)),
                ('repository_uri', models.TextField(blank=True, db_comment='The URI for the repository.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The date and time, in JavaScript date format, when the repository was created.', null=True)),
                ('image_details', models.JSONField(blank=True, db_comment='A list of ImageDetail objects that contain data about the image.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='The JSON repository policy text associated with the repository.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the policy in a canonical form for easier searching.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the repository.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ecrpublic_repository',
                'db_table_comment': 'AWS ECR Public Repository',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEcrRegistryScanningConfiguration',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('registry_id', models.TextField(blank=True, db_comment='The ID of the registry.', null=True)),
                ('scanning_configuration', models.JSONField(blank=True, db_comment='The scanning configuration for the registry.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ecr_registry_scanning_configuration',
                'db_table_comment': 'AWS ECR Registry Scanning Configuration',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEcrRepository',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('repository_name', models.TextField(blank=True, db_comment='The name of the repository.', null=True)),
                ('registry_id', models.TextField(blank=True, db_comment='The AWS account ID associated with the registry that contains the repositories to be described.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that identifies the repository.', null=True)),
                ('repository_uri', models.TextField(blank=True, db_comment='The URI for the repository.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The date and time, in JavaScript date format, when the repository was created.', null=True)),
                ('image_tag_mutability', models.TextField(blank=True, db_comment='The tag mutability setting for the repository.', null=True)),
                ('last_evaluated_at', models.DateTimeField(blank=True, db_comment='The time stamp of the last time that the lifecycle policy was run.', null=True)),
                ('max_results', models.BigIntegerField(blank=True, db_comment='The maximum number of repository results returned by DescribeRepositories.', null=True)),
                ('encryption_configuration', models.JSONField(blank=True, db_comment='The encryption configuration for the repository.', null=True)),
                ('image_details', models.JSONField(blank=True, db_comment='[DEPRECATED] This column has been deprecated and will be removed in a future release, use the aws_ecr_image table instead. A list of ImageDetail objects that contain data about the image.', null=True)),
                ('repository_scanning_configuration', models.JSONField(blank=True, db_comment='Gets the scanning configuration for one or more repositories.', null=True)),
                ('image_scanning_configuration', models.JSONField(blank=True, db_comment='The image scanning configuration for a repository.', null=True)),
                ('image_scanning_findings', models.JSONField(blank=True, db_comment='[DEPRECATED] This column has been deprecated and will be removed in a future release, use the aws_ecr_image_scan_finding table instead. Scan findings for an image.', null=True)),
                ('lifecycle_policy', models.JSONField(blank=True, db_comment='The JSON lifecycle policy text.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='The JSON repository policy text associated with the repository.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the policy in a canonical form for easier searching.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the Repository.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ecr_repository',
                'db_table_comment': 'AWS ECR Repository',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEcsCluster',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cluster_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that identifies the cluster.', null=True)),
                ('cluster_name', models.TextField(blank=True, db_comment='A user-generated string that you use to identify your cluster.', null=True)),
                ('active_services_count', models.BigIntegerField(blank=True, db_comment='The number of services that are running on the cluster in an ACTIVE state.', null=True)),
                ('pending_tasks_count', models.BigIntegerField(blank=True, db_comment='The number of tasks in the cluster that are in the PENDING state.', null=True)),
                ('registered_container_instances_count', models.BigIntegerField(blank=True, db_comment='The number of container instances registered into the cluster. This includes container instances in both ACTIVE and DRAINING status.', null=True)),
                ('running_tasks_count', models.BigIntegerField(blank=True, db_comment='The number of tasks in the cluster that are in the RUNNING state.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the cluster.', null=True)),
                ('attachments_status', models.TextField(blank=True, db_comment='The status of the capacity providers associated with the cluster.', null=True)),
                ('attachments', models.JSONField(blank=True, db_comment='The resources attached to a cluster. When using a capacity provider with a cluster, the Auto Scaling plan that is created will be returned as a cluster attachment.', null=True)),
                ('capacity_providers', models.JSONField(blank=True, db_comment='The capacity providers associated with the cluster.', null=True)),
                ('default_capacity_provider_strategy', models.JSONField(blank=True, db_comment='The default capacity provider strategy for the cluster.', null=True)),
                ('settings', models.JSONField(blank=True, db_comment='The settings for the cluster. This parameter indicates whether CloudWatch Container Insights is enabled or disabled for a cluster.', null=True)),
                ('statistics', models.JSONField(blank=True, db_comment='Additional information about your clusters that are separated by launch type.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the cluster.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ecs_cluster',
                'db_table_comment': 'AWS ECS Cluster',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEcsClusterMetricCpuUtilization',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cluster_name', models.TextField(blank=True, db_comment='A user-generated string that you use to identify your cluster.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ecs_cluster_metric_cpu_utilization',
                'db_table_comment': 'AWS ECS Cluster Cloudwatch Metrics - CPU Utilization',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEcsClusterMetricCpuUtilizationDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cluster_name', models.TextField(blank=True, db_comment='A user-generated string that you use to identify your cluster.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ecs_cluster_metric_cpu_utilization_daily',
                'db_table_comment': 'AWS ECS Cluster Cloudwatch Metrics - CPU Utilization (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEcsClusterMetricCpuUtilizationHourly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cluster_name', models.TextField(blank=True, db_comment='A user-generated string that you use to identify your cluster.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ecs_cluster_metric_cpu_utilization_hourly',
                'db_table_comment': 'AWS ECS Cluster Cloudwatch Metrics - CPU Utilization (Hourly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEcsContainerInstance',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The namespace Amazon Resource Name (ARN) of the container instance.', null=True)),
                ('ec2_instance_id', models.TextField(blank=True, db_comment='The EC2 instance ID of the container instance.', null=True)),
                ('cluster_arn', models.TextField(blank=True, db_comment='The ARN of the cluster.', null=True)),
                ('agent_connected', models.BooleanField(blank=True, db_comment='True if the agent is connected to Amazon ECS.', null=True)),
                ('agent_update_status', models.TextField(blank=True, db_comment='The status of the most recent agent update.', null=True)),
                ('attachments', models.JSONField(blank=True, db_comment='The resources attached to a container instance, such as elastic network interfaces.', null=True)),
                ('attributes', models.JSONField(blank=True, db_comment='The attributes set for the container instance.', null=True)),
                ('capacity_provider_name', models.TextField(blank=True, db_comment='The capacity provider associated with the container instance.', null=True)),
                ('pending_tasks_count', models.BigIntegerField(blank=True, db_comment='The number of tasks on the container instance that are in the PENDING status.', null=True)),
                ('registered_at', models.DateTimeField(blank=True, db_comment='The Unix timestamp for when the container instance was registered.', null=True)),
                ('registered_resources', models.JSONField(blank=True, db_comment='CPU and memory that can be allocated on this container instance to tasks.', null=True)),
                ('remaining_resources', models.JSONField(blank=True, db_comment='CPU and memory that is available for new tasks.', null=True)),
                ('running_tasks_count', models.BigIntegerField(blank=True, db_comment='CPU and memory that is available for new tasks.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the container instance.', null=True)),
                ('status_reason', models.TextField(blank=True, db_comment='The reason that the container instance reached its current status.', null=True)),
                ('version', models.BigIntegerField(blank=True, db_comment='The reason that the container instance reached its current status.', null=True)),
                ('version_info', models.JSONField(blank=True, db_comment='Version information for the Amazon ECS container agent and Docker daemon running on the container instance.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ecs_container_instance',
                'db_table_comment': 'AWS ECS Container Instance',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEcsService',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('service_name', models.TextField(blank=True, db_comment='The name of the service.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the service.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the service. Valid values are: ACTIVE, DRAINING, or INACTIVE.', null=True)),
                ('cluster_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the cluster that hosts the service.', null=True)),
                ('task_definition', models.TextField(blank=True, db_comment='The task definition to use for tasks in the service.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The date and time when the service was created.', null=True)),
                ('created_by', models.TextField(blank=True, db_comment='The principal that created the service.', null=True)),
                ('deployment_controller_type', models.TextField(blank=True, db_comment='The deployment controller type to use. Possible values are: ECS, CODE_DEPLOY, and EXTERNAL.', null=True)),
                ('desired_count', models.BigIntegerField(blank=True, db_comment='The desired number of instantiations of the task definition to keep running on the service.', null=True)),
                ('enable_ecs_managed_tags', models.BooleanField(blank=True, db_comment='Specifies whether to enable Amazon ECS managed tags for the tasks in the service.', null=True)),
                ('enable_execute_command', models.BooleanField(blank=True, db_comment='Indicates whether or not the execute command functionality is enabled for the service.', null=True)),
                ('health_check_grace_period_seconds', models.BigIntegerField(blank=True, db_comment='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started.', null=True)),
                ('launch_type', models.TextField(blank=True, db_comment='The launch type on which your service is running. If no value is specified, it will default to EC2.', null=True)),
                ('pending_count', models.BigIntegerField(blank=True, db_comment='The number of tasks in the cluster that are in the PENDING state.', null=True)),
                ('platform_family', models.TextField(blank=True, db_comment='The operating system that your tasks in the service run on.', null=True)),
                ('platform_version', models.TextField(blank=True, db_comment='The platform version on which to run your service.', null=True)),
                ('propagate_tags', models.TextField(blank=True, db_comment='Specifies whether to propagate the tags from the task definition or the service to the task. If no value is specified, the tags are not propagated.', null=True)),
                ('role_arn', models.TextField(blank=True, db_comment='The ARN of the IAM role associated with the service that allows the Amazon ECS container agent to register container instances with an Elastic Load Balancing load balancer.', null=True)),
                ('running_count', models.BigIntegerField(blank=True, db_comment='The number of tasks in the cluster that are in the RUNNING state.', null=True)),
                ('scheduling_strategy', models.TextField(blank=True, db_comment='The scheduling strategy to use for the service.', null=True)),
                ('capacity_provider_strategy', models.JSONField(blank=True, db_comment='The capacity provider strategy associated with the service.', null=True)),
                ('deployment_configuration', models.JSONField(blank=True, db_comment='Optional deployment parameters that control how many tasks run during the deployment and the ordering of stopping and starting tasks.', null=True)),
                ('deployments', models.JSONField(blank=True, db_comment='The current state of deployments for the service.', null=True)),
                ('events', models.JSONField(blank=True, db_comment='The event stream for your service. A maximum of 100 of the latest events are displayed.', null=True)),
                ('load_balancers', models.JSONField(blank=True, db_comment='A list of Elastic Load Balancing load balancer objects, containing the load balancer name, the container name (as it appears in a container definition), and the container port to access from the load balancer.', null=True)),
                ('network_configuration', models.JSONField(blank=True, db_comment='The VPC subnet and security group configuration for tasks that receive their own elastic network interface by using the awsvpc networking mode.', null=True)),
                ('placement_constraints', models.JSONField(blank=True, db_comment='The placement constraints for the tasks in the service.', null=True)),
                ('placement_strategy', models.JSONField(blank=True, db_comment='The placement strategy that determines how tasks for the service are placed.', null=True)),
                ('service_registries', models.JSONField(blank=True, db_comment='The details of the service discovery registries to assign to this service.', null=True)),
                ('task_sets', models.JSONField(blank=True, db_comment='Information about a set of Amazon ECS tasks in either an AWS CodeDeploy or an EXTERNAL deployment.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The metadata that you apply to the service to help you categorize and organize them.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ecs_service',
                'db_table_comment': 'AWS ECS Service',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEcsTask',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('task_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the task.', null=True)),
                ('container_instance_arn', models.TextField(blank=True, db_comment='The ARN of the container instances that host the task.', null=True)),
                ('cluster_name', models.TextField(blank=True, db_comment='A user-generated string that you use to identify your cluster.', null=True)),
                ('desired_status', models.TextField(blank=True, db_comment='The desired status of the task.', null=True)),
                ('launch_type', models.TextField(blank=True, db_comment='The infrastructure on which your task is running.', null=True)),
                ('availability_zone', models.TextField(blank=True, db_comment='The availability zone of the task.', null=True)),
                ('capacity_provider_name', models.TextField(blank=True, db_comment='The capacity provider associated with the task.', null=True)),
                ('cluster_arn', models.TextField(blank=True, db_comment='The ARN of the cluster that hosts the task.', null=True)),
                ('connectivity', models.TextField(blank=True, db_comment='The connectivity status of a task.', null=True)),
                ('connectivity_at', models.DateTimeField(blank=True, db_comment='The Unix timestamp for when the task last went into CONNECTED status.', null=True)),
                ('cpu', models.BigIntegerField(blank=True, db_comment='The number of CPU units used by the task as expressed in a task definition.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The Unix timestamp for when the task was created.', null=True)),
                ('enable_execute_command', models.BooleanField(blank=True, db_comment='Whether or not execute command functionality is enabled for this task. If true, this enables execute command functionality on all containers in the task.', null=True)),
                ('execution_stopped_at', models.DateTimeField(blank=True, db_comment='The Unix timestamp for when the task execution stopped.', null=True)),
                ('group', models.TextField(blank=True, db_comment='The name of the task group associated with the task.', null=True)),
                ('health_status', models.TextField(blank=True, db_comment='The health status for the task, which is determined by the health of the essential containers in the task. If all essential containers in the task are reporting as HEALTHY, then the task status also reports as HEALTHY.', null=True)),
                ('last_status', models.TextField(blank=True, db_comment='The last known status of the task.', null=True)),
                ('memory', models.BigIntegerField(blank=True, db_comment='The amount of memory (in MiB) used by the task as expressed in a task definition.', null=True)),
                ('platform_version', models.TextField(blank=True, db_comment='The platform version on which your task is running.', null=True)),
                ('pull_started_at', models.DateTimeField(blank=True, db_comment='The Unix timestamp for when the container image pull began.', null=True)),
                ('pull_stopped_at', models.DateTimeField(blank=True, db_comment='The Unix timestamp for when the container image pull completed.', null=True)),
                ('service_name', models.TextField(blank=True, db_comment='The name of the service.', null=True)),
                ('started_at', models.DateTimeField(blank=True, db_comment='The Unix timestamp for when the task started.', null=True)),
                ('started_by', models.TextField(blank=True, db_comment='The tag specified when a task is started.', null=True)),
                ('stop_code', models.TextField(blank=True, db_comment='The stop code indicating why a task was stopped.', null=True)),
                ('stopped_at', models.DateTimeField(blank=True, db_comment='The Unix timestamp for when the task was stopped.', null=True)),
                ('stopped_reason', models.TextField(blank=True, db_comment='The reason that the task was stopped.', null=True)),
                ('stopping_at', models.DateTimeField(blank=True, db_comment='The Unix timestamp for when the task stops.', null=True)),
                ('task_definition_arn', models.TextField(blank=True, db_comment='The ARN of the task definition that creates the task.', null=True)),
                ('version', models.BigIntegerField(blank=True, db_comment='The version counter for the task.', null=True)),
                ('attachments', models.JSONField(blank=True, db_comment='The Elastic Network Adapter associated with the task if the task uses the awsvpc network mode.', null=True)),
                ('attributes', models.JSONField(blank=True, db_comment='The attributes of the task.', null=True)),
                ('containers', models.JSONField(blank=True, db_comment='The containers associated with the task.', null=True)),
                ('ephemeral_storage', models.JSONField(blank=True, db_comment='The ephemeral storage settings for the task.', null=True)),
                ('inference_accelerators', models.JSONField(blank=True, db_comment='The Elastic Inference accelerator associated with the task.', null=True)),
                ('overrides', models.JSONField(blank=True, db_comment='One or more container overrides.', null=True)),
                ('protection', models.JSONField(blank=True, db_comment='Protection status of task in an Amazon ECS service.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with task.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ecs_task',
                'db_table_comment': 'AWS ECS Task',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEcsTaskDefinition',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('task_definition_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that identifies the task definition.', null=True)),
                ('cpu', models.BigIntegerField(blank=True, db_comment='The number of cpu units used by the task.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the task definition.', null=True)),
                ('execution_role_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the task execution role that grants the Amazon ECS container agent permission to make AWS API calls on your behalf.', null=True)),
                ('family', models.TextField(blank=True, db_comment='The name of a family that this task definition is registered to.', null=True)),
                ('ipc_mode', models.TextField(blank=True, db_comment='The IPC resource namespace to use for the containers in the task.', null=True)),
                ('memory', models.BigIntegerField(blank=True, db_comment='The amount (in MiB) of memory used by the task.', null=True)),
                ('network_mode', models.TextField(blank=True, db_comment='The Docker networking mode to use for the containers in the task.', null=True)),
                ('pid_mode', models.TextField(blank=True, db_comment='The process namespace to use for the containers in the task.', null=True)),
                ('revision', models.BigIntegerField(blank=True, db_comment='The revision of the task in a particular family.', null=True)),
                ('task_role_arn', models.TextField(blank=True, db_comment='The short name or full Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants containers in the task permission to call AWS APIs on your behalf.', null=True)),
                ('registered_at', models.TextField(blank=True, db_comment='The Unix timestamp for when the task definition was registered.', null=True)),
                ('registered_by', models.TextField(blank=True, db_comment='The principal that registered the task definition.', null=True)),
                ('container_definitions', models.JSONField(blank=True, db_comment='A list of container definitions in JSON format that describe the different containers that make up your task.', null=True)),
                ('compatibilities', models.JSONField(blank=True, db_comment='The launch type to use with your task.', null=True)),
                ('inference_accelerators', models.JSONField(blank=True, db_comment='The Elastic Inference accelerator associated with the task.', null=True)),
                ('placement_constraints', models.JSONField(blank=True, db_comment='An array of placement constraint objects to use for tasks.', null=True)),
                ('proxy_configuration', models.JSONField(blank=True, db_comment='The configuration details for the App Mesh proxy.', null=True)),
                ('requires_attributes', models.JSONField(blank=True, db_comment='The container instance attributes required by your task.', null=True)),
                ('requires_compatibilities', models.JSONField(blank=True, db_comment='The launch type the task requires. If no value is specified, it will default to EC2. Valid values include EC2 and FARGATE.', null=True)),
                ('volumes', models.JSONField(blank=True, db_comment='The list of volume definitions for the task.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with task.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ecs_task_definition',
                'db_table_comment': 'AWS ECS Task Definition',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEfsAccessPoint',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the access point. This is the value of the Name tag.', null=True)),
                ('access_point_id', models.TextField(blank=True, db_comment='The ID of the access point, assigned by Amazon EFS.', null=True)),
                ('access_point_arn', models.TextField(blank=True, db_comment='The unique Amazon Resource Name (ARN) associated with the access point.', null=True)),
                ('life_cycle_state', models.TextField(blank=True, db_comment='Identifies the lifecycle phase of the access point.', null=True)),
                ('file_system_id', models.TextField(blank=True, db_comment='The ID of the EFS file system that the access point applies to.', null=True)),
                ('client_token', models.TextField(blank=True, db_comment='The opaque string specified in the request to ensure idempotent creation.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='Identified the AWS account that owns the access point resource.', null=True)),
                ('posix_user', models.JSONField(blank=True, db_comment='The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point that is used for all file operations by NFS clients using the access point.', null=True)),
                ('root_directory', models.JSONField(blank=True, db_comment='The directory on the Amazon EFS file system that the access point exposes as the root directory to NFS clients using the access point.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The tags associated with the access point, presented as an array of Tag objects.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_efs_access_point',
                'db_table_comment': 'AWS EFS Access Point',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEfsFileSystem',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='Name of the file system provided by the user.', null=True)),
                ('file_system_id', models.TextField(blank=True, db_comment='The ID of the file system, assigned by Amazon EFS.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the EFS file system.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='The AWS account that created the file system.', null=True)),
                ('creation_token', models.TextField(blank=True, db_comment='The opaque string specified in the request.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The time that the file system was created.', null=True)),
                ('automatic_backups', models.TextField(blank=True, db_comment='Automatic backups use a default backup plan with the AWS Backup recommended settings for automatic backups.', null=True)),
                ('life_cycle_state', models.TextField(blank=True, db_comment='The lifecycle phase of the file system.', null=True)),
                ('number_of_mount_targets', models.BigIntegerField(blank=True, db_comment='The current number of mount targets that the file system has.', null=True)),
                ('performance_mode', models.TextField(blank=True, db_comment='The performance mode of the file system.', null=True)),
                ('encrypted', models.BooleanField(blank=True, db_comment='A Boolean value that, if true, indicates that the file system is encrypted.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The ID of an AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the encrypted file system.', null=True)),
                ('throughput_mode', models.TextField(blank=True, db_comment='The throughput mode for a file system.', null=True)),
                ('provisioned_throughput_in_mibps', models.FloatField(blank=True, db_comment='The throughput, measured in MiB/s, that you want to provision for a file system.', null=True)),
                ('size_in_bytes', models.JSONField(blank=True, db_comment='The latest known metered size (in bytes) of data stored in the file system.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='The JSON formatted FileSystemPolicy for the EFS file system.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the policy in a canonical form for easier searching.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with Filesystem.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_efs_file_system',
                'db_table_comment': 'AWS Elastic File System',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEfsMountTarget',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('mount_target_id', models.TextField(blank=True, db_comment='The ID of the mount target.', null=True)),
                ('file_system_id', models.TextField(blank=True, db_comment='The ID of the file system for which the mount target is intended.', null=True)),
                ('life_cycle_state', models.TextField(blank=True, db_comment='Lifecycle state of the mount target.', null=True)),
                ('availability_zone_id', models.TextField(blank=True, db_comment='The unique and consistent identifier of the Availability Zone that the mount target resides in.', null=True)),
                ('availability_zone_name', models.TextField(blank=True, db_comment='The name of the Availability Zone in which the mount target is located.', null=True)),
                ('ip_address', models.GenericIPAddressField(blank=True, db_comment='Address at which the file system can be mounted by using the mount target.', null=True)),
                ('network_interface_id', models.TextField(blank=True, db_comment='The ID of the network interface that Amazon EFS created when it created the mount target.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='AWS account ID that owns the resource.', null=True)),
                ('subnet_id', models.TextField(blank=True, db_comment="The ID of the mount target's subnet.", null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The virtual private cloud (VPC) ID that the mount target is configured in.', null=True)),
                ('security_groups', models.JSONField(blank=True, db_comment='Specifies the security groups currently in effect for a mount target.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_efs_mount_target',
                'db_table_comment': 'AWS EFS Mount Target',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEksAddon',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('addon_name', models.TextField(blank=True, db_comment='The name of the add-on.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the add-on.', null=True)),
                ('cluster_name', models.TextField(blank=True, db_comment='The name of the cluster.', null=True)),
                ('addon_version', models.TextField(blank=True, db_comment='The version of the add-on.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the add-on.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The date and time that the add-on was created.', null=True)),
                ('modified_at', models.DateTimeField(blank=True, db_comment='The date and time that the add-on was last modified.', null=True)),
                ('service_account_role_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the IAM role that is bound to the Kubernetes service account used by the add-on.', null=True)),
                ('health_issues', models.JSONField(blank=True, db_comment="An object that represents the add-on's health issues.", null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='The metadata that you apply to the cluster to assist with categorization and organization.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_eks_addon',
                'db_table_comment': 'AWS EKS Addon',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEksAddonVersion',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('addon_name', models.TextField(blank=True, db_comment='The name of the add-on.', null=True)),
                ('addon_version', models.TextField(blank=True, db_comment='The version of the add-on.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of the add-on.', null=True)),
                ('addon_configuration', models.JSONField(blank=True, db_comment='The configuration for the add-on.', null=True)),
                ('architecture', models.JSONField(blank=True, db_comment='The architectures that the version supports.', null=True)),
                ('compatibilities', models.JSONField(blank=True, db_comment='An object that represents the compatibilities of a version.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_eks_addon_version',
                'db_table_comment': 'AWS EKS Addon Version',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEksCluster',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the cluster.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the cluster.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The Unix epoch timestamp in seconds for when the cluster was created.', null=True)),
                ('version', models.TextField(blank=True, db_comment='The Kubernetes server version for the cluster.', null=True)),
                ('endpoint', models.TextField(blank=True, db_comment='The endpoint for your Kubernetes API server.', null=True)),
                ('role_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the IAM role that provides permissions for the Kubernetes control plane to make calls to AWS API operations on your behalf.', null=True)),
                ('encryption_config', models.JSONField(blank=True, db_comment='The encryption configuration for the cluster.', null=True)),
                ('resources_vpc_config', models.JSONField(blank=True, db_comment='The VPC configuration used by the cluster control plane.', null=True)),
                ('kubernetes_network_config', models.JSONField(blank=True, db_comment='The Kubernetes network configuration for the cluster.', null=True)),
                ('logging', models.JSONField(blank=True, db_comment='The logging configuration for the cluster.', null=True)),
                ('identity', models.JSONField(blank=True, db_comment='The identity provider information for the cluster.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current status of the cluster.', null=True)),
                ('certificate_authority', models.JSONField(blank=True, db_comment='The certificate-authority-data for the cluster.', null=True)),
                ('platform_version', models.TextField(blank=True, db_comment='The platform version of your Amazon EKS cluster.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A list of tags assigned to the table', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_eks_cluster',
                'db_table_comment': 'AWS Elastic Kubernetes Service Cluster',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEksFargateProfile',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('fargate_profile_name', models.TextField(blank=True, db_comment='The name of the Fargate profile.', null=True)),
                ('cluster_name', models.TextField(blank=True, db_comment='The name of the Amazon EKS cluster that the Fargate profile belongs to.', null=True)),
                ('fargate_profile_arn', models.TextField(blank=True, db_comment='The full Amazon Resource Name (ARN) of the Fargate profile.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The Unix epoch timestamp in seconds for when the Fargate profile was created.', null=True)),
                ('pod_execution_role_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the pod execution role to use for pods that match the selectors in the Fargate profile.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current status of the Fargate profile.', null=True)),
                ('selectors', models.JSONField(blank=True, db_comment='The selectors to match for pods to use this Fargate profile.', null=True)),
                ('subnets', models.JSONField(blank=True, db_comment='The subnets used by the Fargate profile.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A list of tags assigned to the Fargate profile.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_eks_fargate_profile',
                'db_table_comment': 'AWS Elastic Kubernetes Service Fargate Profile',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEksIdentityProviderConfig',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the identity provider configuration.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of the identity provider configuration.', null=True)),
                ('client_id', models.TextField(blank=True, db_comment='This is also known as audience. The ID of the client application that makes authentication requests to the OIDC identity provider.', null=True)),
                ('cluster_name', models.TextField(blank=True, db_comment='The name of the cluster.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the configuration.', null=True)),
                ('groups_claim', models.TextField(blank=True, db_comment='The JSON web token (JWT) claim that the provider uses to return your groups.', null=True)),
                ('groups_prefix', models.TextField(blank=True, db_comment='The prefix that is prepended to group claims to prevent clashes with existing names (such as system: groups).', null=True)),
                ('issuer_url', models.TextField(blank=True, db_comment='The URL of the OIDC identity provider that allows the API server to discover public signing keys for verifying tokens.', null=True)),
                ('username_claim', models.TextField(blank=True, db_comment='The JSON Web token (JWT) claim that is used as the username.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the OIDC identity provider.', null=True)),
                ('username_prefix', models.TextField(blank=True, db_comment='The prefix that is prepended to username claims to prevent clashes with existing names.', null=True)),
                ('required_claims', models.JSONField(blank=True, db_comment='The key-value pairs that describe required claims in the identity token.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The metadata to apply to the provider configuration to assist with categorization and organization.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_eks_identity_provider_config',
                'db_table_comment': 'AWS EKS Identity Provider Config',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEksNodeGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nodegroup_name', models.TextField(blank=True, db_comment='The name associated with an Amazon EKS managed node group.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) associated with the managed node group.', null=True)),
                ('cluster_name', models.TextField(blank=True, db_comment='The name of the cluster that the managed node group resides in.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The Unix epoch timestamp in seconds for when the managed node group was created.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current status of the managed node group.', null=True)),
                ('ami_type', models.TextField(blank=True, db_comment='The AMI type that was specified in the node group configuration.', null=True)),
                ('capacity_type', models.TextField(blank=True, db_comment='The capacity type of your managed node group.', null=True)),
                ('disk_size', models.BigIntegerField(blank=True, db_comment='The disk size in the node group configuration.', null=True)),
                ('modified_at', models.DateTimeField(blank=True, db_comment='The Unix epoch timestamp in seconds for when the managed node group was last modified.', null=True)),
                ('node_role', models.TextField(blank=True, db_comment='The IAM role associated with your node group.', null=True)),
                ('release_version', models.TextField(blank=True, db_comment="If the node group was deployed using a launch template with a custom AMI, then this is the AMI ID that was specified in the launch template. For node groups that weren't deployed using a launch template, this is the version of the Amazon EKS optimized AMI that the node group was deployed with.", null=True)),
                ('version', models.TextField(blank=True, db_comment='The Kubernetes version of the managed node group.', null=True)),
                ('health', models.JSONField(blank=True, db_comment='The health status of the node group.', null=True)),
                ('instance_types', models.JSONField(blank=True, db_comment='The instance type that is associated with the node group. If the node group was deployed with a launch template, then this is null.', null=True)),
                ('labels', models.JSONField(blank=True, db_comment='The Kubernetes labels applied to the nodes in the node group.', null=True)),
                ('launch_template', models.JSONField(blank=True, db_comment='If a launch template was used to create the node group, then this is the launch template that was used.', null=True)),
                ('remote_access', models.JSONField(blank=True, db_comment='The remote access configuration that is associated with the node group. If the node group was deployed with a launch template, then this is null.', null=True)),
                ('resources', models.JSONField(blank=True, db_comment='The resources associated with the node group, such as Auto Scaling groups and security groups for remote access.', null=True)),
                ('scaling_config', models.JSONField(blank=True, db_comment='The scaling configuration details for the Auto Scaling group that is associated with your node group.', null=True)),
                ('subnets', models.JSONField(blank=True, db_comment='The subnets that were specified for the Auto Scaling group that is associated with your node group.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('taints', models.JSONField(blank=True, db_comment='The Kubernetes taints to be applied to the nodes in the node group when they are created.', null=True)),
                ('update_config', models.JSONField(blank=True, db_comment='The node group update configuration.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_eks_node_group',
                'db_table_comment': 'AWS EKS Node Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsElasticacheCluster',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cache_cluster_id', models.TextField(blank=True, db_comment='An unique identifier for ElastiCache cluster.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN (Amazon Resource Name) of the cache cluster.', null=True)),
                ('cache_node_type', models.TextField(blank=True, db_comment='The name of the compute and memory capacity node type for the cluster.', null=True)),
                ('cache_cluster_status', models.TextField(blank=True, db_comment='The current state of this cluster, one of the following values: available, creating, deleted, deleting, incompatible-network, modifying, rebooting cluster nodes, restore-failed, or snapshotting.', null=True)),
                ('at_rest_encryption_enabled', models.BooleanField(blank=True, db_comment='A flag that enables encryption at-rest when set to true.', null=True)),
                ('auth_token_enabled', models.BooleanField(blank=True, db_comment='A flag that enables using an AuthToken (password) when issuing Redis commands.', null=True)),
                ('auto_minor_version_upgrade', models.BooleanField(blank=True, db_comment='This parameter is currently disabled.', null=True)),
                ('cache_cluster_create_time', models.DateTimeField(blank=True, db_comment='The date and time when the cluster was created.', null=True)),
                ('cache_subnet_group_name', models.TextField(blank=True, db_comment='The name of the cache subnet group associated with the cluster.', null=True)),
                ('client_download_landing_page', models.TextField(blank=True, db_comment='The URL of the web page where you can download the latest ElastiCache client library.', null=True)),
                ('engine', models.TextField(blank=True, db_comment='The name of the cache engine (memcached or redis) to be used for this cluster.', null=True)),
                ('engine_version', models.TextField(blank=True, db_comment='The version of the cache engine that is used in this cluster.', null=True)),
                ('num_cache_nodes', models.BigIntegerField(blank=True, db_comment='The number of cache nodes in the cluster.', null=True)),
                ('preferred_availability_zone', models.TextField(blank=True, db_comment="The name of the Availability Zone in which the cluster is located or 'Multiple' if the cache nodes are located in different Availability Zones.", null=True)),
                ('preferred_maintenance_window', models.TextField(blank=True, db_comment='Specifies the weekly time range during which maintenance on the cluster is performed.', null=True)),
                ('replication_group_id', models.TextField(blank=True, db_comment='The replication group to which this cluster belongs.', null=True)),
                ('snapshot_retention_limit', models.BigIntegerField(blank=True, db_comment='The number of days for which ElastiCache retains automatic cluster snapshots before deleting them.', null=True)),
                ('snapshot_window', models.TextField(blank=True, db_comment='The daily time range (in UTC) during which ElastiCache begins taking a daily snapshot of your cluster.', null=True)),
                ('transit_encryption_enabled', models.BooleanField(blank=True, db_comment='A flag that enables in-transit encryption when set to true.', null=True)),
                ('auth_token_last_modified_date', models.DateTimeField(blank=True, db_comment='The date the auth token was last modified.', null=True)),
                ('ip_discovery', models.TextField(blank=True, db_comment='The network type associated with the cluster, either ipv4 or ipv6.', null=True)),
                ('network_type', models.TextField(blank=True, db_comment='Must be either ipv4, ipv6, or dual_stack.', null=True)),
                ('preferred_outpost_arn', models.TextField(blank=True, db_comment='The outpost ARN in which the cache cluster is created.', null=True)),
                ('replication_group_log_delivery_enabled', models.BooleanField(blank=True, db_comment='A boolean value indicating whether log delivery is enabled for the replication group.', null=True)),
                ('transit_encryption_mode', models.TextField(blank=True, db_comment='A setting that allows you to migrate your clients to use in-transit encryption, with no downtime.', null=True)),
                ('cache_parameter_group', models.JSONField(blank=True, db_comment='Status of the cache parameter group.', null=True)),
                ('notification_configuration', models.JSONField(blank=True, db_comment='Describes a notification topic and its status.', null=True)),
                ('pending_modified_values', models.JSONField(blank=True, db_comment='A group of settings that are applied to the cluster in the future, or that are currently being applied.', null=True)),
                ('security_groups', models.JSONField(blank=True, db_comment='A list of VPC Security Groups associated with the cluster.', null=True)),
                ('configuration_endpoint', models.JSONField(blank=True, db_comment='Represents a Memcached cluster endpoint which can be used by an application to connect to any node in the cluster.', null=True)),
                ('cache_nodes', models.JSONField(blank=True, db_comment='A list of cache nodes that are members of the cluster.', null=True)),
                ('cache_security_groups', models.JSONField(blank=True, db_comment='A list of cache security group elements, composed of name and status sub-elements.', null=True)),
                ('log_delivery_configurations', models.JSONField(blank=True, db_comment='Returns the destination, format, and type of the logs.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with the cluster.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_elasticache_cluster',
                'db_table_comment': 'AWS ElastiCache Cluster',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsElasticacheParameterGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cache_parameter_group_name', models.TextField(blank=True, db_comment='The name of the cache parameter group.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN (Amazon Resource Name) of the cache parameter group.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description for the cache parameter group.', null=True)),
                ('cache_parameter_group_family', models.TextField(blank=True, db_comment='The name of the cache parameter group family that this cache parameter group is compatible with.', null=True)),
                ('is_global', models.BooleanField(blank=True, db_comment='Indicates whether the parameter group is associated with a Global Datastore.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_elasticache_parameter_group',
                'db_table_comment': 'AWS ElastiCache Parameter Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsElasticacheRedisMetricCacheHitsHourly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cache_cluster_id', models.TextField(blank=True, db_comment='The cache cluster id.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_elasticache_redis_metric_cache_hits_hourly',
                'db_table_comment': 'AWS Elasticache Redis CacheHits metric (Hourly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsElasticacheRedisMetricCurrConnectionsHourly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cache_cluster_id', models.TextField(blank=True, db_comment='The cache cluster id.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_elasticache_redis_metric_curr_connections_hourly',
                'db_table_comment': 'AWS Elasticache Redis CurrConnections metric (Hourly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsElasticacheRedisMetricEngineCpuUtilizationDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cache_cluster_id', models.TextField(blank=True, db_comment='The cache cluster id.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_elasticache_redis_metric_engine_cpu_utilization_daily',
                'db_table_comment': 'AWS Elasticache Redis EngineCPUUtilization metric (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsElasticacheRedisMetricEngineCpuUtilizationHourly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cache_cluster_id', models.TextField(blank=True, db_comment='The cache cluster id.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_elasticache_redis_metric_engine_cpu_utilization_hourly',
                'db_table_comment': 'AWS Elasticache Redis EngineCPUUtilization metric (Hourly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsElasticacheRedisMetricGetTypeCmdsHourly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cache_cluster_id', models.TextField(blank=True, db_comment='The cache cluster id.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_elasticache_redis_metric_get_type_cmds_hourly',
                'db_table_comment': 'AWS Elasticache Redis GetTypeCmds metric(Hourly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsElasticacheRedisMetricListBasedCmdsHourly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cache_cluster_id', models.TextField(blank=True, db_comment='The cache cluster id.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_elasticache_redis_metric_list_based_cmds_hourly',
                'db_table_comment': 'AWS Elasticache Redis ListBasedCmds metric (Hourly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsElasticacheRedisMetricNewConnectionsHourly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cache_cluster_id', models.TextField(blank=True, db_comment='The cache cluster id.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_elasticache_redis_metric_new_connections_hourly',
                'db_table_comment': 'AWS Elasticache Redis NewConnections metric (Hourly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsElasticacheReplicationGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('replication_group_id', models.TextField(blank=True, db_comment='The identifier for the replication group.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN (Amazon Resource Name) of the replication group.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The user supplied description of the replication group.', null=True)),
                ('at_rest_encryption_enabled', models.BooleanField(blank=True, db_comment='A flag that enables encryption at-rest when set to true.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The ID of the KMS key used to encrypt the disk in the cluster.', null=True)),
                ('auth_token_enabled', models.BooleanField(blank=True, db_comment='A flag that enables using an AuthToken (password) when issuing Redis commands.', null=True)),
                ('auth_token_last_modified_date', models.DateTimeField(blank=True, db_comment='The date when the auth token was last modified.', null=True)),
                ('automatic_failover', models.TextField(blank=True, db_comment='Indicates the status of automatic failover for this Redis replication group.', null=True)),
                ('cache_node_type', models.TextField(blank=True, db_comment='The name of the compute and memory capacity node type for each node in the replication group.', null=True)),
                ('cluster_enabled', models.BooleanField(blank=True, db_comment='A flag indicating whether or not this replication group is cluster enabled.', null=True)),
                ('multi_az', models.TextField(blank=True, db_comment='A flag indicating if you have Multi-AZ enabled to enhance fault tolerance.', null=True)),
                ('snapshot_retention_limit', models.BigIntegerField(blank=True, db_comment='The number of days for which ElastiCache retains automatic cluster snapshots before deleting them.', null=True)),
                ('snapshot_window', models.TextField(blank=True, db_comment='The daily time range (in UTC) during which ElastiCache begins taking a daily snapshot of your node group (shard).', null=True)),
                ('snapshotting_cluster_id', models.TextField(blank=True, db_comment='The cluster ID that is used as the daily snapshot source for the replication group.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current state of this replication group - creating, available, modifying, deleting, create-failed, snapshotting.', null=True)),
                ('transit_encryption_enabled', models.BooleanField(blank=True, db_comment='A flag that enables in-transit encryption when set to true.', null=True)),
                ('configuration_endpoint', models.JSONField(blank=True, db_comment='The configuration endpoint for this replication group.', null=True)),
                ('global_replication_group_info', models.JSONField(blank=True, db_comment='The name of the Global Datastore and role of this replication group in the Global Datastore.', null=True)),
                ('member_clusters', models.JSONField(blank=True, db_comment='The names of all the cache clusters that are part of this replication group.', null=True)),
                ('member_clusters_outpost_arns', models.JSONField(blank=True, db_comment="The outpost ARNs of the replication group's member clusters.", null=True)),
                ('node_groups', models.JSONField(blank=True, db_comment='A list of node groups in this replication group.', null=True)),
                ('pending_modified_values', models.JSONField(blank=True, db_comment='A group of settings to be applied to the replication group, either immediately or during the next maintenance window.', null=True)),
                ('user_group_ids', models.JSONField(blank=True, db_comment='The list of user group IDs that have access to the replication group.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_elasticache_replication_group',
                'db_table_comment': 'AWS ElastiCache Replication Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsElasticacheReservedCacheNode',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('reserved_cache_node_id', models.TextField(blank=True, db_comment='The unique identifier for the reservation.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the reserved cache node.', null=True)),
                ('reserved_cache_nodes_offering_id', models.TextField(blank=True, db_comment='The offering identifier.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The state of the reserved cache node.', null=True)),
                ('cache_node_type', models.TextField(blank=True, db_comment='The cache node type for the reserved cache nodes.', null=True)),
                ('cache_node_count', models.BigIntegerField(blank=True, db_comment='The number of cache nodes that have been reserved.', null=True)),
                ('duration', models.BigIntegerField(blank=True, db_comment='The duration of the reservation in seconds.', null=True)),
                ('fixed_price', models.FloatField(blank=True, db_comment='The fixed price charged for this reserved cache node.', null=True)),
                ('offering_type', models.TextField(blank=True, db_comment='The offering type of this reserved cache node.', null=True)),
                ('product_description', models.TextField(blank=True, db_comment='The description of the reserved cache node.', null=True)),
                ('start_time', models.DateTimeField(blank=True, db_comment='The time the reservation started.', null=True)),
                ('usage_price', models.FloatField(blank=True, db_comment='The hourly price charged for this reserved cache node.', null=True)),
                ('recurring_charges', models.JSONField(blank=True, db_comment='The recurring price charged to run this reserved cache node.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_elasticache_reserved_cache_node',
                'db_table_comment': 'AWS ElastiCache Reserved Cache Node',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsElasticacheSubnetGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cache_subnet_group_name', models.TextField(blank=True, db_comment='The name of the cache subnet group.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN (Amazon Resource Name) of the cache subnet group.', null=True)),
                ('cache_subnet_group_description', models.TextField(blank=True, db_comment='The description of the cache subnet group.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The Amazon Virtual Private Cloud identifier (VPC ID) of the cache subnet group.', null=True)),
                ('subnets', models.JSONField(blank=True, db_comment='A list of subnets associated with the cache subnet group.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_elasticache_subnet_group',
                'db_table_comment': 'AWS ElastiCache Subnet Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsElasticBeanstalkApplication',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the application.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the application.', null=True)),
                ('description', models.TextField(blank=True, db_comment='User-defined description of the application.', null=True)),
                ('date_created', models.DateTimeField(blank=True, db_comment='The date when the application was created.', null=True)),
                ('date_updated', models.DateTimeField(blank=True, db_comment='The date when the application was last modified.', null=True)),
                ('configuration_templates', models.JSONField(blank=True, db_comment='The names of the configuration templates associated with this application.', null=True)),
                ('versions', models.JSONField(blank=True, db_comment='The names of the versions for this application.', null=True)),
                ('resource_lifecycle_config', models.JSONField(blank=True, db_comment='The lifecycle settings for the application.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the application.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_elastic_beanstalk_application',
                'db_table_comment': 'AWS Elastic Beanstalk Application',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsElasticBeanstalkApplicationVersion',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('application_name', models.TextField(blank=True, db_comment='The name of the application to which the application version belongs.', null=True)),
                ('application_version_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the application version.', null=True)),
                ('build_arn', models.TextField(blank=True, db_comment='Reference to the artifact from the AWS CodeBuild build.', null=True)),
                ('date_created', models.DateTimeField(blank=True, db_comment='The creation date of the application version.', null=True)),
                ('date_updated', models.DateTimeField(blank=True, db_comment='The last modified date of the application version.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the application version.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The processing status of the application version. Reflects the state of the application version during its creation.', null=True)),
                ('version_label', models.TextField(blank=True, db_comment='A unique identifier for the application version.', null=True)),
                ('source_build_information', models.JSONField(blank=True, db_comment='Information about the source code for the application version if the source code was retrieved from AWS CodeCommit.', null=True)),
                ('source_bundle', models.JSONField(blank=True, db_comment="The storage location of the application version's source bundle in Amazon S3.", null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the application.', null=True)),
                ('title', models.TextField(blank=True, db_comment='A title for the resource, typically the resource name.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_elastic_beanstalk_application_version',
                'db_table_comment': 'AWS Elastic Beanstalk Application Version',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsElasticBeanstalkEnvironment',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('environment_name', models.TextField(blank=True, db_comment='The name of this environment.', null=True)),
                ('environment_id', models.TextField(blank=True, db_comment='The ID of this environment.', null=True)),
                ('arn', models.TextField(blank=True, db_comment="The environment's Amazon Resource Name (ARN).", null=True)),
                ('description', models.TextField(blank=True, db_comment='Describes this environment.', null=True)),
                ('date_created', models.DateTimeField(blank=True, db_comment='The creation date for this environment.', null=True)),
                ('abortable_operation_in_progress', models.BooleanField(blank=True, db_comment='Indicates if there is an in-progress environment configuration update or application version deployment that you can cancel.', null=True)),
                ('application_name', models.TextField(blank=True, db_comment='The name of the application associated with this environment.', null=True)),
                ('cname', models.TextField(blank=True, db_comment='The URL to the CNAME for this environment.', null=True)),
                ('date_updated', models.DateTimeField(blank=True, db_comment='The last modified date for this environment.', null=True)),
                ('endpoint_url', models.TextField(blank=True, db_comment='The URL to the LoadBalancer.', null=True)),
                ('health', models.TextField(blank=True, db_comment='The health status of the environment.', null=True)),
                ('health_status', models.TextField(blank=True, db_comment='Returns the health status of the application running in your environment.', null=True)),
                ('operations_role', models.TextField(blank=True, db_comment="The Amazon Resource Name (ARN) of the environment's operations role.", null=True)),
                ('platform_arn', models.TextField(blank=True, db_comment='The ARN of the platform version.', null=True)),
                ('solution_stack_name', models.TextField(blank=True, db_comment='The name of the SolutionStack deployed with this environment.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current operational status of the environment.', null=True)),
                ('template_name', models.TextField(blank=True, db_comment='The name of the configuration template used to originally launch this environment.', null=True)),
                ('version_label', models.TextField(blank=True, db_comment='The application version deployed in this environment.', null=True)),
                ('configuration_settings', models.JSONField(blank=True, db_comment='Returns a description of the settings for the specified configuration set, that is, either a configuration template or the configuration set associated with a running environment.', null=True)),
                ('environment_links', models.JSONField(blank=True, db_comment='A list of links to other environments in the same group.', null=True)),
                ('managed_actions', models.JSONField(blank=True, db_comment='A list of upcoming and in-progress managed actions.', null=True)),
                ('resources', models.JSONField(blank=True, db_comment='The description of the AWS resources used by this environment.', null=True)),
                ('tier', models.JSONField(blank=True, db_comment='Describes the current tier of this environment.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the Repository', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_elastic_beanstalk_environment',
                'db_table_comment': 'AWS ElasticBeanstalk Environment',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsElasticsearchDomain',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('domain_name', models.TextField(blank=True, db_comment='The name of the domain.', null=True)),
                ('engine_type', models.TextField(blank=True, db_comment='Specifies the EngineType of the domain.', null=True)),
                ('domain_id', models.TextField(blank=True, db_comment='The id of the domain.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the domain.', null=True)),
                ('elasticsearch_version', models.TextField(blank=True, db_comment='The version for the Elasticsearch domain.', null=True)),
                ('endpoint', models.TextField(blank=True, db_comment='The Elasticsearch domain endpoint that use to submit index and search requests.', null=True)),
                ('endpoints', models.JSONField(blank=True, db_comment='Map containing the Elasticsearch domain endpoints used to submit index and search requests.', null=True)),
                ('access_policies', models.TextField(blank=True, db_comment='IAM access policy as a JSON-formatted string.', null=True)),
                ('created', models.BooleanField(blank=True, db_comment='The domain creation status.', null=True)),
                ('deleted', models.BooleanField(blank=True, db_comment='The domain deletion status.', null=True)),
                ('processing', models.BooleanField(blank=True, db_comment='The status of the Elasticsearch domain configuration.', null=True)),
                ('upgrade_processing', models.BooleanField(blank=True, db_comment='The status of an Elasticsearch domain version upgrade.', null=True)),
                ('enabled', models.BooleanField(blank=True, db_comment='Specifies the status of the NodeToNodeEncryptionOptions.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the policy in a canonical form for easier searching.', null=True)),
                ('ebs_options', models.JSONField(blank=True, db_comment='Specifies whether EBS-based storage is enabled.', null=True)),
                ('advanced_options', models.JSONField(blank=True, db_comment='Specifies the status of the AdvancedOptions.', null=True)),
                ('advanced_security_options', models.JSONField(blank=True, db_comment="Specifies The current status of the Elasticsearch domain's advanced security options.", null=True)),
                ('auto_tune_options', models.JSONField(blank=True, db_comment="The current status of the Elasticsearch domain's Auto-Tune options.", null=True)),
                ('cognito_options', models.JSONField(blank=True, db_comment='The CognitoOptions for the specified domain.', null=True)),
                ('domain_endpoint_options', models.JSONField(blank=True, db_comment="The current status of the Elasticsearch domain's endpoint options.", null=True)),
                ('elasticsearch_cluster_config', models.JSONField(blank=True, db_comment='The type and number of instances in the domain cluster.', null=True)),
                ('encryption_at_rest_options', models.JSONField(blank=True, db_comment='Specifies the status of the EncryptionAtRestOptions.', null=True)),
                ('log_publishing_options', models.JSONField(blank=True, db_comment='Log publishing options for the given domain.', null=True)),
                ('service_software_options', models.JSONField(blank=True, db_comment="The current status of the Elasticsearch domain's service software.", null=True)),
                ('snapshot_options', models.JSONField(blank=True, db_comment='Specifies the status of the SnapshotOptions.', null=True)),
                ('vpc_options', models.JSONField(blank=True, db_comment='The VPCOptions for the specified domain.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the domain.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_elasticsearch_domain',
                'db_table_comment': 'AWS Elasticsearch Domain',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEmrBlockPublicAccessConfiguration',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('block_public_security_group_rules', models.BooleanField(blank=True, db_comment='Indicates whether Amazon EMR block public access is enabled (true) or disabled (false).', null=True)),
                ('classification', models.TextField(blank=True, db_comment='The classification within a configuration.', null=True)),
                ('created_by_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name that created or last modified the configuration.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The date and time that the configuration was created.', null=True)),
                ('permitted_public_security_group_rule_ranges', models.JSONField(blank=True, db_comment='Specifies ports and port ranges that are permitted to have security group rules that allow inbound traffic from all public sources.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_emr_block_public_access_configuration',
                'db_table_comment': 'AWS EMR Block Public Access Configuration',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEmrCluster',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the cluster.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The unique identifier for the cluster.', primary_key=True, serialize=False)),
                ('cluster_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name of the cluster.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The current state of the cluster.', null=True)),
                ('status', models.JSONField(blank=True, db_comment='The current status details about the cluster.', null=True)),
                ('auto_scaling_role', models.TextField(blank=True, db_comment='An IAM role for automatic scaling policies.', null=True)),
                ('auto_terminate', models.BooleanField(blank=True, db_comment='Specifies whether the cluster should terminate after completing all steps.', null=True)),
                ('custom_ami_id', models.TextField(blank=True, db_comment='Available only in Amazon EMR version 5.7.0 and later. The ID of a custom Amazon EBS-backed Linux AMI if the cluster uses a custom AMI.', null=True)),
                ('ebs_root_volume_size', models.TextField(blank=True, db_comment='The size of the Amazon EBS root device volume of the Linux AMI that is used for each EC2 instance, in GiB. Available in Amazon EMR version 4.x and later.', null=True)),
                ('instance_collection_type', models.TextField(blank=True, db_comment='The instance group configuration of the cluster.', null=True)),
                ('log_encryption_kms_key_id', models.TextField(blank=True, db_comment='The AWS KMS customer master key (CMK) used for encrypting log files. This attribute is only available with EMR version 5.30.0 and later, excluding EMR 6.0.0.', null=True)),
                ('log_uri', models.TextField(blank=True, db_comment='The path to the Amazon S3 location where logs for this cluster are stored.', null=True)),
                ('outpost_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the Outpost where the cluster is launched.', null=True)),
                ('master_public_dns_name', models.TextField(blank=True, db_comment='The DNS name of the master node.', null=True)),
                ('normalized_instance_hours', models.BigIntegerField(blank=True, db_comment='An approximation of the cost of the cluster, represented in m1.small/hours.', null=True)),
                ('release_label', models.TextField(blank=True, db_comment='The Amazon EMR release label, which determines the version of open-source application packages installed on the cluster.', null=True)),
                ('repo_upgrade_on_boot', models.TextField(blank=True, db_comment='Applies only when CustomAmiID is used. Specifies the type of updates that are applied from the Amazon Linux AMI package repositories when an instance boots using the AMI.', null=True)),
                ('requested_ami_version', models.TextField(blank=True, db_comment='Applies only when CustomAmiID is used. Specifies the type of updates that are applied from the Amazon Linux AMI package repositories when an instance boots using the AMI.', null=True)),
                ('running_ami_version', models.TextField(blank=True, db_comment='The AMI version running on this cluster.', null=True)),
                ('scale_down_behavior', models.TextField(blank=True, db_comment='The way that individual Amazon EC2 instances terminate when an automatic scale-in activity occurs or an instance group is resized.', null=True)),
                ('security_configuration', models.TextField(blank=True, db_comment='The name of the security configuration applied to the cluster.', null=True)),
                ('service_role', models.TextField(blank=True, db_comment='The IAM role that will be assumed by the Amazon EMR service to access AWS resources on your behalf.', null=True)),
                ('step_concurrency_level', models.BigIntegerField(blank=True, db_comment='Specifies the number of steps that can be executed concurrently.', null=True)),
                ('termination_protected', models.BooleanField(blank=True, db_comment='Indicates whether Amazon EMR will lock the cluster to prevent the EC2 instances from being terminated by an API call or user intervention, or in the event of a cluster error.', null=True)),
                ('visible_to_all_users', models.BooleanField(blank=True, db_comment='Indicates whether the cluster is visible to all IAM users of the AWS account associated with the cluster.', null=True)),
                ('applications', models.JSONField(blank=True, db_comment='The applications installed on this cluster.', null=True)),
                ('configurations', models.JSONField(blank=True, db_comment='Applies only to Amazon EMR releases 4.x and later. The list of Configurations supplied to the EMR cluster.', null=True)),
                ('ec2_instance_attributes', models.JSONField(blank=True, db_comment='Provides information about the EC2 instances in a cluster grouped by category.', null=True)),
                ('placement_groups', models.JSONField(blank=True, db_comment='Placement group configured for an Amazon EMR cluster.', null=True)),
                ('kerberos_attributes', models.JSONField(blank=True, db_comment='Attributes for Kerberos configuration when Kerberos authentication is enabled using a security configuration.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with a cluster.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_emr_cluster',
                'db_table_comment': 'AWS EMR Cluster',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEmrClusterMetricIsIdle',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The unique identifier for the cluster.', primary_key=True, serialize=False)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_emr_cluster_metric_is_idle',
                'db_table_comment': 'AWS EMR Cluster Cloudwatch Metrics - IsIdle',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEmrInstance',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The unique identifier for the instance in Amazon EMR.', primary_key=True, serialize=False)),
                ('cluster_id', models.TextField(blank=True, db_comment='The unique identifier for the cluster.', null=True)),
                ('ec2_instance_id', models.TextField(blank=True, db_comment='The unique identifier of the instance in Amazon EC2.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The current state of the instance.', null=True)),
                ('instance_fleet_id', models.TextField(blank=True, db_comment='The unique identifier of the instance fleet to which an EC2 instance belongs.', null=True)),
                ('instance_group_id', models.TextField(blank=True, db_comment='The identifier of the instance group to which this instance belongs.', null=True)),
                ('instance_type', models.TextField(blank=True, db_comment='The EC2 instance type, for example m3.xlarge.', null=True)),
                ('market', models.TextField(blank=True, db_comment='The instance purchasing option. Valid values are ON_DEMAND or SPOT.', null=True)),
                ('private_dns_name', models.TextField(blank=True, db_comment='The private DNS name of the instance.', null=True)),
                ('private_ip_address', models.GenericIPAddressField(blank=True, db_comment='The private IP address of the instance.', null=True)),
                ('public_dns_name', models.TextField(blank=True, db_comment='The public DNS name of the instance.', null=True)),
                ('public_ip_address', models.GenericIPAddressField(blank=True, db_comment='The public IP address of the instance.', null=True)),
                ('ebs_volumes', models.JSONField(blank=True, db_comment='The list of Amazon EBS volumes that are attached to this instance.', null=True)),
                ('state_change_reason', models.JSONField(blank=True, db_comment='The status change reason details for the instance.', null=True)),
                ('status_timeline', models.JSONField(blank=True, db_comment='The timeline of the instance status over time.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_emr_instance',
                'db_table_comment': 'AWS EMR Instance',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEmrInstanceFleet',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the instance fleet.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The identifier of the instance fleet.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the instance fleet.', null=True)),
                ('cluster_id', models.TextField(blank=True, db_comment='The unique identifier for the cluster.', null=True)),
                ('instance_fleet_type', models.TextField(blank=True, db_comment='The type of the instance fleet. Valid values are MASTER, CORE or TASK.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The current state of the instance fleet.', null=True)),
                ('provisioned_on_demand_capacity', models.BigIntegerField(blank=True, db_comment='The number of On-Demand units that have been provisioned for the instance fleet to fulfill TargetOnDemandCapacity.', null=True)),
                ('provisioned_spot_capacity', models.BigIntegerField(blank=True, db_comment='The number of Spot units that have been provisioned for this instance fleet to fulfill TargetSpotCapacity.', null=True)),
                ('target_on_demand_capacity', models.BigIntegerField(blank=True, db_comment='The target capacity of On-Demand units for the instance fleet, which determines how many On-Demand Instances to provision.', null=True)),
                ('target_spot_capacity', models.BigIntegerField(blank=True, db_comment='The target capacity of Spot units for the instance fleet, which determines how many Spot Instances to provision.', null=True)),
                ('instance_type_specifications', models.JSONField(blank=True, db_comment='An array of specifications for the instance types that comprise an instance fleet.', null=True)),
                ('launch_specifications', models.JSONField(blank=True, db_comment='Describes the launch specification for an instance fleet.', null=True)),
                ('state_change_reason', models.JSONField(blank=True, db_comment='Provides status change reason details for the instance fleet.', null=True)),
                ('status_timeline', models.JSONField(blank=True, db_comment='Provides historical timestamps for the instance fleet, including the time of creation, the time it became ready to run jobs, and the time of termination.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_emr_instance_fleet',
                'db_table_comment': 'AWS EMR Instance Fleet',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEmrInstanceGroup',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the instance group.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The identifier of the instance group.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the instance group.', null=True)),
                ('cluster_id', models.TextField(blank=True, db_comment='The unique identifier for the cluster.', null=True)),
                ('instance_group_type', models.TextField(blank=True, db_comment='The type of the instance group. Valid values are MASTER, CORE or TASK.', null=True)),
                ('instance_type', models.TextField(blank=True, db_comment='The EC2 instance type for all instances in the instance group.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The current state of the instance group.', null=True)),
                ('bid_price', models.TextField(blank=True, db_comment='The maximum price you are willing to pay for Spot Instances. If specified, indicates that the instance group uses Spot Instances.', null=True)),
                ('configurations_version', models.BigIntegerField(blank=True, db_comment='The version number of the requested configuration specification for this instance group.', null=True)),
                ('ebs_optimized', models.BooleanField(blank=True, db_comment='Indicates whether the instance group is EBS-optimized, or not.  An Amazon EBS-optimized instance uses an optimized configuration stack and provides additional, dedicated capacity for Amazon EBS I/O.', null=True)),
                ('last_successfully_applied_configurations_version', models.BigIntegerField(blank=True, db_comment='The version number of a configuration specification that was successfully applied for an instance group last time.', null=True)),
                ('market', models.TextField(blank=True, db_comment='The marketplace to provision instances for this group. Valid values are ON_DEMAND or SPOT.', null=True)),
                ('requested_instance_count', models.BigIntegerField(blank=True, db_comment='The target number of instances for the instance group.', null=True)),
                ('running_instance_count', models.BigIntegerField(blank=True, db_comment='The number of instances currently running in this instance group.', null=True)),
                ('autoscaling_policy', models.JSONField(blank=True, db_comment='An automatic scaling policy for a core instance group or task instance group in an Amazon EMR cluster.', null=True)),
                ('configurations', models.JSONField(blank=True, db_comment='A list of configurations supplied for an EMR cluster instance group. Only availbale for Amazon EMR releases 4.x or later.', null=True)),
                ('ebs_block_devices', models.JSONField(blank=True, db_comment='The EBS block devices that are mapped to this instance group.', null=True)),
                ('last_successfully_applied_configurations', models.JSONField(blank=True, db_comment='A list of configurations that were successfully applied for an instance group last time.', null=True)),
                ('shrink_policy', models.JSONField(blank=True, db_comment='Policy for customizing shrink operations.', null=True)),
                ('state_change_reason', models.JSONField(blank=True, db_comment='The status change reason details for the instance group.', null=True)),
                ('status_timeline', models.JSONField(blank=True, db_comment='The timeline of the instance group status over time.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_emr_instance_group',
                'db_table_comment': 'AWS EMR Instance Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEmrSecurityConfiguration',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the security configuration.', null=True)),
                ('creation_date_time', models.DateTimeField(blank=True, db_comment='The date and time the security configuration was created.', null=True)),
                ('encryption_configuration', models.JSONField(blank=True, db_comment='The encryption configuration details for a secutiry configuration.', null=True)),
                ('instance_metadata_service_configuration', models.JSONField(blank=True, db_comment='The instance metadata service configuration details for a secutiry configuration.', null=True)),
                ('security_configuration', models.JSONField(blank=True, db_comment='The security configuration details in JSON format.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_emr_security_configuration',
                'db_table_comment': 'AWS EMR Security Configuration',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEventbridgeBus',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the event bus.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the account permitted to write events to the current account.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='The policy that enables the external account to send events to your account.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the policy that enables the external account to send events to your account in a canonical form for easier searching.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the bus.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_eventbridge_bus',
                'db_table_comment': 'AWS EventBridge Bus',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsEventbridgeRule',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the rule.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the rule.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the rule.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The state of the rule.', null=True)),
                ('event_bus_name', models.TextField(blank=True, db_comment='The name or ARN of the event bus associated with the rule.', null=True)),
                ('created_by', models.TextField(blank=True, db_comment='The account ID of the user that created the rule.', null=True)),
                ('managed_by', models.TextField(blank=True, db_comment='If this is a managed rule, created by an AWS service on your behalf, this field displays the principal name of the AWS service that created the rule.', null=True)),
                ('event_pattern', models.JSONField(blank=True, db_comment='The event pattern of the rule.', null=True)),
                ('name_prefix', models.TextField(blank=True, db_comment='Specifying this limits the results to only those event rules with names that start with the specified prefix.', null=True)),
                ('targets', models.JSONField(blank=True, db_comment='The targets assigned to the rule.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the rule.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_eventbridge_rule',
                'db_table_comment': 'AWS EventBridge Rule',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsFsxFileSystem',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('file_system_id', models.TextField(blank=True, db_comment='The system-generated, unique 17-digit ID of the file system.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the EFS file system.', null=True)),
                ('file_system_type', models.TextField(blank=True, db_comment='The type of Amazon FSx file system, which can be LUSTRE, WINDOWS, or ONTAP.', null=True)),
                ('lifecycle', models.TextField(blank=True, db_comment='The lifecycle status of the file system, following are the possible values AVAILABLE, CREATING, DELETING, FAILED, MISCONFIGURED, UPDATING.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The time that the file system was created.', null=True)),
                ('dns_name', models.TextField(blank=True, db_comment='The DNS name for the file system.', null=True)),
                ('file_system_type_version', models.TextField(blank=True, db_comment='The version of your Amazon FSx for Lustre file system, either 2.10 or 2.12.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment="The ID of the Key Management Service (KMS) key used to encrypt the file system's.", null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='The AWS account that created the file system.', null=True)),
                ('storage_capacity', models.BigIntegerField(blank=True, db_comment='The storage capacity of the file system in gibibytes (GiB).', null=True)),
                ('storage_type', models.TextField(blank=True, db_comment='The storage type of the file system.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The ID of the primary VPC for the file system.', null=True)),
                ('administrative_actions', models.JSONField(blank=True, db_comment='A list of administrative actions for the file system that are in process or waiting to be processed.', null=True)),
                ('failure_details', models.JSONField(blank=True, db_comment='A structure providing details of any failures that occur when creating the file system has failed.', null=True)),
                ('lustre_configuration', models.JSONField(blank=True, db_comment='The configuration for the Amazon FSx for Lustre file system.', null=True)),
                ('network_interface_ids', models.JSONField(blank=True, db_comment='The IDs of the elastic network interface from which a specific file system is accessible.', null=True)),
                ('ontap_configuration', models.JSONField(blank=True, db_comment='The configuration for this FSx for NetApp ONTAP file system.', null=True)),
                ('open_zfs_configuration', models.JSONField(blank=True, db_comment='The configuration for this FSx for NetApp ONTAP file system.', null=True)),
                ('subnet_ids', models.JSONField(blank=True, db_comment='Specifies the IDs of the subnets that the file system is accessible from.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with Filesystem.', null=True)),
                ('windows_configuration', models.JSONField(blank=True, db_comment='The configuration for this Microsoft Windows file system.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_fsx_file_system',
                'db_table_comment': 'AWS FSx File System',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGlacierVault',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('vault_name', models.TextField(blank=True, db_comment='The name of the vault.', null=True)),
                ('vault_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the vault.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The Universal Coordinated Time (UTC) date when the vault was created.', null=True)),
                ('last_inventory_date', models.DateTimeField(blank=True, db_comment='The Universal Coordinated Time (UTC) date when Amazon S3 Glacier completed the last vault inventory.', null=True)),
                ('number_of_archives', models.BigIntegerField(blank=True, db_comment='The number of archives in the vault as of the last inventory date.', null=True)),
                ('size_in_bytes', models.BigIntegerField(blank=True, db_comment='Total size, in bytes, of the archives in the vault as of the last inventory date.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='Contains the returned vault access policy as a JSON string.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the policy in a canonical form for easier searching.', null=True)),
                ('vault_lock_policy', models.JSONField(blank=True, db_comment='The vault lock policy.', null=True)),
                ('vault_lock_policy_std', models.JSONField(blank=True, db_comment='Contains the policy in a canonical form for easier searching.', null=True)),
                ('vault_notification_config', models.JSONField(blank=True, db_comment='Contains the notification configuration set on the vault.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with the vault.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_glacier_vault',
                'db_table_comment': 'AWS Glacier Vault',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGlobalacceleratorAccelerator',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the accelerator.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the accelerator.', null=True)),
                ('created_time', models.DateTimeField(blank=True, db_comment='The date and time that the accelerator was created.', null=True)),
                ('dns_name', models.TextField(blank=True, db_comment="The Domain Name System (DNS) name that Global Accelerator creates that points to your accelerator's static IP addresses.", null=True)),
                ('enabled', models.BooleanField(blank=True, db_comment='Indicates whether the accelerator is enabled.', null=True)),
                ('ip_address_type', models.TextField(blank=True, db_comment='The value for the address type must be IPv4.', null=True)),
                ('ip_sets', models.JSONField(blank=True, db_comment='The static IP addresses that Global Accelerator associates with the accelerator.', null=True)),
                ('last_modified_time', models.DateTimeField(blank=True, db_comment='The date and time that the accelerator was last modified.', null=True)),
                ('status', models.TextField(blank=True, db_comment='Describes the deployment status of the accelerator.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with the accelerator.', null=True)),
                ('accelerator_attributes', models.JSONField(blank=True, db_comment='Attributes of the accelerator.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_globalaccelerator_accelerator',
                'db_table_comment': 'AWS Global Accelerator Accelerator',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGlobalacceleratorEndpointGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the endpoint group.', null=True)),
                ('listener_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of parent listener.', null=True)),
                ('endpoint_descriptions', models.JSONField(blank=True, db_comment='The list of endpoint objects.', null=True)),
                ('endpoint_group_region', models.TextField(blank=True, db_comment='The AWS Region where the endpoint group is located.', null=True)),
                ('health_check_interval_seconds', models.BigIntegerField(blank=True, db_comment='The time—10 seconds or 30 seconds—between health checks for each endpoint.', null=True)),
                ('health_check_path', models.TextField(blank=True, db_comment='If the protocol is HTTP/S, then this value provides the ping path that Global Accelerator uses for the destination on the endpoints for health checks.', null=True)),
                ('health_check_port', models.BigIntegerField(blank=True, db_comment='The port that Global Accelerator uses to perform health checks on endpoints that are part of this endpoint group.', null=True)),
                ('health_check_protocol', models.TextField(blank=True, db_comment='The protocol that Global Accelerator uses to perform health checks on endpoints that are part of this endpoint group.', null=True)),
                ('port_overrides', models.JSONField(blank=True, db_comment='Overrides for destination ports used to route traffic to an endpoint.', null=True)),
                ('threshold_count', models.BigIntegerField(blank=True, db_comment='The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy.', null=True)),
                ('traffic_dial_percentage', models.FloatField(blank=True, db_comment='The percentage of traffic to send to an AWS Region.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_globalaccelerator_endpoint_group',
                'db_table_comment': 'AWS Global Accelerator Endpoint Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGlobalacceleratorListener',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the listener.', null=True)),
                ('accelerator_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of parent accelerator.', null=True)),
                ('client_affinity', models.TextField(blank=True, db_comment='Client affinity setting for the listener.', null=True)),
                ('port_ranges', models.JSONField(blank=True, db_comment='The list of port ranges for the connections from clients to the accelerator.', null=True)),
                ('protocol', models.TextField(blank=True, db_comment='The protocol for the connections from clients to the accelerator.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_globalaccelerator_listener',
                'db_table_comment': 'AWS Global Accelerator Listener',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGlueCatalogDatabase',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.', null=True)),
                ('catalog_id', models.TextField(blank=True, db_comment='The ID of the Data Catalog in which the database resides.', null=True)),
                ('create_time', models.DateTimeField(blank=True, db_comment='The time at which the metadata database was created in the catalog.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the database.', null=True)),
                ('location_uri', models.TextField(blank=True, db_comment='The location of the database (for example, an HDFS path).', null=True)),
                ('create_table_default_permissions', models.JSONField(blank=True, db_comment='Creates a set of default permissions on the table for principals.', null=True)),
                ('parameters', models.JSONField(blank=True, db_comment='These key-value pairs define parameters and properties of the database.', null=True)),
                ('target_database', models.JSONField(blank=True, db_comment='A DatabaseIdentifier structure that describes a target database for resource linking.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_glue_catalog_database',
                'db_table_comment': 'AWS Glue Catalog Database',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGlueCatalogTable',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The table name.', null=True)),
                ('catalog_id', models.TextField(blank=True, db_comment='The ID of the Data Catalog in which the table resides.', null=True)),
                ('create_time', models.DateTimeField(blank=True, db_comment='The time when the table definition was created in the data catalog.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the table.', null=True)),
                ('created_by', models.TextField(blank=True, db_comment='The person or entity who created the table.', null=True)),
                ('database_name', models.TextField(blank=True, db_comment='The name of the database where the table metadata resides.', null=True)),
                ('is_registered_with_lake_formation', models.BooleanField(blank=True, db_comment='Indicates whether the table has been registered with lake formation.', null=True)),
                ('last_access_time', models.DateTimeField(blank=True, db_comment='The last time that the table was accessed. This is usually taken from HDFS, and might not be reliable.', null=True)),
                ('last_analyzed_time', models.DateTimeField(blank=True, db_comment='The last time that column statistics were computed for this table.', null=True)),
                ('owner', models.TextField(blank=True, db_comment='The owner of the table.', null=True)),
                ('retention', models.BigIntegerField(blank=True, db_comment='The retention time for this table.', null=True)),
                ('table_type', models.TextField(blank=True, db_comment='The type of this table (EXTERNAL_TABLE, VIRTUAL_VIEW, etc.).', null=True)),
                ('update_time', models.DateTimeField(blank=True, db_comment='The last time that the table was updated.', null=True)),
                ('view_expanded_text', models.TextField(blank=True, db_comment='If the table is a view, the expanded text of the view otherwise null.', null=True)),
                ('view_original_text', models.TextField(blank=True, db_comment='If the table is a view, the original text of the view otherwise null.', null=True)),
                ('parameters', models.JSONField(blank=True, db_comment='These key-value pairs define properties associated with the table.', null=True)),
                ('partition_keys', models.JSONField(blank=True, db_comment='A list of columns by which the table is partitioned.', null=True)),
                ('storage_descriptor', models.JSONField(blank=True, db_comment='A storage descriptor containing information about the physical storage of this table.', null=True)),
                ('target_table', models.JSONField(blank=True, db_comment='A TableIdentifier structure that describes a target table for resource linking.', null=True)),
                ('lf_tags', models.JSONField(blank=True, db_comment='LF-Tags assigned to the table by AWS Lake Formation.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_glue_catalog_table',
                'db_table_comment': 'AWS Glue Catalog Table',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGlueConnection',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the connection definition.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the connection.', null=True)),
                ('connection_type', models.TextField(blank=True, db_comment='The type of the connection. Currently, SFTP is not supported.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The time that this connection definition was created.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the connection.', null=True)),
                ('last_updated_by', models.TextField(blank=True, db_comment='The user, group, or role that last updated this connection definition.', null=True)),
                ('last_updated_time', models.DateTimeField(blank=True, db_comment='The last time that this connection definition was updated.', null=True)),
                ('connection_properties', models.JSONField(blank=True, db_comment='These key-value pairs define parameters for the connection.', null=True)),
                ('match_criteria', models.JSONField(blank=True, db_comment='A list of criteria that can be used in selecting this connection.', null=True)),
                ('physical_connection_requirements', models.JSONField(blank=True, db_comment='A map of physical connection requirements, such as virtual private cloud (VPC) and SecurityGroup, that are needed to make this connection successfully.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_glue_connection',
                'db_table_comment': 'AWS Glue Connection',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGlueCrawler',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the crawler.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the crawler.', null=True)),
                ('database_name', models.TextField(blank=True, db_comment="The name of the database in which the crawler's output is stored.", null=True)),
                ('state', models.TextField(blank=True, db_comment='Indicates whether the crawler is running or pending.', null=True)),
                ('role', models.TextField(blank=True, db_comment="The Amazon Resource Name (ARN) of an IAM role that's used to access customer resources, such as Amazon Simple Storage Service (Amazon S3) data.", null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The time that the crawler was created.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the crawler.', null=True)),
                ('crawl_elapsed_time', models.BigIntegerField(blank=True, db_comment='If the crawler is running, contains the total time elapsed since the last crawl began.', null=True)),
                ('crawler_lineage_settings', models.TextField(blank=True, db_comment='Specifies whether data lineage is enabled for the crawler.', null=True)),
                ('crawler_security_configuration', models.TextField(blank=True, db_comment='The name of the SecurityConfiguration structure to be used by this crawler.', null=True)),
                ('last_updated', models.DateTimeField(blank=True, db_comment='The time that the crawler was last updated.', null=True)),
                ('recrawl_behavior', models.TextField(blank=True, db_comment='Specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run. A value of CRAWL_EVERYTHING specifies crawling the entire dataset again. A value of CRAWL_NEW_FOLDERS_ONLY specifies crawling only folders that were added since the last crawler run. A value of CRAWL_EVENT_MODE specifies crawling only the changes identified by Amazon S3 events.', null=True)),
                ('table_prefix', models.TextField(blank=True, db_comment='The prefix added to the names of tables that are created.', null=True)),
                ('version', models.BigIntegerField(blank=True, db_comment='The version of the crawler.', null=True)),
                ('classifiers', models.JSONField(blank=True, db_comment='A list of UTF-8 strings that specify the custom classifiers that are associated with the crawler.', null=True)),
                ('configuration', models.JSONField(blank=True, db_comment='Crawler configuration information.', null=True)),
                ('last_crawl', models.JSONField(blank=True, db_comment='The status of the last crawl, and potentially error information if an error occurred.', null=True)),
                ('schedule', models.JSONField(blank=True, db_comment='For scheduled crawlers, the schedule when the crawler runs.', null=True)),
                ('schema_change_policy', models.JSONField(blank=True, db_comment='The policy that specifies update and delete behaviors for the crawler.', null=True)),
                ('targets', models.JSONField(blank=True, db_comment='A collection of targets to crawl.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_glue_crawler',
                'db_table_comment': 'AWS Glue Crawler',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGlueDataCatalogEncryptionSettings',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('encryption_at_rest', models.JSONField(blank=True, db_comment='A list of public keys to be used by the DataCatalogEncryptionSettingss for authentication.', null=True)),
                ('connection_password_encryption', models.JSONField(blank=True, db_comment='A list of security group identifiers used in this DataCatalogEncryptionSettings.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_glue_data_catalog_encryption_settings',
                'db_table_comment': 'AWS Glue Data Catalog Encryption Settings',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGlueDataQualityRuleset',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the data quality ruleset.', null=True)),
                ('database_name', models.TextField(blank=True, db_comment='The name of the database where the glue table exists.', null=True)),
                ('table_name', models.TextField(blank=True, db_comment='The name of the glue table.', null=True)),
                ('created_on', models.DateTimeField(blank=True, db_comment='The date and time the data quality ruleset was created.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the data quality ruleset.', null=True)),
                ('last_modified_on', models.DateTimeField(blank=True, db_comment='The date and time the data quality ruleset was last modified.', null=True)),
                ('recommendation_run_id', models.TextField(blank=True, db_comment='When a ruleset was created from a recommendation run, this run ID is generated to link the two together.', null=True)),
                ('rule_count', models.BigIntegerField(blank=True, db_comment='The number of rules in the ruleset.', null=True)),
                ('rule_set', models.TextField(blank=True, db_comment='A Data Quality Definition Language (DQDL) ruleset.', null=True)),
                ('target_table', models.JSONField(blank=True, db_comment='An object representing a glue table.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_glue_data_quality_ruleset',
                'db_table_comment': 'AWS Glue Data Quality Ruleset',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGlueDevEndpoint',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('endpoint_name', models.TextField(blank=True, db_comment='The name of the DevEndpoint.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the DevEndpoint.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current status of this DevEndpoint.', null=True)),
                ('availability_zone', models.TextField(blank=True, db_comment='The AWS Availability Zone where this DevEndpoint is located.', null=True)),
                ('created_timestamp', models.DateTimeField(blank=True, db_comment='The point in time at which this DevEndpoint was created.', null=True)),
                ('extra_jars_s3_path', models.TextField(blank=True, db_comment='The path to one or more Java .jar files in an S3 bucket that should be loaded in your DevEndpoint.', null=True)),
                ('extra_python_libs_s3_path', models.TextField(blank=True, db_comment='The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma.', null=True)),
                ('failure_reason', models.TextField(blank=True, db_comment='The reason for a current failure in this DevEndpoint.', null=True)),
                ('glue_version', models.TextField(blank=True, db_comment='Glue version determines the versions of Apache Spark and Python that Glue supports.', null=True)),
                ('last_modified_timestamp', models.DateTimeField(blank=True, db_comment='The point in time at which this DevEndpoint was last modified.', null=True)),
                ('last_update_status', models.TextField(blank=True, db_comment='The status of the last update.', null=True)),
                ('number_of_nodes', models.BigIntegerField(blank=True, db_comment='The number of Glue Data Processing Units (DPUs) allocated to this DevEndpoint.', null=True)),
                ('number_of_workers', models.BigIntegerField(blank=True, db_comment='The number of workers of a defined workerType that are allocated to the development endpoint.', null=True)),
                ('private_address', models.TextField(blank=True, db_comment='A private IP address to access the DevEndpoint within a VPC if the DevEndpoint is created within one.', null=True)),
                ('public_address', models.TextField(blank=True, db_comment='The public IP address used by this DevEndpoint. The PublicAddress field is present only when you create a non-virtual private cloud (VPC) DevEndpoint.', null=True)),
                ('public_key', models.TextField(blank=True, db_comment='The public key to be used by this DevEndpoint for authentication.', null=True)),
                ('role_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the IAM role used in this DevEndpoint.', null=True)),
                ('security_configuration', models.TextField(blank=True, db_comment='The name of the SecurityConfiguration structure to be used with this DevEndpoint.', null=True)),
                ('subnet_id', models.TextField(blank=True, db_comment='The subnet ID for this DevEndpoint.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The ID of the virtual private cloud (VPC) used by this DevEndpoint.', null=True)),
                ('worker_type', models.TextField(blank=True, db_comment='The type of predefined worker that is allocated to the development endpoint. Accepts a value of Standard, G.1X, or G.2X.', null=True)),
                ('yarn_endpoint_address', models.TextField(blank=True, db_comment='The YARN endpoint address used by this DevEndpoint.', null=True)),
                ('zeppelin_remote_spark_interpreter_port', models.BigIntegerField(blank=True, db_comment='The Apache Zeppelin port for the remote Apache Spark interpreter.', null=True)),
                ('public_keys', models.JSONField(blank=True, db_comment='A list of public keys to be used by the DevEndpoints for authentication.', null=True)),
                ('security_group_ids', models.JSONField(blank=True, db_comment='A list of security group identifiers used in this DevEndpoint.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_glue_dev_endpoint',
                'db_table_comment': 'AWS Glue Dev Endpoint',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGlueJob',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the GlueJob.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the GlueJob.', null=True)),
                ('allocated_capacity', models.FloatField(blank=True, db_comment='[DEPRECATED] This column has been deprecated and will be removed in a future release, use max_capacity instead. The number of Glue data processing units (DPUs) that can be allocated when this job runs.', null=True)),
                ('created_on', models.DateTimeField(blank=True, db_comment='The time and date that this job definition was created.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the job.', null=True)),
                ('glue_version', models.TextField(blank=True, db_comment='Glue version determines the versions of Apache Spark and Python that Glue supports.', null=True)),
                ('last_modified_on', models.DateTimeField(blank=True, db_comment='The last point in time when this job definition was modified.', null=True)),
                ('log_uri', models.TextField(blank=True, db_comment='This field is reserved for future use.', null=True)),
                ('max_capacity', models.FloatField(blank=True, db_comment='The number of Glue data processing units (DPUs) that can be allocated when this job runs.', null=True)),
                ('max_retries', models.BigIntegerField(blank=True, db_comment='The maximum number of times to retry this job after a JobRun fails.', null=True)),
                ('number_of_workers', models.BigIntegerField(blank=True, db_comment='The number of workers of a defined workerType that are allocated when a job runs.', null=True)),
                ('role', models.TextField(blank=True, db_comment='The name or Amazon Resource Name (ARN) of the IAM role associated with this job.', null=True)),
                ('security_configuration', models.TextField(blank=True, db_comment='The name of the SecurityConfiguration structure to be used with this job.', null=True)),
                ('timeout', models.BigIntegerField(blank=True, db_comment='The job timeout in minutes.', null=True)),
                ('worker_type', models.TextField(blank=True, db_comment='The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.', null=True)),
                ('command', models.JSONField(blank=True, db_comment='The JobCommand that runs this job.', null=True)),
                ('connections', models.JSONField(blank=True, db_comment='The connections used for this job.', null=True)),
                ('default_arguments', models.JSONField(blank=True, db_comment='The default arguments for this job, specified as name-value pairs.', null=True)),
                ('execution_property', models.JSONField(blank=True, db_comment='An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.', null=True)),
                ('job_bookmark', models.JSONField(blank=True, db_comment='Defines a point that a job can resume processing.', null=True)),
                ('non_overridable_arguments', models.JSONField(blank=True, db_comment='Non-overridable arguments for this job, specified as name-value pairs.', null=True)),
                ('notification_property', models.JSONField(blank=True, db_comment='Specifies configuration properties of a job notification.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_glue_job',
                'db_table_comment': 'AWS Glue Job',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGlueSecurityConfiguration',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the security configuration.', null=True)),
                ('created_time_stamp', models.DateTimeField(blank=True, db_comment='The time at which this security configuration was created.', null=True)),
                ('cloud_watch_encryption', models.JSONField(blank=True, db_comment='The encryption configuration for Amazon CloudWatch.', null=True)),
                ('job_bookmarks_encryption', models.JSONField(blank=True, db_comment='The encryption configuration for job bookmarks.', null=True)),
                ('s3_encryption', models.JSONField(blank=True, db_comment='The encryption configuration for Amazon Simple Storage Service (Amazon S3) data.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_glue_security_configuration',
                'db_table_comment': 'AWS Glue Security Configuration',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGuarddutyDetector',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('detector_id', models.TextField(blank=True, db_comment='The ID of the detector.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the detector.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The detector status.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The timestamp of when the detector was created.', null=True)),
                ('finding_publishing_frequency', models.TextField(blank=True, db_comment='The publishing frequency of the finding.', null=True)),
                ('service_role', models.TextField(blank=True, db_comment='The GuardDuty service role.', null=True)),
                ('updated_at', models.DateTimeField(blank=True, db_comment='The last-updated timestamp for the detector.', null=True)),
                ('data_sources', models.JSONField(blank=True, db_comment='Describes which data sources are enabled for the detector.', null=True)),
                ('features', models.JSONField(blank=True, db_comment='Describes the features that have been enabled for the detector.', null=True)),
                ('master_account', models.JSONField(blank=True, db_comment='Contains information about the administrator account and invitation.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_guardduty_detector',
                'db_table_comment': 'AWS GuardDuty Detector',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGuarddutyFilter',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name for the filter.', null=True)),
                ('detector_id', models.TextField(blank=True, db_comment='The ID of the detector.', null=True)),
                ('action', models.TextField(blank=True, db_comment='Specifies the action that is to be applied to the findings that match the filter.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the filter.', null=True)),
                ('rank', models.BigIntegerField(blank=True, db_comment='Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.', null=True)),
                ('finding_criteria', models.JSONField(blank=True, db_comment='Represents the criteria to be used in the filter for querying findings.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_guardduty_filter',
                'db_table_comment': 'AWS GuardDuty Filter',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGuarddutyFinding',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The title of the finding.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The ID of the finding.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the finding.', null=True)),
                ('detector_id', models.TextField(blank=True, db_comment='The ID of the detector.', null=True)),
                ('severity', models.FloatField(blank=True, db_comment='The severity of the finding.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The time and date when the finding was created.', null=True)),
                ('confidence', models.FloatField(blank=True, db_comment='The confidence score for the finding.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the finding.', null=True)),
                ('schema_version', models.TextField(blank=True, db_comment='The version of the schema used for the finding.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of finding.', null=True)),
                ('updated_at', models.DateTimeField(blank=True, db_comment='The time and date when the finding was last updated.', null=True)),
                ('resource', models.JSONField(blank=True, db_comment='Contains information about the AWS resource associated with the activity that prompted GuardDuty to generate a finding.', null=True)),
                ('service', models.JSONField(blank=True, db_comment='Contains additional information about the generated finding.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_guardduty_finding',
                'db_table_comment': 'AWS GuardDuty Finding',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGuarddutyIpset',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name for the IPSet.', null=True)),
                ('detector_id', models.TextField(blank=True, db_comment='The ID of the detector.', null=True)),
                ('ipset_id', models.TextField(blank=True, db_comment='The ID of the IPSet.', null=True)),
                ('format', models.TextField(blank=True, db_comment='The format of the file that contains the IPSet.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of IPSet.', null=True)),
                ('location', models.TextField(blank=True, db_comment='The URI of the file that contains the IPSet.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_guardduty_ipset',
                'db_table_comment': 'AWS GuardDuty IPSet',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGuarddutyMember',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('member_account_id', models.TextField(blank=True, db_comment='The ID of the member account.', null=True)),
                ('detector_id', models.TextField(blank=True, db_comment='The detector ID of the member account.', null=True)),
                ('master_id', models.TextField(blank=True, db_comment='The administrator account ID.', null=True)),
                ('email', models.TextField(blank=True, db_comment='The email address of the member account.', null=True)),
                ('invited_at', models.DateTimeField(blank=True, db_comment='The timestamp when the invitation was sent.', null=True)),
                ('relationship_status', models.TextField(blank=True, db_comment='The status of the relationship between the member and the administrator.', null=True)),
                ('updated_at', models.DateTimeField(blank=True, db_comment='The last-updated timestamp of the member.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_guardduty_member',
                'db_table_comment': 'AWS GuardDuty Member',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGuarddutyPublishingDestination',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('destination_id', models.TextField(blank=True, db_comment='The ID of the publishing destination.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the publishing destination.', null=True)),
                ('detector_id', models.TextField(blank=True, db_comment='The ID of the detector.', null=True)),
                ('destination_arn', models.TextField(blank=True, db_comment='The ARN of the resource to publish to.', null=True)),
                ('destination_type', models.TextField(blank=True, db_comment='The type of publishing destination. Currently, only Amazon S3 buckets are supported.', null=True)),
                ('kms_key_arn', models.TextField(blank=True, db_comment='The ARN of the KMS key to use for encryption.', null=True)),
                ('publishing_failure_start_timestamp', models.DateTimeField(blank=True, db_comment='The time, in epoch millisecond format, at which GuardDuty was first unable to publish findings to the destination.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the publishing destination.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_guardduty_publishing_destination',
                'db_table_comment': 'AWS GuardDuty Publishing Destination',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsGuarddutyThreatIntelSet',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='A ThreatIntelSet name displayed in all findings that are generated by activity that involves IP addresses included in this ThreatIntelSet.', null=True)),
                ('threat_intel_set_id', models.TextField(blank=True, db_comment='The ID of the ThreatIntelSet.', null=True)),
                ('detector_id', models.TextField(blank=True, db_comment='The ID of the detector.', null=True)),
                ('format', models.TextField(blank=True, db_comment='The format of the threatIntelSet.', null=True)),
                ('location', models.TextField(blank=True, db_comment='The URI of the file that contains the ThreatIntelSet.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of threatIntelSet file uploaded.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_guardduty_threat_intel_set',
                'db_table_comment': 'AWS GuardDuty ThreatIntelSet',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsHealthAffectedEntity',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the health entity.', null=True)),
                ('entity_url', models.TextField(blank=True, db_comment='The URL of the affected entity.', null=True)),
                ('entity_value', models.TextField(blank=True, db_comment='The ID of the affected entity.', null=True)),
                ('event_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the health event.', null=True)),
                ('last_updated_time', models.DateTimeField(blank=True, db_comment='The most recent time that the entity was updated.', null=True)),
                ('status_code', models.TextField(blank=True, db_comment='The most recent status of the entity affected by the event. The possible values are IMPAIRED, UNIMPAIRED, and UNKNOWN.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_health_affected_entity',
                'db_table_comment': 'AWS Health Affected Entity',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIamAccessKey',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('access_key_id', models.TextField(blank=True, db_comment='The ID for this access key.', null=True)),
                ('user_name', models.TextField(blank=True, db_comment='The name of the IAM user that the key is associated with.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the access key. Active means that the key is valid for API calls; Inactive means it is not.', null=True)),
                ('create_date', models.DateTimeField(blank=True, db_comment='The date when the access key was created.', null=True)),
                ('access_key_last_used_date', models.DateTimeField(blank=True, db_comment='The date when the access key was last used.', null=True)),
                ('access_key_last_used_service', models.TextField(blank=True, db_comment='The service last used by the access key.', null=True)),
                ('access_key_last_used_region', models.TextField(blank=True, db_comment='The region in which the access key was last used.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iam_access_key',
                'db_table_comment': 'AWS IAM User Access Key',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIamAccountPasswordPolicy',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('allow_users_to_change_password', models.BooleanField(blank=True, db_comment='Specifies whether IAM users are allowed to change their own password.', null=True)),
                ('expire_passwords', models.BooleanField(blank=True, db_comment='Indicates whether passwords in the account expire. Returns true if MaxPasswordAge contains a value greater than 0. Returns false if MaxPasswordAge is 0 or not present.', null=True)),
                ('hard_expiry', models.BooleanField(blank=True, db_comment='Specifies whether IAM users are prevented from setting a new password after.', null=True)),
                ('max_password_age', models.BigIntegerField(blank=True, db_comment='The number of days that an IAM user password is valid.', null=True)),
                ('minimum_password_length', models.BigIntegerField(blank=True, db_comment='Minimum length to require for IAM user passwords.', null=True)),
                ('password_reuse_prevention', models.BigIntegerField(blank=True, db_comment='Specifies the number of previous passwords that IAM users are prevented from reusing.', null=True)),
                ('require_lowercase_characters', models.BooleanField(blank=True, db_comment='Specifies whether to require lowercase characters for IAM user passwords.', null=True)),
                ('require_numbers', models.BooleanField(blank=True, db_comment='Specifies whether to require numbers for IAM user passwords.', null=True)),
                ('require_symbols', models.BooleanField(blank=True, db_comment='Specifies whether to require symbols for IAM user passwords.', null=True)),
                ('require_uppercase_characters', models.BooleanField(blank=True, db_comment='Specifies whether to require uppercase characters for IAM user passwords.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iam_account_password_policy',
                'db_table_comment': 'AWS IAM Account Password Policy',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIamAccountSummary',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('access_keys_per_user_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed quota of access keys per user.', null=True)),
                ('account_access_keys_present', models.BigIntegerField(blank=True, db_comment='Specifies the number of account level access keys present.', null=True)),
                ('account_mfa_enabled', models.BooleanField(blank=True, db_comment='Specifies whether MFA is enabled for the account.', null=True)),
                ('account_signing_certificates_present', models.BigIntegerField(blank=True, db_comment='Specifies the number of account signing certificates present.', null=True)),
                ('assume_role_policy_size_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed assume role policy size.', null=True)),
                ('attached_policies_per_group_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed attached policies per group.', null=True)),
                ('attached_policies_per_role_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed attached policies per role.', null=True)),
                ('attached_policies_per_user_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed attached policies per user.', null=True)),
                ('global_endpoint_token_version', models.BigIntegerField(blank=True, db_comment='Specifies the token version of the global endpoint.', null=True)),
                ('group_policy_size_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed group policy size.', null=True)),
                ('groups', models.BigIntegerField(blank=True, db_comment='Specifies the number of groups.', null=True)),
                ('groups_per_user_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed number of groups.', null=True)),
                ('groups_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed number of groups.', null=True)),
                ('instance_profiles', models.BigIntegerField(blank=True, db_comment='Specifies the number of groups.', null=True)),
                ('instance_profiles_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed number of groups.', null=True)),
                ('mfa_devices', models.BigIntegerField(blank=True, db_comment='Specifies the number of MFA devices.', null=True)),
                ('mfa_devices_in_use', models.BigIntegerField(blank=True, db_comment='Specifies the number of MFA devices in use.', null=True)),
                ('policies', models.BigIntegerField(blank=True, db_comment='Specifies the number of policies.', null=True)),
                ('policies_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed number of policies.', null=True)),
                ('policy_size_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed size of policies.', null=True)),
                ('policy_versions_in_use', models.BigIntegerField(blank=True, db_comment='Specifies the number of policy versions in use.', null=True)),
                ('policy_versions_in_use_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed number of policy versions.', null=True)),
                ('providers', models.BigIntegerField(blank=True, db_comment='Specifies the number of providers.', null=True)),
                ('role_policy_size_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed role policy size.', null=True)),
                ('roles', models.BigIntegerField(blank=True, db_comment='Specifies the number of roles.', null=True)),
                ('roles_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed number of roles.', null=True)),
                ('server_certificates', models.BigIntegerField(blank=True, db_comment='Specifies the number of server certificates.', null=True)),
                ('server_certificates_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed number of server certificates.', null=True)),
                ('signing_certificates_per_user_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed number of signing certificates per user.', null=True)),
                ('user_policy_size_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed user policy size.', null=True)),
                ('users', models.BigIntegerField(blank=True, db_comment='Specifies the number of users.', null=True)),
                ('users_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed number of users.', null=True)),
                ('versions_per_policy_quota', models.BigIntegerField(blank=True, db_comment='Specifies the allowed number of versions per policy.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iam_account_summary',
                'db_table_comment': 'AWS IAM Account Summary',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIamAction',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('action', models.TextField(blank=True, db_comment='The action for this permission.', null=True)),
                ('prefix', models.TextField(blank=True, db_comment='The prefix for this action.', null=True)),
                ('privilege', models.TextField(blank=True, db_comment='The privilege for this action.', null=True)),
                ('access_level', models.TextField(blank=True, db_comment='The access level for this action.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description for this action.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iam_action',
                'db_table_comment': 'AWS IAM Action',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIamGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The friendly name that identifies the group.', null=True)),
                ('group_id', models.TextField(blank=True, db_comment='The stable and unique string identifying the group.', null=True)),
                ('path', models.TextField(blank=True, db_comment='The path to the group.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the group.', null=True)),
                ('create_date', models.DateTimeField(blank=True, db_comment='The date and time, when the group was created.', null=True)),
                ('inline_policies', models.JSONField(blank=True, db_comment='A list of policy documents that are embedded as inline policies for the group.', null=True)),
                ('inline_policies_std', models.JSONField(blank=True, db_comment='Inline policies in canonical form for the group.', null=True)),
                ('attached_policy_arns', models.JSONField(blank=True, db_comment='A list of managed policies attached to the group.', null=True)),
                ('users', models.JSONField(blank=True, db_comment='A list of users in the group.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iam_group',
                'db_table_comment': 'AWS IAM Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIamOpenIdConnectProvider',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the OIDC provider resource.', null=True)),
                ('client_id_list', models.JSONField(blank=True, db_comment='A list of client IDs (also known as audiences) that are associated with the specified IAM OIDC provider resource object.', null=True)),
                ('create_date', models.DateTimeField(blank=True, db_comment='The date and time when the IAM OIDC provider resource object was created in the Amazon Web Services account.', null=True)),
                ('thumbprint_list', models.JSONField(blank=True, db_comment='A list of certificate thumbprints that are associated with the specified IAM OIDC provider resource object.', null=True)),
                ('url', models.TextField(blank=True, db_comment='The URL that the IAM OIDC provider resource object is associated with.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are attached to the specified IAM OIDC provider.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iam_open_id_connect_provider',
                'db_table_comment': 'AWS IAM OpenID Connect Provider',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIamPolicy',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The friendly name that identifies the iam policy.', null=True)),
                ('policy_id', models.TextField(blank=True, db_comment='The stable and unique string identifying the policy.', null=True)),
                ('path', models.TextField(blank=True, db_comment='The path to the policy.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the iam policy.', null=True)),
                ('is_aws_managed', models.BooleanField(blank=True, db_comment='Specifies whether the policy is AWS Managed or Customer Managed. If true policy is aws managed otherwise customer managed.', null=True)),
                ('is_attachable', models.BooleanField(blank=True, db_comment='Specifies whether the policy can be attached to an IAM user, group, or role.', null=True)),
                ('create_date', models.DateTimeField(blank=True, db_comment='The date and time, when the policy was created.', null=True)),
                ('update_date', models.DateTimeField(blank=True, db_comment='The date and time, when the policy was last updated.', null=True)),
                ('attachment_count', models.BigIntegerField(blank=True, db_comment='The number of entities (users, groups, and roles) that the policy is attached to.', null=True)),
                ('is_attached', models.BooleanField(blank=True, db_comment='Specifies whether the policy is attached to at least one IAM user, group, or role.', null=True)),
                ('default_version_id', models.TextField(blank=True, db_comment='The identifier for the version of the policy that is set as the default version.', null=True)),
                ('permissions_boundary_usage_count', models.BigIntegerField(blank=True, db_comment='The number of entities (users and roles) for which the policy is used to set the permissions boundary.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='Contains the details about the policy.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the policy in a canonical form for easier searching.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached with the IAM policy.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iam_policy',
                'db_table_comment': 'AWS IAM Policy',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIamPolicyAttachment',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('policy_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the IAM policy.', null=True)),
                ('is_attached', models.BooleanField(blank=True, db_comment='Specifies whether the policy is attached to at least one IAM user, group, or role.', null=True)),
                ('policy_groups', models.JSONField(blank=True, db_comment='A list of IAM groups that the policy is attached to.', null=True)),
                ('policy_roles', models.JSONField(blank=True, db_comment='A list of IAM roles that the policy is attached to.', null=True)),
                ('policy_users', models.JSONField(blank=True, db_comment='A list of IAM users that the policy is attached to.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iam_policy_attachment',
                'db_table_comment': 'AWS IAM Policy Attachment',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIamRole',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The friendly name that identifies the role.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the role.', null=True)),
                ('role_id', models.TextField(blank=True, db_comment='The stable and unique string identifying the role.', null=True)),
                ('create_date', models.DateTimeField(blank=True, db_comment='The date and time when the role was created.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A user-provided description of the role.', null=True)),
                ('instance_profile_arns', models.JSONField(blank=True, db_comment='A list of instance profiles associated with the role.', null=True)),
                ('max_session_duration', models.BigIntegerField(blank=True, db_comment='The maximum session duration (in seconds) for the specified role. Anyone who uses the AWS CLI, or API to assume the role can specify the duration using the optional DurationSeconds API parameter or duration-seconds CLI parameter.', null=True)),
                ('path', models.TextField(blank=True, db_comment='The path to the role.', null=True)),
                ('permissions_boundary_arn', models.TextField(blank=True, db_comment='The ARN of the policy used to set the permissions boundary for the role.', null=True)),
                ('permissions_boundary_type', models.TextField(blank=True, db_comment='The permissions boundary usage type that indicates what type of IAM resource is used as the permissions boundary for an entity. This data type can only have a value of Policy.', null=True)),
                ('role_last_used_date', models.DateTimeField(blank=True, db_comment='Contains information about the last time that an IAM role was used. Activity is only reported for the trailing 400 days. This period can be shorter if your Region began supporting these features within the last year. The role might have been used more than 400 days ago.', null=True)),
                ('role_last_used_region', models.TextField(blank=True, db_comment='Contains the region in which the IAM role was used.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are attached to the role.', null=True)),
                ('inline_policies', models.JSONField(blank=True, db_comment='A list of policy documents that are embedded as inline policies for the role..', null=True)),
                ('inline_policies_std', models.JSONField(blank=True, db_comment='Inline policies in canonical form for the role.', null=True)),
                ('attached_policy_arns', models.JSONField(blank=True, db_comment='A list of managed policies attached to the role.', null=True)),
                ('assume_role_policy', models.JSONField(blank=True, db_comment='The policy that grants an entity permission to assume the role.', null=True)),
                ('assume_role_policy_std', models.JSONField(blank=True, db_comment='Contains the assume role policy in a canonical form for easier searching.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iam_role',
                'db_table_comment': 'AWS IAM Role',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIamSamlProvider',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the IAM policy.', null=True)),
                ('create_date', models.DateTimeField(blank=True, db_comment='The date and time when the SAML provider was created.', null=True)),
                ('valid_until', models.DateTimeField(blank=True, db_comment='The expiration date and time for the SAML provider.', null=True)),
                ('saml_metadata_document', models.TextField(blank=True, db_comment='The XML metadata document that includes information about an identity provider.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are attached to the specified IAM SAML provider.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iam_saml_provider',
                'db_table_comment': 'AWS IAM Saml Provider',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIamServerCertificate',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name that identifies the server certificate.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the server certificate.', null=True)),
                ('server_certificate_id', models.TextField(blank=True, db_comment='The stable and unique string identifying the server certificate.', null=True)),
                ('expiration', models.DateTimeField(blank=True, db_comment='The date on which the certificate is set to expire.', null=True)),
                ('certificate_body', models.TextField(blank=True, db_comment='The contents of the public key certificate.', null=True)),
                ('certificate_chain', models.TextField(blank=True, db_comment='The contents of the public key certificate chain.', null=True)),
                ('path', models.TextField(blank=True, db_comment='The path to the server certificate.', null=True)),
                ('upload_date', models.DateTimeField(blank=True, db_comment='The Amazon Resource Name (ARN) of the account that is designated as the management account for the organization', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached with the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iam_server_certificate',
                'db_table_comment': 'AWS IAM Server Certificate',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIamServiceSpecificCredential',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('service_name', models.TextField(blank=True, db_comment='The name of the service associated with the service-specific credential.', null=True)),
                ('service_specific_credential_id', models.TextField(blank=True, db_comment='The unique identifier for the service-specific credential.', null=True)),
                ('create_date', models.DateTimeField(blank=True, db_comment='The date and time, in ISO 8601 date-time format (http://www.iso.org/iso/iso8601), when the service-specific credential were created.', null=True)),
                ('service_user_name', models.TextField(blank=True, db_comment='The generated user name for the service-specific credential.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the service-specific credential. Active means that the key is valid for API calls, while Inactive means it is not.', null=True)),
                ('user_name', models.TextField(blank=True, db_comment='The name of the IAM user associated with the service-specific credential.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iam_service_specific_credential',
                'db_table_comment': 'AWS IAM User Service Specific Credential',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIamUser',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The friendly name identifying the user.', null=True)),
                ('user_id', models.TextField(blank=True, db_comment='The stable and unique string identifying the user.', null=True)),
                ('path', models.TextField(blank=True, db_comment='The path to the user.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that identifies the user.', null=True)),
                ('create_date', models.DateTimeField(blank=True, db_comment='The date and time, when the user was created.', null=True)),
                ('password_last_used', models.DateTimeField(blank=True, db_comment="The date and time, when the user's password was last used to sign in to an AWS website.", null=True)),
                ('permissions_boundary_arn', models.TextField(blank=True, db_comment='The ARN of the policy used to set the permissions boundary for the user.', null=True)),
                ('permissions_boundary_type', models.TextField(blank=True, db_comment='The permissions boundary usage type that indicates what type of IAM resource is used as the permissions boundary for an entity. This data type can only have a value of Policy.', null=True)),
                ('mfa_enabled', models.BooleanField(blank=True, db_comment='The MFA status of the user.', null=True)),
                ('login_profile', models.JSONField(blank=True, db_comment='Contains the user name and password create date for a user.', null=True)),
                ('mfa_devices', models.JSONField(blank=True, db_comment='A list of MFA devices attached to the user.', null=True)),
                ('groups', models.JSONField(blank=True, db_comment='A list of groups attached to the user.', null=True)),
                ('inline_policies', models.JSONField(blank=True, db_comment='A list of policy documents that are embedded as inline policies for the user.', null=True)),
                ('inline_policies_std', models.JSONField(blank=True, db_comment='Inline policies in canonical form for the user.', null=True)),
                ('attached_policy_arns', models.JSONField(blank=True, db_comment='A list of managed policies attached to the user.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are attached to the user.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iam_user',
                'db_table_comment': 'AWS IAM User',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIamVirtualMfaDevice',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('serial_number', models.TextField(blank=True, db_comment='The serial number associated with VirtualMFADevice.', null=True)),
                ('enable_date', models.DateTimeField(blank=True, db_comment='The date and time on which the virtual MFA device was enabled.', null=True)),
                ('assignment_status', models.TextField(blank=True, db_comment='The status (Unassigned or Assigned) of the device.', null=True)),
                ('user_id', models.TextField(blank=True, db_comment='The user id of the user associated with this virtual MFA device.', null=True)),
                ('user_name', models.TextField(blank=True, db_comment='The friendly name of the user associated with this virtual MFA device.', null=True)),
                ('user', models.JSONField(blank=True, db_comment='Details of the IAM user associated with this virtual MFA device.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached with the MFA device.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iam_virtual_mfa_device',
                'db_table_comment': 'AWS IAM Virtual MFA device',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsInspector2Coverage',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('source_account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('resource_id', models.TextField(blank=True, db_comment='The ID of the covered resource.', null=True)),
                ('resource_type', models.TextField(blank=True, db_comment='The type of the covered resource.', null=True)),
                ('scan_type', models.TextField(blank=True, db_comment='The Amazon Inspector scan type covering the resource.', null=True)),
                ('ec2_ami_id', models.TextField(blank=True, db_comment='The ID of the Amazon Machine Image (AMI) used to launch the instance.', null=True)),
                ('ecr_image_tag', models.TextField(blank=True, db_comment='Tags associated with the Amazon ECR image metadata.', null=True)),
                ('ecr_repository_name', models.TextField(blank=True, db_comment='The name of the Amazon ECR repository.', null=True)),
                ('ecr_repository_scan_frequency', models.TextField(blank=True, db_comment='The frequency of scans for an object that contains details about the repository an Amazon ECR image resides in.', null=True)),
                ('lambda_function_name', models.TextField(blank=True, db_comment='The name of a function.', null=True)),
                ('lambda_function_runtime', models.TextField(blank=True, db_comment="An AWS Lambda function's runtime.", null=True)),
                ('scan_status_reason', models.TextField(blank=True, db_comment='The reason for the scan.', null=True)),
                ('scan_status_code', models.TextField(blank=True, db_comment='The status code of the scan.', null=True)),
                ('ec2_platform', models.JSONField(blank=True, db_comment='The platform of the instance.', null=True)),
                ('ec2_instance_tags', models.JSONField(blank=True, db_comment='The tags attached to the instance.', null=True)),
                ('ecr_image_tags', models.JSONField(blank=True, db_comment='Tags associated with the Amazon ECR image metadata.', null=True)),
                ('lambda_function_tags', models.JSONField(blank=True, db_comment='The resource tags on an AWS Lambda function.', null=True)),
                ('lambda_function_layers', models.JSONField(blank=True, db_comment='The layers for an AWS Lambda function. A Lambda function can have up to five layers.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_inspector2_coverage',
                'db_table_comment': 'AWS Inspector2 Coverage',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsInspector2CoverageStatistics',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('total_counts', models.BigIntegerField(blank=True, db_comment='The total number for all groups', null=True)),
                ('counts_by_group', models.JSONField(blank=True, db_comment='An array with the number for each group', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_inspector2_coverage_statistics',
                'db_table_comment': 'AWS Inspector2 Coverage Statistics',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsInspector2Finding',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('finding_account_id', models.TextField(blank=True, db_comment='The Amazon Web Services account ID associated with the finding.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the finding.', null=True)),
                ('exploit_available', models.TextField(blank=True, db_comment='If a finding discovered in your environment has an exploit available. Valid values are: YES | NO.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Number (ARN) of the finding.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the finding. Valid values are: ACTIVE | SUPPRESSED | CLOSED.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of the finding. Valid values are: NETWORK_REACHABILITY | PACKAGE_VULNERABILITY.', null=True)),
                ('first_observed_at', models.DateTimeField(blank=True, db_comment='The date and time that the finding was first observed.', null=True)),
                ('fix_available', models.TextField(blank=True, db_comment='Details on whether a fix is available through a version update. Valid values are: YES | NO | PARTIAL.', null=True)),
                ('inspector_score', models.FloatField(blank=True, db_comment='The Amazon Inspector score given to the finding.', null=True)),
                ('resource_id', models.TextField(blank=True, db_comment='The ID of the resource.', null=True)),
                ('resource_type', models.TextField(blank=True, db_comment='The resource type supported by AWS.', null=True)),
                ('component_type', models.TextField(blank=True, db_comment='The component type.', null=True)),
                ('component_id', models.TextField(blank=True, db_comment='The component ID of the resource.', null=True)),
                ('ec2_instance_image_id', models.TextField(blank=True, db_comment='The Amazon EC2 instance image ID.', null=True)),
                ('ec2_instance_subnet_id', models.TextField(blank=True, db_comment='The Amazon EC2 instance subnet ID.', null=True)),
                ('ec2_instance_vpc_id', models.TextField(blank=True, db_comment='The Amazon EC2 instance VPC ID.', null=True)),
                ('ecr_image_architecture', models.TextField(blank=True, db_comment='The Amazon ECR image architecture.', null=True)),
                ('ecr_image_hash', models.TextField(blank=True, db_comment='The Amazon ECR image hash.', null=True)),
                ('ecr_image_pushed_at', models.DateTimeField(blank=True, db_comment='The Amazon ECR image push date and time.', null=True)),
                ('ecr_image_registry', models.TextField(blank=True, db_comment='The Amazon ECR registry.', null=True)),
                ('ecr_image_repository_name', models.TextField(blank=True, db_comment='The name of the Amazon ECR repository.', null=True)),
                ('ecr_image_tags', models.TextField(blank=True, db_comment='The tags attached to the Amazon ECR container image.', null=True)),
                ('lambda_function_execution_role_arn', models.TextField(blank=True, db_comment='The AWS Lambda function execution role ARN.', null=True)),
                ('lambda_function_last_modified_at', models.DateTimeField(blank=True, db_comment='The AWS Lambda functions the date and time that a user last updated the configuration.', null=True)),
                ('lambda_function_layers', models.TextField(blank=True, db_comment='The AWS Lambda function layer.', null=True)),
                ('lambda_function_name', models.TextField(blank=True, db_comment='The AWS Lambda function name.', null=True)),
                ('lambda_function_runtime', models.TextField(blank=True, db_comment='The AWS Lambda function runtime environment.', null=True)),
                ('network_protocol', models.TextField(blank=True, db_comment='The ingress source addresse.', null=True)),
                ('related_vulnerabilitie', models.TextField(blank=True, db_comment='The related vulnerabilitie.', null=True)),
                ('last_observed_at', models.DateTimeField(blank=True, db_comment='The date and time that the finding was last observed.', null=True)),
                ('remediation_recommendation_text', models.TextField(blank=True, db_comment='The recommended course of action to remediate the finding.', null=True)),
                ('remediation_recommendation_url', models.TextField(blank=True, db_comment='The URL address to the CVE remediation recommendations.', null=True)),
                ('severity', models.TextField(blank=True, db_comment='The severity of the finding. Valid values are: INFORMATIONAL | LOW | MEDIUM | HIGH | CRITICAL | UNTRIAGED.', null=True)),
                ('updated_at', models.DateTimeField(blank=True, db_comment='The date and time the finding was last updated at.', null=True)),
                ('source', models.TextField(blank=True, db_comment='The source of the vulnerability information.', null=True)),
                ('source_url', models.TextField(blank=True, db_comment='A URL to the source of the vulnerability information.', null=True)),
                ('vendor_created_at', models.DateTimeField(blank=True, db_comment='The date and time that this vulnerability was first added to the vendor’s database.', null=True)),
                ('vendor_severity', models.TextField(blank=True, db_comment='The severity the vendor has given to this vulnerability type.', null=True)),
                ('vendor_updated_at', models.DateTimeField(blank=True, db_comment='The date and time the vendor last updated this vulnerability in their database.', null=True)),
                ('vulnerability_id', models.TextField(blank=True, db_comment='The ID given to this vulnerability.', null=True)),
                ('exploitability_details', models.JSONField(blank=True, db_comment='The details of an exploit available for a finding discovered in your environment.', null=True)),
                ('inspector_score_details', models.JSONField(blank=True, db_comment='An object that contains details of the Amazon Inspector score.', null=True)),
                ('network_reachability_details', models.JSONField(blank=True, db_comment='An object that contains the details of a network reachability finding.', null=True)),
                ('package_vulnerability_details', models.JSONField(blank=True, db_comment='An object that contains the details of a package vulnerability finding.', null=True)),
                ('cvss', models.JSONField(blank=True, db_comment='An object that contains details about the CVSS score of a finding.', null=True)),
                ('reference_urls', models.JSONField(blank=True, db_comment='One or more URLs that contain details about this vulnerability type.', null=True)),
                ('related_vulnerabilities', models.JSONField(blank=True, db_comment='One or more vulnerabilities related to the one identified in this finding.', null=True)),
                ('vulnerable_package', models.JSONField(blank=True, db_comment='The package impacted by this vulnerability.', null=True)),
                ('vulnerable_packages', models.JSONField(blank=True, db_comment='The packages impacted by this vulnerability.', null=True)),
                ('resources', models.JSONField(blank=True, db_comment='Contains information on the resources involved in a finding.', null=True)),
                ('resource_tags', models.JSONField(blank=True, db_comment='Details on the resource tags used to filter findings.', null=True)),
                ('title', models.TextField(blank=True, db_comment='The title of the finding.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_inspector2_finding',
                'db_table_comment': 'AWS Inspector2 Finding',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsInspector2Member',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('member_account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('delegated_admin_account_id', models.TextField(blank=True, db_comment='The Amazon Web Services account ID of the Amazon Inspector delegated administrator for this member account.', null=True)),
                ('only_associated', models.TextField(blank=True, db_comment='Specifies whether to list only currently associated members if True or to list all members within the organization if False.', null=True)),
                ('relationship_status', models.TextField(blank=True, db_comment='The status of the member account. Valid values are: CREATED | INVITED | DISABLED | ENABLED | REMOVED | RESIGNED | DELETED | EMAIL_VERIFICATION_IN_PROGRESS | EMAIL_VERIFICATION_FAILED | REGION_DISABLED | ACCOUNT_SUSPENDED | CANNOT_CREATE_DETECTOR_IN_ORG_MASTER.', null=True)),
                ('updated_at', models.DateTimeField(blank=True, db_comment='A timestamp showing when the status of this member was last updated.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_inspector2_member',
                'db_table_comment': 'AWS Inspector2 Member',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsInspectorAssessmentRun',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The auto-generated name for the assessment run.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the assessment run.', null=True)),
                ('assessment_template_arn', models.TextField(blank=True, db_comment='The ARN of the assessment template that is associated with the assessment run.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The state of the assessment run.', null=True)),
                ('completed_at', models.DateTimeField(blank=True, db_comment='The assessment run completion time that corresponds to the rules packages evaluation completion time or failure.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The time when StartAssessmentRun was called.', null=True)),
                ('data_collected', models.BooleanField(blank=True, db_comment='Boolean value (true or false) that specifies whether the process of collecting data from the agents is completed.', null=True)),
                ('duration_in_seconds', models.BigIntegerField(blank=True, db_comment='The duration of the assessment run.', null=True)),
                ('started_at', models.DateTimeField(blank=True, db_comment='The time when StartAssessmentRun was called.', null=True)),
                ('state_changed_at', models.DateTimeField(blank=True, db_comment="The last time when the assessment run's state changed.", null=True)),
                ('finding_counts', models.JSONField(blank=True, db_comment='Provides a total count of generated findings per severity.', null=True)),
                ('notifications', models.JSONField(blank=True, db_comment='A list of notifications for the event subscriptions.', null=True)),
                ('rules_package_arns', models.JSONField(blank=True, db_comment='The rules packages selected for the assessment run.', null=True)),
                ('state_changes', models.JSONField(blank=True, db_comment='A list of the assessment run state changes.', null=True)),
                ('user_attributes_for_findings', models.JSONField(blank=True, db_comment='The user-defined attributes that are assigned to every generated finding.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_inspector_assessment_run',
                'db_table_comment': 'AWS Inspector Assessment Run',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsInspectorAssessmentTarget',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the Amazon Inspector assessment target.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN that specifies the Amazon Inspector assessment target.', null=True)),
                ('resource_group_arn', models.TextField(blank=True, db_comment='The ARN that specifies the resource group that is associated with the assessment target.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The time at which the assessment target is created.', null=True)),
                ('updated_at', models.DateTimeField(blank=True, db_comment='The time at which UpdateAssessmentTarget is called.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_inspector_assessment_target',
                'db_table_comment': 'AWS Inspector Assessment Target',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsInspectorAssessmentTemplate',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the assessment template.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the assessment template.', null=True)),
                ('assessment_run_count', models.BigIntegerField(blank=True, db_comment='The number of existing assessment runs associated with this assessment template.', null=True)),
                ('assessment_target_arn', models.TextField(blank=True, db_comment='The ARN of the assessment target that corresponds to this assessment template.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The time at which the assessment template is created.', null=True)),
                ('duration_in_seconds', models.BigIntegerField(blank=True, db_comment='The duration in seconds specified for this assessment template.', null=True)),
                ('last_assessment_run_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the most recent assessment run associated with this assessment template.', null=True)),
                ('rules_package_arns', models.JSONField(blank=True, db_comment='The rules packages that are specified for this assessment template.', null=True)),
                ('user_attributes_for_findings', models.JSONField(blank=True, db_comment='The user-defined attributes that are assigned to every generated finding from the assessment run that uses this assessment template.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with the Assessment Template.', null=True)),
                ('event_subscriptions', models.JSONField(blank=True, db_comment='A list of event subscriptions associated with the Assessment Template.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_inspector_assessment_template',
                'db_table_comment': 'AWS Inspector Assessment Template',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsInspectorExclusion',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The ARN that specifies the exclusion.', null=True)),
                ('assessment_run_arn', models.TextField(blank=True, db_comment='The ARN that specifies the assessment run, the exclusion belongs to.', null=True)),
                ('attributes', models.JSONField(blank=True, db_comment='The system-defined attributes for the exclusion.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the exclusion.', null=True)),
                ('recommendation', models.TextField(blank=True, db_comment='The recommendation for the exclusion.', null=True)),
                ('scopes', models.JSONField(blank=True, db_comment='The AWS resources for which the exclusion pertains.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_inspector_exclusion',
                'db_table_comment': 'AWS Inspector Exclusion',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsInspectorFinding',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The ID of the finding.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The ARN that specifies the finding.', null=True)),
                ('agent_id', models.TextField(blank=True, db_comment='The ID of the agent that is installed on the EC2 instance where the finding is generated.', null=True)),
                ('asset_type', models.TextField(blank=True, db_comment='The type of the host from which the finding is generated.', null=True)),
                ('auto_scaling_group', models.TextField(blank=True, db_comment='The Auto Scaling group of the EC2 instance where the finding is generated.', null=True)),
                ('confidence', models.BigIntegerField(blank=True, db_comment='This data element is currently not used.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The time when the finding was generated.', null=True)),
                ('updated_at', models.DateTimeField(blank=True, db_comment='The time when AddAttributesToFindings is called.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the finding.', null=True)),
                ('indicator_of_compromise', models.BooleanField(blank=True, db_comment='This data element is currently not used.', null=True)),
                ('numeric_severity', models.FloatField(blank=True, db_comment='The numeric value of the finding severity.', null=True)),
                ('recommendation', models.TextField(blank=True, db_comment='The recommendation for the finding.', null=True)),
                ('schema_version', models.BigIntegerField(blank=True, db_comment='The schema version of this data type.', null=True)),
                ('service', models.TextField(blank=True, db_comment="The data element is set to 'Inspector'.", null=True)),
                ('severity', models.TextField(blank=True, db_comment='The finding severity. Values can be set to High, Medium, Low, and Informational.', null=True)),
                ('asset_attributes', models.JSONField(blank=True, db_comment='A collection of attributes of the host from which the finding is generated.', null=True)),
                ('attributes', models.JSONField(blank=True, db_comment='The system-defined attributes for the finding.', null=True)),
                ('failed_items', models.JSONField(blank=True, db_comment='Attributes details that cannot be described. An error code is provided for each failed item.', null=True)),
                ('service_attributes', models.JSONField(blank=True, db_comment='This data type is used in the Finding data type.', null=True)),
                ('user_attributes', models.JSONField(blank=True, db_comment='The user-defined attributes that are assigned to the finding.', null=True)),
                ('title', models.TextField(blank=True, db_comment='The name of the finding.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_inspector_finding',
                'db_table_comment': 'AWS Inspector Finding',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIotFleetMetric',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the fleet metric to describe.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the fleet metric to describe.', null=True)),
                ('index_name', models.TextField(blank=True, db_comment='The name of the index to search.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The fleet metric description.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The date when the fleet metric is created.', null=True)),
                ('last_modified_date', models.DateTimeField(blank=True, db_comment='The date when the fleet metric is last modified.', null=True)),
                ('aggregation_field', models.TextField(blank=True, db_comment='The field to aggregate.', null=True)),
                ('aggregation_type_name', models.TextField(blank=True, db_comment='The name of the aggregation type.', null=True)),
                ('period', models.BigIntegerField(blank=True, db_comment='The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.', null=True)),
                ('query_string', models.TextField(blank=True, db_comment='The search query string.', null=True)),
                ('query_version', models.TextField(blank=True, db_comment='The search query version.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='Used to support unit transformation such as milliseconds to seconds. The unit must be supported by CW metric (https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html)', null=True)),
                ('version', models.BigIntegerField(blank=True, db_comment='The version of the fleet metric.', null=True)),
                ('aggregation_type_values', models.JSONField(blank=True, db_comment='A list of the values of aggregation types.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags currently associated with the thing type.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iot_fleet_metric',
                'db_table_comment': 'AWS IoT Fleet Metric',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIotThing',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('thing_name', models.TextField(blank=True, db_comment='The name of the thing.', null=True)),
                ('thing_id', models.TextField(blank=True, db_comment='The ID of the thing to describe.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the thing.', null=True)),
                ('thing_type_name', models.TextField(blank=True, db_comment='The name of the thing type, if the thing has been associated with a type.', null=True)),
                ('attribute_name', models.TextField(blank=True, db_comment='The attribute name of the thing.', null=True)),
                ('attribute_value', models.TextField(blank=True, db_comment='The attribute value for the attribute name of the thing.', null=True)),
                ('billing_group_name', models.TextField(blank=True, db_comment='The name of the billing group the thing belongs to.', null=True)),
                ('default_client_id', models.TextField(blank=True, db_comment='The default MQTT client ID. For a typical device, the thing name is also used as the default MQTT client ID.', null=True)),
                ('version', models.BigIntegerField(blank=True, db_comment='The version of the thing record in the registry.', null=True)),
                ('attributes', models.JSONField(blank=True, db_comment='A list of thing attributes which are name-value pairs.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iot_thing',
                'db_table_comment': 'AWS IoT Thing',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIotThingGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('group_name', models.TextField(blank=True, db_comment='The group name.', null=True)),
                ('thing_group_id', models.TextField(blank=True, db_comment='The thing group ID.', null=True)),
                ('thing_group_description', models.TextField(blank=True, db_comment='The thing group description.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The UNIX timestamp of when the thing group was created.', null=True)),
                ('parent_group_name', models.TextField(blank=True, db_comment='The parent thing group name.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the thing group.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The dynamic thing group status.', null=True)),
                ('index_name', models.TextField(blank=True, db_comment='The dynamic thing group index name.', null=True)),
                ('query_string', models.TextField(blank=True, db_comment='The dynamic thing group search query string.', null=True)),
                ('query_version', models.TextField(blank=True, db_comment='The dynamic thing group query version.', null=True)),
                ('version', models.BigIntegerField(blank=True, db_comment='The version of the thing group.', null=True)),
                ('attribute_payload', models.JSONField(blank=True, db_comment='The thing group attributes in JSON format.', null=True)),
                ('root_to_parent_thing_groups', models.JSONField(blank=True, db_comment='The root parent thing group.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags currently associated with the thing group.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iot_thing_group',
                'db_table_comment': 'AWS IoT Thing Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsIotThingType',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('thing_type_name', models.TextField(blank=True, db_comment='The name of the thing type.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the thing type.', null=True)),
                ('thing_type_id', models.TextField(blank=True, db_comment='The thing type ID.', null=True)),
                ('thing_type_description', models.TextField(blank=True, db_comment='The description of the thing type.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The UNIX timestamp of when the thing type was created.', null=True)),
                ('deprecated', models.BooleanField(blank=True, db_comment='Whether the thing type is deprecated. If true, no new things could be associated with this type.', null=True)),
                ('deprecation_date', models.DateTimeField(blank=True, db_comment='The date and time when the thing type was deprecated.', null=True)),
                ('searchable_attributes', models.JSONField(blank=True, db_comment='A list of searchable thing attribute names.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags currently associated with the thing type.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_iot_thing_type',
                'db_table_comment': 'AWS IoT Thing Type',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsKinesisanalyticsv2Application',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('application_name', models.TextField(blank=True, db_comment='The name of the application.', null=True)),
                ('application_version_id', models.BigIntegerField(blank=True, db_comment='Provides the current application version.', null=True)),
                ('application_arn', models.TextField(blank=True, db_comment='The ARN of the application.', null=True)),
                ('application_status', models.TextField(blank=True, db_comment='The status of the application.', null=True)),
                ('create_timestamp', models.DateTimeField(blank=True, db_comment='The current timestamp when the application was created.', null=True)),
                ('application_description', models.TextField(blank=True, db_comment='The description of the application.', null=True)),
                ('last_update_timestamp', models.DateTimeField(blank=True, db_comment='The current timestamp when the application was last updated.', null=True)),
                ('runtime_environment', models.TextField(blank=True, db_comment='The runtime environment for the application.', null=True)),
                ('service_execution_role', models.TextField(blank=True, db_comment='Specifies the IAM role that the application uses to access external resources.', null=True)),
                ('application_configuration_description', models.JSONField(blank=True, db_comment="Provides details about the application's Java, SQL, or Scala code and starting parameters.", null=True)),
                ('cloud_watch_logging_option_descriptions', models.JSONField(blank=True, db_comment='Describes the application Amazon CloudWatch logging options.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The key-value tags assigned to the application.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_kinesisanalyticsv2_application',
                'db_table_comment': 'AWS Kinesis Analytics V2 Application',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsKinesisConsumer',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('consumer_name', models.TextField(blank=True, db_comment='The name of the consumer.', null=True)),
                ('consumer_arn', models.TextField(blank=True, db_comment='An ARN generated by Kinesis Data Streams when consumer is registered.', null=True)),
                ('stream_arn', models.TextField(blank=True, db_comment='The ARN of the stream with which you registered the consumer.', null=True)),
                ('consumer_status', models.TextField(blank=True, db_comment='The current status of consumer.', null=True)),
                ('consumer_creation_timestamp', models.DateTimeField(blank=True, db_comment='Timestamp when consumer was created.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_kinesis_consumer',
                'db_table_comment': 'AWS Kinesis Consumer',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsKinesisFirehoseDeliveryStream',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('delivery_stream_name', models.TextField(blank=True, db_comment='The name of the delivery stream.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the delivery stream.', null=True)),
                ('delivery_stream_status', models.TextField(blank=True, db_comment='The server-side encryption type used on the stream.', null=True)),
                ('delivery_stream_type', models.TextField(blank=True, db_comment='The delivery stream type.', null=True)),
                ('version_id', models.TextField(blank=True, db_comment='The version id of the stream. Each time the destination is updated for a delivery stream, the version ID is changed, and the current version ID is required when updating the destination', null=True)),
                ('create_timestamp', models.DateTimeField(blank=True, db_comment='The date and time that the delivery stream was created.', null=True)),
                ('has_more_destinations', models.BooleanField(blank=True, db_comment='Indicates whether there are more destinations available to list.', null=True)),
                ('last_update_timestamp', models.DateTimeField(blank=True, db_comment='The date and time that the delivery stream was last updated.', null=True)),
                ('delivery_stream_encryption_configuration', models.JSONField(blank=True, db_comment='Indicates the server-side encryption (SSE) status for the delivery stream.', null=True)),
                ('destinations', models.JSONField(blank=True, db_comment='The destinations for the stream.', null=True)),
                ('failure_description', models.JSONField(blank=True, db_comment='Provides details in case one of the following operations fails due to an error related to KMS: CreateDeliveryStream, DeleteDeliveryStream, StartDeliveryStreamEncryption,StopDeliveryStreamEncryption.', null=True)),
                ('source', models.JSONField(blank=True, db_comment='If the DeliveryStreamType parameter is KinesisStreamAsSource, a SourceDescription object describing the source Kinesis data stream.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with the delivery stream.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_kinesis_firehose_delivery_stream',
                'db_table_comment': 'AWS Kinesis Firehose Delivery Stream',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsKinesisStream',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('stream_name', models.TextField(blank=True, db_comment='The name of the stream being described.', null=True)),
                ('stream_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the stream being described.', null=True)),
                ('stream_status', models.TextField(blank=True, db_comment='The current status of the stream being described.', null=True)),
                ('stream_creation_timestamp', models.DateTimeField(blank=True, db_comment='The approximate time that the stream was created.', null=True)),
                ('encryption_type', models.TextField(blank=True, db_comment='The server-side encryption type used on the stream.', null=True)),
                ('key_id', models.TextField(blank=True, db_comment='The GUID for the customer-managed AWS KMS key to use for encryption.', null=True)),
                ('retention_period_hours', models.BigIntegerField(blank=True, db_comment='The current retention period, in hours.', null=True)),
                ('consumer_count', models.BigIntegerField(blank=True, db_comment='The number of enhanced fan-out consumers registered with the stream.', null=True)),
                ('open_shard_count', models.BigIntegerField(blank=True, db_comment='The number of open shards in the stream.', null=True)),
                ('has_more_shards', models.BooleanField(blank=True, db_comment='If set to true, more shards in the stream are available to describe.', null=True)),
                ('shards', models.JSONField(blank=True, db_comment='The shards that comprise the stream.', null=True)),
                ('enhanced_monitoring', models.JSONField(blank=True, db_comment='Represents the current enhanced monitoring settings of the stream.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with the stream.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_kinesis_stream',
                'db_table_comment': 'AWS Kinesis Stream',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsKinesisVideoStream',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('stream_name', models.TextField(blank=True, db_comment='The name of the stream.', null=True)),
                ('stream_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the stream.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the stream.', null=True)),
                ('version', models.TextField(blank=True, db_comment='The version of the stream.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The ID of the AWS Key Management Service (AWS KMS) key that Kinesis Video Streams uses to encrypt data on the stream.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='A time stamp that indicates when the stream was created.', null=True)),
                ('data_retention_in_hours', models.BigIntegerField(blank=True, db_comment='How long the stream retains data, in hours.', null=True)),
                ('device_name', models.TextField(blank=True, db_comment='The name of the device that is associated with the stream.', null=True)),
                ('media_type', models.TextField(blank=True, db_comment='The MediaType of the stream.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_kinesis_video_stream',
                'db_table_comment': 'AWS Kinesis Video Stream',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsKmsAlias',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('alias_name', models.TextField(blank=True, db_comment='String that contains the alias. This value begins with alias/.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='String that contains the key ARN.', null=True)),
                ('target_key_id', models.TextField(blank=True, db_comment='String that contains the key identifier of the KMS key associated with the alias.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='Date and time that the alias was most recently created in the account and Region.', null=True)),
                ('last_updated_date', models.DateTimeField(blank=True, db_comment='Date and time that the alias was most recently associated with a KMS key in the account and Region.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_kms_alias',
                'db_table_comment': 'AWS KMS Alias',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsLambdaAlias',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the alias.', null=True)),
                ('function_name', models.TextField(blank=True, db_comment='The name of the function.', null=True)),
                ('alias_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the alias.', null=True)),
                ('function_version', models.TextField(blank=True, db_comment='The function version that the alias invokes.', null=True)),
                ('revision_id', models.TextField(blank=True, db_comment='A unique identifier that changes when you update the alias.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the alias.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='Contains the resource-based policy.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the contents of the resource-based policy in a canonical form for easier searching.', null=True)),
                ('url_config', models.JSONField(blank=True, db_comment='The function URL configuration details of the alias.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_lambda_alias',
                'db_table_comment': 'AWS Lambda Alias',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsLambdaEventSourceMapping',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('uuid', models.TextField(blank=True, db_comment='The identifier of the event source mapping.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the event source.', null=True)),
                ('function_arn', models.TextField(blank=True, db_comment='The ARN of the Lambda function.', null=True)),
                ('function_name', models.TextField(blank=True, db_comment='The name of the Lambda function.', null=True)),
                ('batch_size', models.BigIntegerField(blank=True, db_comment='The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function.', null=True)),
                ('bisect_batch_on_function_error', models.BooleanField(blank=True, db_comment='If the function returns an error, split the batch in two and retry.', null=True)),
                ('last_modified', models.DateTimeField(blank=True, db_comment='The date that the event source mapping was last updated or that its state changed.', null=True)),
                ('last_processing_result', models.TextField(blank=True, db_comment='The result of the last Lambda invocation of your function.', null=True)),
                ('maximum_batching_window_in_seconds', models.BigIntegerField(blank=True, db_comment='The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function.', null=True)),
                ('maximum_record_age_in_seconds', models.BigIntegerField(blank=True, db_comment='Discard records older than the specified age.', null=True)),
                ('maximum_retry_attempts', models.BigIntegerField(blank=True, db_comment='Discard records after the specified number of retries.', null=True)),
                ('parallelization_factor', models.BigIntegerField(blank=True, db_comment='The number of batches to process concurrently from each shard.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The state of the event source mapping.', null=True)),
                ('state_transition_reason', models.TextField(blank=True, db_comment='Indicates whether a user or Lambda made the last change to the event source mapping.', null=True)),
                ('starting_position', models.TextField(blank=True, db_comment='The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.', null=True)),
                ('starting_position_timestamp', models.DateTimeField(blank=True, db_comment='The position in a stream from which to start reading. With StartingPosition set to AT_TIMESTAMP, the time from which to start reading, in Unix time seconds. StartingPositionTimestamp cannot be in the future.', null=True)),
                ('tumbling_window_in_seconds', models.BigIntegerField(blank=True, db_comment='The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.', null=True)),
                ('function_response_types', models.JSONField(blank=True, db_comment='A list of current response type enums applied to the event source mapping.', null=True)),
                ('source_access_configurations', models.JSONField(blank=True, db_comment='An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.', null=True)),
                ('destination_config', models.JSONField(blank=True, db_comment='An Amazon SQS queue or Amazon SNS topic destination for discarded records.', null=True)),
                ('filter_criteria', models.JSONField(blank=True, db_comment='An object that defines the filter criteria that determine whether Lambda should process an event.', null=True)),
                ('amazon_managed_kafka_event_source_config', models.JSONField(blank=True, db_comment='Specific configuration settings for an Amazon Managed Streaming for Apache Kafka.', null=True)),
                ('queues', models.JSONField(blank=True, db_comment='The name of the Amazon MQ broker destination queue to consume.', null=True)),
                ('scaling_config', models.JSONField(blank=True, db_comment='The scaling configuration for the event source.', null=True)),
                ('self_managed_event_source', models.JSONField(blank=True, db_comment='The self-managed Apache Kafka cluster for your event source.', null=True)),
                ('self_managed_kafka_event_source_config', models.JSONField(blank=True, db_comment='Specific configuration settings for a self-managed Apache Kafka event source.', null=True)),
                ('topics', models.JSONField(blank=True, db_comment='The name of the Kafka topic.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_lambda_event_source_mapping',
                'db_table_comment': 'AWS Lambda Event Source Mapping',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsLambdaFunction',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the function.', null=True)),
                ('arn', models.TextField(blank=True, db_comment="The function's Amazon Resource Name (ARN).", null=True)),
                ('code_sha_256', models.TextField(blank=True, db_comment="The SHA256 hash of the function's deployment package.", null=True)),
                ('code_size', models.BigIntegerField(blank=True, db_comment="The size of the function's deployment package, in bytes.", null=True)),
                ('dead_letter_config_target_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.', null=True)),
                ('description', models.TextField(blank=True, db_comment="The function's description.", null=True)),
                ('handler', models.TextField(blank=True, db_comment='The function that Lambda calls to begin executing your function.', null=True)),
                ('kms_key_arn', models.TextField(blank=True, db_comment="The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed CMK.", null=True)),
                ('last_modified', models.DateTimeField(blank=True, db_comment='The date and time that the function was last updated.', null=True)),
                ('timeout', models.TextField(blank=True, db_comment='The amount of time in seconds that Lambda allows a function to run before stopping it.', null=True)),
                ('version', models.TextField(blank=True, db_comment='The version of the Lambda function.', null=True)),
                ('package_type', models.TextField(blank=True, db_comment='The type of deployment package.', null=True)),
                ('master_arn', models.TextField(blank=True, db_comment='For Lambda@Edge functions, the ARN of the master function.', null=True)),
                ('memory_size', models.BigIntegerField(blank=True, db_comment="The memory that's allocated to the function.", null=True)),
                ('revision_id', models.TextField(blank=True, db_comment='The latest updated revision of the function or alias.', null=True)),
                ('role', models.TextField(blank=True, db_comment="The function's execution role.", null=True)),
                ('runtime', models.TextField(blank=True, db_comment='The runtime environment for the Lambda function.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The current state of the function.', null=True)),
                ('state_reason', models.TextField(blank=True, db_comment="The reason for the function's current state.", null=True)),
                ('state_reason_code', models.TextField(blank=True, db_comment="The reason code for the function's current state.", null=True)),
                ('last_update_status', models.TextField(blank=True, db_comment='The status of the last update that was performed on the function.', null=True)),
                ('last_update_status_reason', models.TextField(blank=True, db_comment='The reason for the last update that was performed on the function.', null=True)),
                ('last_update_status_reason_code', models.TextField(blank=True, db_comment='The reason code for the last update that was performed on the function.', null=True)),
                ('reserved_concurrent_executions', models.BigIntegerField(blank=True, db_comment='The number of concurrent executions that are reserved for this function.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The VPC ID that is attached to Lambda function.', null=True)),
                ('architectures', models.JSONField(blank=True, db_comment='The instruction set architecture that the function supports. Architecture is a string array with one of the valid values.', null=True)),
                ('code', models.JSONField(blank=True, db_comment='The deployment package of the function or version.', null=True)),
                ('environment_variables', models.JSONField(blank=True, db_comment='The environment variables that are accessible from function code during execution.', null=True)),
                ('file_system_configs', models.JSONField(blank=True, db_comment='Connection settings for an Amazon EFS file system.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='The resource-based iam policy of Lambda function.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the policy in a canonical form for easier searching.', null=True)),
                ('tracing_config', models.JSONField(blank=True, db_comment="The function's X-Ray tracing configuration.", null=True)),
                ('snap_start', models.JSONField(blank=True, db_comment='Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version.', null=True)),
                ('url_config', models.JSONField(blank=True, db_comment='The function URL configuration details of the function.', null=True)),
                ('vpc_security_group_ids', models.JSONField(blank=True, db_comment='A list of VPC security groups IDs attached to Lambda function.', null=True)),
                ('vpc_subnet_ids', models.JSONField(blank=True, db_comment='A list of VPC subnet IDs attached to Lambda function.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('layers', models.JSONField(blank=True, null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_lambda_function',
                'db_table_comment': 'AWS Lambda Function',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsLambdaFunctionMetricDurationDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the function.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_lambda_function_metric_duration_daily',
                'db_table_comment': 'AWS Lambda Function Cloudwatch Metrics - Duration (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsLambdaFunctionMetricErrorsDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the function.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_lambda_function_metric_errors_daily',
                'db_table_comment': 'AWS Lambda Function Cloudwatch Metrics - Errors (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsLambdaFunctionMetricInvocationsDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the function.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_lambda_function_metric_invocations_daily',
                'db_table_comment': 'AWS Lambda Function Cloudwatch Metrics - Invocations (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsLambdaLayer',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('layer_name', models.TextField(blank=True, db_comment='The name of the layer.', null=True)),
                ('layer_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the function layer.', null=True)),
                ('created_date', models.DateTimeField(blank=True, db_comment='The date that the version was created, in ISO 8601 format.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the version.', null=True)),
                ('layer_version_arn', models.TextField(blank=True, db_comment='The ARN of the layer version.', null=True)),
                ('license_info', models.TextField(blank=True, db_comment="The layer's open-source license.", null=True)),
                ('version', models.BigIntegerField(blank=True, db_comment='The version number.', null=True)),
                ('compatible_architectures', models.JSONField(blank=True, db_comment='A list of compatible instruction set architectures.', null=True)),
                ('compatible_runtimes', models.JSONField(blank=True, db_comment="The layer's compatible runtimes.", null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_lambda_layer',
                'db_table_comment': 'AWS Lambda Layer',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsLambdaLayerVersion',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('layer_name', models.TextField(blank=True, db_comment='The name of the layer.', null=True)),
                ('layer_arn', models.TextField(blank=True, db_comment='The ARN of the layer.', null=True)),
                ('layer_version_arn', models.TextField(blank=True, db_comment='The ARN of the layer version.', null=True)),
                ('created_date', models.DateTimeField(blank=True, db_comment='The date that the version was created, in ISO 8601 format.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the version.', null=True)),
                ('license_info', models.TextField(blank=True, db_comment="The layer's open-source license.", null=True)),
                ('revision_id', models.TextField(blank=True, db_comment='A unique identifier for the current revision of the policy.', null=True)),
                ('version', models.BigIntegerField(blank=True, db_comment='The version number.', null=True)),
                ('compatible_architectures', models.JSONField(blank=True, db_comment='A list of compatible instruction set architectures.', null=True)),
                ('compatible_runtimes', models.JSONField(blank=True, db_comment="The layer's compatible runtimes.", null=True)),
                ('content', models.JSONField(blank=True, db_comment='Details about the layer version.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='The policy document.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the policy document in a canonical form for easier searching.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_lambda_layer_version',
                'db_table_comment': 'AWS Lambda Layer Version',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsLambdaVersion',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('version', models.TextField(blank=True, db_comment='The version of the Lambda function.', null=True)),
                ('function_name', models.TextField(blank=True, db_comment='The name of the function.', null=True)),
                ('arn', models.TextField(blank=True, db_comment="The function's Amazon Resource Name (ARN).", null=True)),
                ('master_arn', models.TextField(blank=True, db_comment='For Lambda@Edge functions, the ARN of the master function.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The current state of the function.', null=True)),
                ('code_sha_256', models.TextField(blank=True, db_comment="The SHA256 hash of the function's deployment package.", null=True)),
                ('code_size', models.BigIntegerField(blank=True, db_comment="The size of the function's deployment package, in bytes.", null=True)),
                ('description', models.TextField(blank=True, db_comment="The function's description.", null=True)),
                ('handler', models.TextField(blank=True, db_comment='The function that Lambda calls to begin executing your function.', null=True)),
                ('last_modified', models.DateTimeField(blank=True, db_comment='The date and time that the function was last updated, in ISO-8601 format.', null=True)),
                ('last_update_status', models.TextField(blank=True, db_comment='The status of the last update that was performed on the function.', null=True)),
                ('last_update_status_reason', models.TextField(blank=True, db_comment='The reason for the last update that was performed on the function.', null=True)),
                ('last_update_status_reason_code', models.TextField(blank=True, db_comment='The reason code for the last update that was performed on the function.', null=True)),
                ('memory_size', models.BigIntegerField(blank=True, db_comment="The memory that's allocated to the function.", null=True)),
                ('revision_id', models.TextField(blank=True, db_comment='The latest updated revision of the function or alias.', null=True)),
                ('runtime', models.TextField(blank=True, db_comment='The runtime environment for the Lambda function.', null=True)),
                ('timeout', models.BigIntegerField(blank=True, db_comment='The amount of time in seconds that Lambda allows a function to run before stopping it.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The ID of the VPC.', null=True)),
                ('kms_key_arn', models.TextField(blank=True, db_comment="The KMS key that's used to encrypt the function's environment variables.", null=True)),
                ('role', models.TextField(blank=True, db_comment="The function's execution role.", null=True)),
                ('signing_job_arn', models.TextField(blank=True, db_comment='The ARN of the signing job.', null=True)),
                ('signing_profile_version_arn', models.TextField(blank=True, db_comment='The ARN of the signing profile version.', null=True)),
                ('state_reason', models.TextField(blank=True, db_comment="The reason for the function's current state.", null=True)),
                ('state_reason_code', models.TextField(blank=True, db_comment="The reason code for the function's current state.", null=True)),
                ('ephemeral_storage_size', models.BigIntegerField(blank=True, db_comment="The size of the function's /tmp directory in MB.", null=True)),
                ('environment_variables', models.JSONField(blank=True, db_comment='The environment variables that are accessible from function code during execution.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='Contains the resource-based policy.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the contents of the resource-based policy in a canonical form for easier searching.', null=True)),
                ('vpc_security_group_ids', models.JSONField(blank=True, db_comment='A list of VPC security groups IDs attached to Lambda function.', null=True)),
                ('vpc_subnet_ids', models.JSONField(blank=True, db_comment='A list of VPC subnet IDs attached to Lambda function.', null=True)),
                ('architectures', models.JSONField(blank=True, db_comment='The instruction set architecture that the function supports.', null=True)),
                ('dead_letter_config', models.JSONField(blank=True, db_comment="The function's dead letter queue configuration.", null=True)),
                ('file_system_configs', models.JSONField(blank=True, db_comment='Connection settings for an Amazon EFS file system.', null=True)),
                ('image_config_response', models.JSONField(blank=True, db_comment="The function's image configuration values.", null=True)),
                ('layers', models.JSONField(blank=True, db_comment="The function's layers.", null=True)),
                ('logging_config', models.JSONField(blank=True, db_comment="The function's Amazon CloudWatch Logs configuration settings.", null=True)),
                ('runtime_version_config', models.JSONField(blank=True, db_comment='The ARN of the runtime and any errors that occurred.', null=True)),
                ('snap_start', models.JSONField(blank=True, db_comment='Configuration for creating a snapshot of the initialized execution environment.', null=True)),
                ('tracing_config', models.JSONField(blank=True, db_comment="The function's X-Ray tracing configuration.", null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_lambda_version',
                'db_table_comment': 'AWS Lambda Version',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsLightsailInstance',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the instance.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the instance.', null=True)),
                ('blueprint_id', models.TextField(blank=True, db_comment='The blueprint ID (e.g., os_amlinux_2016_03).', null=True)),
                ('blueprint_name', models.TextField(blank=True, db_comment='The friendly name of the blueprint (e.g., Amazon Linux).', null=True)),
                ('bundle_id', models.TextField(blank=True, db_comment='The bundle for the instance (e.g., micro_1_0).', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The timestamp when the instance was created.', null=True)),
                ('hardware', models.JSONField(blank=True, db_comment='The size of the vCPU and the amount of RAM for the instance.', null=True)),
                ('ip_address_type', models.JSONField(blank=True, db_comment='The IP address type of the instance.', null=True)),
                ('ip_v6_addresses', models.JSONField(blank=True, db_comment='The IPv6 addresses of the instance.', null=True)),
                ('is_static_ip', models.BooleanField(blank=True, db_comment='A Boolean value indicating whether this instance has a static IP assigned to it.', null=True)),
                ('availability_zone', models.TextField(blank=True, db_comment='The Availability Zone where the instance is located.', null=True)),
                ('metadata_options', models.JSONField(blank=True, db_comment='The metadata options for the Amazon Lightsail instance.', null=True)),
                ('networking', models.JSONField(blank=True, db_comment='Information about the public ports and monthly data transfer rates for the instance.', null=True)),
                ('private_ip_address', models.TextField(blank=True, db_comment='The private IP address of the instance.', null=True)),
                ('public_ip_address', models.TextField(blank=True, db_comment='The public IP address of the instance.', null=True)),
                ('resource_type', models.TextField(blank=True, db_comment='The type of resource.', null=True)),
                ('ssh_key_name', models.TextField(blank=True, db_comment='The name of the SSH key being used to connect to the instance.', null=True)),
                ('state_code', models.BigIntegerField(blank=True, db_comment='The status code for the instance.', null=True)),
                ('state_name', models.TextField(blank=True, db_comment='The status of the instance.', null=True)),
                ('support_code', models.TextField(blank=True, db_comment='The support code.', null=True)),
                ('username', models.TextField(blank=True, db_comment='The user name for connecting to the instance.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the instance.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_lightsail_instance',
                'db_table_comment': 'AWS Lightsail Instance',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsMacie2ClassificationJob',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The custom name of the job.', null=True)),
                ('job_id', models.TextField(blank=True, db_comment='The unique identifier for the job.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the job.', null=True)),
                ('job_status', models.TextField(blank=True, db_comment='The status of a classification job.', null=True)),
                ('job_type', models.TextField(blank=True, db_comment='The schedule for running a classification job.', null=True)),
                ('client_token', models.TextField(blank=True, db_comment='The token that was provided to ensure the idempotency of the request to create the job.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The date and time, in UTC and extended ISO 8601 format, when the job was created.', null=True)),
                ('last_run_time', models.DateTimeField(blank=True, db_comment='This value indicates when the most recent run started.', null=True)),
                ('sampling_percentage', models.BigIntegerField(blank=True, db_comment='The sampling depth, as a percentage, that determines the percentage of eligible objects that the job analyzes.', null=True)),
                ('bucket_definitions', models.JSONField(blank=True, db_comment='The namespace of the AWS service that provides the resource, or a custom-resource.', null=True)),
                ('custom_data_identifier_ids', models.JSONField(blank=True, db_comment='The custom data identifiers that the job uses to analyze data.', null=True)),
                ('last_run_error_status', models.JSONField(blank=True, db_comment='Specifies whether any account- or bucket-level access errors occurred when a classification job ran.', null=True)),
                ('s3_job_definition', models.JSONField(blank=True, db_comment='Specifies which S3 buckets contain the objects that a classification job analyzes, and the scope of that analysis.', null=True)),
                ('schedule_frequency', models.JSONField(blank=True, db_comment='Specifies the recurrence pattern for running a classification job.', null=True)),
                ('statistics', models.JSONField(blank=True, db_comment='Provides processing statistics for a classification job.', null=True)),
                ('user_paused_details', models.JSONField(blank=True, db_comment='Provides information about when a classification job was paused.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_macie2_classification_job',
                'db_table_comment': 'AWS Macie2 Classification Job',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsMediaStoreContainer',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the container.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the container.', null=True)),
                ('status', models.TextField(blank=True, db_comment="The status of container creation or deletion. The status is one of the following: 'CREATING', 'ACTIVE', or 'DELETING'.", null=True)),
                ('access_logging_enabled', models.BooleanField(blank=True, db_comment='The state of access logging on the container. This value is false by default, indicating that AWS Elemental MediaStore does not send access logs to Amazon CloudWatch Logs. When you enable access logging on the container, MediaStore changes this value to true, indicating that the service delivers access logs for objects stored in that container to CloudWatch Logs.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The Unix timestamp that the container was created.', null=True)),
                ('endpoint', models.TextField(blank=True, db_comment='The DNS endpoint of the container.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='The contents of the access policy.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the contents of the access policy in a canonical form for easier searching.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with the container', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_media_store_container',
                'db_table_comment': 'AWS Media Store Container',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsMgnApplication',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='Application name.', null=True)),
                ('application_id', models.TextField(blank=True, db_comment='Application ID.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the application.', null=True)),
                ('creation_date_time', models.DateTimeField(blank=True, db_comment='Application creation dateTime.', null=True)),
                ('description', models.TextField(blank=True, db_comment='Application description.', null=True)),
                ('is_archived', models.BooleanField(blank=True, db_comment='Application archival status.', null=True)),
                ('last_modified_date_time', models.DateTimeField(blank=True, db_comment='Application last modified dateTime.', null=True)),
                ('wave_id', models.TextField(blank=True, db_comment='Application wave ID.', null=True)),
                ('application_aggregated_status', models.JSONField(blank=True, db_comment='Application aggregated status.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A list of tags attached to the application.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_mgn_application',
                'db_table_comment': 'AWS MGN Application',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsMqBroker',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('broker_name', models.TextField(blank=True, db_comment="The broker's name.", null=True)),
                ('broker_id', models.TextField(blank=True, db_comment='The unique ID that Amazon MQ generates for the broker.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the broker.', null=True)),
                ('broker_state', models.TextField(blank=True, db_comment="The broker's status.", null=True)),
                ('deployment_mode', models.TextField(blank=True, db_comment="The broker's deployment mode.", null=True)),
                ('created', models.DateTimeField(blank=True, db_comment='The time when the broker was created.', null=True)),
                ('host_instance_type', models.TextField(blank=True, db_comment="The broker's instance type.", null=True)),
                ('authentication_strategy', models.TextField(blank=True, db_comment='The authentication strategy used to secure the broker. The default is SIMPLE.', null=True)),
                ('data_replication_mode', models.TextField(blank=True, db_comment='Describes whether this broker is a part of a data replication pair.', null=True)),
                ('engine_type', models.TextField(blank=True, db_comment='The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.', null=True)),
                ('engine_version', models.TextField(blank=True, db_comment="The broker engine's version.", null=True)),
                ('pending_authentication_strategy', models.TextField(blank=True, db_comment='The authentication strategy that will be applied when the broker is rebooted. The default is SIMPLE.', null=True)),
                ('pending_data_replication_mode', models.TextField(blank=True, db_comment='Describes whether this broker will be a part of a data replication pair after reboot.', null=True)),
                ('pending_engine_version', models.TextField(blank=True, db_comment='The broker engine version to upgrade to.', null=True)),
                ('pending_host_instance_type', models.TextField(blank=True, db_comment="The broker's host instance type to upgrade to.", null=True)),
                ('publicly_accessible', models.BooleanField(blank=True, db_comment="Enables connections from applications outside of the VPC that hosts the broker's subnets.", null=True)),
                ('storage_type', models.TextField(blank=True, db_comment="The broker's storage type.", null=True)),
                ('auto_minor_version_upgrade', models.BooleanField(blank=True, db_comment='Enables automatic upgrades to new minor versions for brokers, as new versions are released and supported by Amazon MQ.', null=True)),
                ('actions_required', models.JSONField(blank=True, db_comment='Actions required for a broker.', null=True)),
                ('broker_instances', models.JSONField(blank=True, db_comment='A list of information about allocated brokers.', null=True)),
                ('configurations', models.JSONField(blank=True, db_comment='The list of all revisions for the specified configuration.', null=True)),
                ('data_replication_metadata', models.JSONField(blank=True, db_comment='The replication details of the data replication-enabled broker. Only returned if dataReplicationMode is set to CRDR.', null=True)),
                ('encryption_options', models.JSONField(blank=True, db_comment='Encryption options for the broker.', null=True)),
                ('ldap_server_metadata', models.JSONField(blank=True, db_comment='The metadata of the LDAP server used to authenticate and authorize connections to the broker.', null=True)),
                ('logs', models.JSONField(blank=True, db_comment='The list of information about logs currently enabled and pending to be deployed for the specified broker.', null=True)),
                ('pending_ldap_server_metadata', models.JSONField(blank=True, db_comment='The metadata of the LDAP server that will be used to authenticate and authorize connections to the broker after it is rebooted.', null=True)),
                ('maintenance_window_start_time', models.JSONField(blank=True, db_comment='The parameters that determine the WeeklyStartTime.', null=True)),
                ('pending_data_replication_metadata', models.JSONField(blank=True, db_comment='The pending replication details of the data replication-enabled broker. Only returned if pendingDataReplicationMode is set to CRDR.', null=True)),
                ('pending_security_groups', models.JSONField(blank=True, db_comment='The list of pending security groups to authorize connections to brokers.', null=True)),
                ('security_groups', models.JSONField(blank=True, db_comment='The list of rules (1 minimum, 125 maximum) that authorize connections to brokers.', null=True)),
                ('subnet_ids', models.JSONField(blank=True, db_comment='The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones.', null=True)),
                ('users', models.JSONField(blank=True, db_comment='The list of all broker usernames for the specified broker.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A list of tags attached to the broker.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_mq_broker',
                'db_table_comment': 'AWS MQ Broker',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsMskCluster',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that uniquely identifies the Cluster.', null=True)),
                ('cluster_name', models.TextField(blank=True, db_comment='The name of the cluster.', null=True)),
                ('active_operation_arn', models.TextField(blank=True, db_comment='Arn of active cluster operation.', null=True)),
                ('cluster_type', models.TextField(blank=True, db_comment='The type of the cluster.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The time when the cluster was created.', null=True)),
                ('current_version', models.TextField(blank=True, db_comment='The current version of the MSK cluster.', null=True)),
                ('state', models.TextField(blank=True, db_comment='Settings for open monitoring using Prometheus.', null=True)),
                ('cluster_configuration', models.JSONField(blank=True, db_comment='Description of this MSK configuration.', null=True)),
                ('cluster_operation', models.JSONField(blank=True, db_comment='Description of this MSK operation.', null=True)),
                ('provisioned', models.JSONField(blank=True, db_comment='Information about the provisioned cluster.', null=True)),
                ('state_info', models.JSONField(blank=True, db_comment='State Info for the Amazon MSK cluster.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A list of tags attached to the Cluster.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_msk_cluster',
                'db_table_comment': 'AWS Managed Streaming for Apache Kafka',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsMskServerlessCluster',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that uniquely identifies the Cluster.', null=True)),
                ('cluster_name', models.TextField(blank=True, db_comment='The name of the cluster.', null=True)),
                ('active_operation_arn', models.TextField(blank=True, db_comment='Arn of active cluster operation.', null=True)),
                ('cluster_type', models.TextField(blank=True, db_comment='The type of the cluster.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The time when the cluster was created.', null=True)),
                ('current_version', models.TextField(blank=True, db_comment='The current version of the MSK cluster.', null=True)),
                ('state', models.TextField(blank=True, db_comment='Settings for open monitoring using Prometheus.', null=True)),
                ('cluster_operation', models.JSONField(blank=True, db_comment='Description of this MSK operation.', null=True)),
                ('serverless', models.JSONField(blank=True, db_comment='Information about the serverless cluster.', null=True)),
                ('state_info', models.JSONField(blank=True, db_comment='State Info for the Amazon MSK cluster.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A list of tags attached to the Cluster.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_msk_serverless_cluster',
                'db_table_comment': 'AWS Serverless Managed Streaming for Apache Kafka',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsNeptuneDbCluster',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_cluster_identifier', models.TextField(blank=True, db_comment='Contains a user-supplied DB cluster identifier. This identifier is the unique key that identifies a DB cluster.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the DB cluster.', null=True)),
                ('status', models.TextField(blank=True, db_comment='Specifies the current state of this DB cluster.', null=True)),
                ('cluster_create_time', models.DateTimeField(blank=True, db_comment='Specifies the time when the DB cluster was created, in Universal Coordinated Time (UTC).', null=True)),
                ('allocated_storage', models.BigIntegerField(blank=True, db_comment='AllocatedStorage always returns 1, because Neptune DB cluster storage size is not fixed, but instead automatically adjusts as needed.', null=True)),
                ('automatic_restart_time', models.DateTimeField(blank=True, db_comment='Time at which the DB cluster will be automatically restarted.', null=True)),
                ('backup_retention_period', models.BigIntegerField(blank=True, db_comment='Specifies the number of days for which automatic DB snapshots are retained.', null=True)),
                ('clone_group_id', models.TextField(blank=True, db_comment='Identifies the clone group to which the DB cluster is associated.', null=True)),
                ('copy_tags_to_snapshot', models.BooleanField(blank=True, db_comment='If set to true, tags are copied to any snapshot of the DB cluster that is created.', null=True)),
                ('cross_account_clone', models.BooleanField(blank=True, db_comment='If set to true, the DB cluster can be cloned across accounts.', null=True)),
                ('db_cluster_parameter_group', models.TextField(blank=True, db_comment='Specifies the name of the DB cluster parameter group for the DB cluster.', null=True)),
                ('db_subnet_group', models.TextField(blank=True, db_comment='Specifies information on the subnet group associated with the DB cluster.', null=True)),
                ('database_name', models.TextField(blank=True, db_comment='Contains the name of the initial database of this DB cluster that was provided.', null=True)),
                ('db_cluster_resource_id', models.TextField(blank=True, db_comment='The Amazon Region-unique, immutable identifier for the DB cluster.', null=True)),
                ('deletion_protection', models.BooleanField(blank=True, db_comment='Indicates whether or not the DB cluster has deletion protection enabled.', null=True)),
                ('earliest_restorable_time', models.DateTimeField(blank=True, db_comment='Specifies the earliest time to which a database can be restored with point-in-time restore.', null=True)),
                ('endpoint', models.TextField(blank=True, db_comment='Specifies the connection endpoint for the primary instance of the DB cluster.', null=True)),
                ('engine', models.TextField(blank=True, db_comment='Provides the name of the database engine to be used for this DB cluster.', null=True)),
                ('engine_version', models.TextField(blank=True, db_comment='Indicates the database engine version.', null=True)),
                ('hosted_zone_id', models.TextField(blank=True, db_comment='Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.', null=True)),
                ('iam_database_authentication_enabled', models.BooleanField(blank=True, db_comment='True if mapping of Amazon Identity and Access Management (IAM) accounts to database accounts is enabled, and otherwise false.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='If StorageEncrypted is true, the Amazon KMS key identifier for the encrypted DB cluster.', null=True)),
                ('latest_restorable_time', models.DateTimeField(blank=True, db_comment='Specifies the latest time to which a database can be restored with point-in-time restore.', null=True)),
                ('multi_az', models.BooleanField(blank=True, db_comment='Specifies whether the DB cluster has instances in multiple Availability Zones.', null=True)),
                ('percent_progress', models.TextField(blank=True, db_comment='Specifies the progress of the operation as a percentage.', null=True)),
                ('port', models.BigIntegerField(blank=True, db_comment='Specifies the port that the database engine is listening on.', null=True)),
                ('preferred_backup_window', models.TextField(blank=True, db_comment='Specifies the daily time range during which automated backups are created if automated backups are enabled, as determined by the BackupRetentionPeriod.', null=True)),
                ('preferred_maintenance_window', models.TextField(blank=True, db_comment='Specifies the weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).', null=True)),
                ('reader_endpoint', models.TextField(blank=True, db_comment='The reader endpoint for the DB cluster.', null=True)),
                ('storage_encrypted', models.BooleanField(blank=True, db_comment='Specifies whether the DB cluster is encrypted.', null=True)),
                ('associated_roles', models.JSONField(blank=True, db_comment='Provides a list of the Amazon Identity and Access Management (IAM) roles.', null=True)),
                ('availability_zones', models.JSONField(blank=True, db_comment='Provides the list of EC2 Availability Zones that instances in the DB cluster can be created in.', null=True)),
                ('db_cluster_members', models.JSONField(blank=True, db_comment='Provides the list of instances that make up the DB cluster.', null=True)),
                ('enabled_cloudwatch_logs_exports', models.JSONField(blank=True, db_comment='A list of log types that this DB cluster is configured to export to CloudWatch Logs.', null=True)),
                ('read_replica_identifiers', models.JSONField(blank=True, db_comment='Contains one or more identifiers of the Read Replicas associated with this DB cluster.', null=True)),
                ('vpc_security_groups', models.JSONField(blank=True, db_comment='Provides a list of VPC security groups that the DB cluster belongs to.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_neptune_db_cluster',
                'db_table_comment': 'AWS Neptune DB Cluster',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsNeptuneDbClusterSnapshot',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_cluster_snapshot_identifier', models.TextField(blank=True, db_comment='Specifies the identifier for a DB cluster snapshot. Must match the identifier of an existing snapshot.', null=True)),
                ('db_cluster_snapshot_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the DB cluster snapshot.', null=True)),
                ('snapshot_type', models.TextField(blank=True, db_comment='Provides the type of the DB cluster snapshot.', null=True)),
                ('status', models.TextField(blank=True, db_comment='Specifies the status of this DB cluster snapshot.', null=True)),
                ('db_cluster_identifier', models.TextField(blank=True, db_comment='Specifies the DB cluster identifier of the DB cluster that this DB cluster snapshot was created from.', null=True)),
                ('cluster_create_time', models.DateTimeField(blank=True, db_comment='Specifies the time when the DB cluster was created, in Universal Coordinated Time (UTC).', null=True)),
                ('allocated_storage', models.BigIntegerField(blank=True, db_comment='Specifies the allocated storage size in gibibytes (GiB).', null=True)),
                ('snapshot_create_time', models.DateTimeField(blank=True, db_comment='Provides the time when the snapshot was taken, in Universal Coordinated Time (UTC).', null=True)),
                ('percent_progress', models.BigIntegerField(blank=True, db_comment='Specifies the percentage of the estimated data that has been transferred.', null=True)),
                ('source_db_cluster_snapshot_arn', models.TextField(blank=True, db_comment='If the DB cluster snapshot was copied from a source DB cluster snapshot, the Amazon Resource Name (ARN) for the source DB cluster snapshot, otherwise, a null value.', null=True)),
                ('engine', models.TextField(blank=True, db_comment='Specifies the name of the database engine.', null=True)),
                ('engine_version', models.TextField(blank=True, db_comment='Provides the version of the database engine for this DB cluster snapshot.', null=True)),
                ('iam_database_authentication_enabled', models.BooleanField(blank=True, db_comment='True if mapping of Amazon Identity and Access Management (IAM) accounts to database accounts is enabled, and otherwise false.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='If StorageEncrypted is true, the Amazon KMS key identifier for the encrypted DB cluster snapshot.', null=True)),
                ('license_model', models.TextField(blank=True, db_comment='Provides the license model information for this DB cluster snapshot.', null=True)),
                ('master_username', models.TextField(blank=True, db_comment='Not supported by Neptune.', null=True)),
                ('port', models.BigIntegerField(blank=True, db_comment='Specifies the port that the DB cluster was listening on at the time of the snapshot.', null=True)),
                ('storage_encrypted', models.BooleanField(blank=True, db_comment='Specifies whether the DB cluster snapshot is encrypted.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='Provides the VPC ID associated with the DB cluster snapshot.', null=True)),
                ('availability_zones', models.JSONField(blank=True, db_comment='Provides the list of EC2 Availability Zones that instances in the DB cluster snapshot can be restored in.', null=True)),
                ('db_cluster_snapshot_attributes', models.JSONField(blank=True, db_comment='A list of DB cluster snapshot attribute names and values for a manual DB cluster snapshot.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_neptune_db_cluster_snapshot',
                'db_table_comment': 'AWS Neptune DB Cluster Snapshot',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsNetworkfirewallFirewall',
            fields=[
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the firewall.', null=True)),
                ('name', models.TextField(blank=True, db_comment='The descriptive name of the firewall.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The unique identifier of the VPC where the firewall is in use.', null=True)),
                ('delete_protection', models.BooleanField(blank=True, db_comment='A flag indicating whether it is possible to delete the firewall.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the firewall.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The unique identifier for the firewall.', primary_key=True, serialize=False)),
                ('policy_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the firewall policy.', null=True)),
                ('policy_change_protection', models.BooleanField(blank=True, db_comment='A setting indicating whether the firewall is protected against a change to the firewall policy association.', null=True)),
                ('subnet_change_protection', models.BooleanField(blank=True, db_comment='A setting indicating whether the firewall is protected against changes to the subnet associations.', null=True)),
                ('encryption_configuration', models.JSONField(blank=True, db_comment='A complex type that contains the Amazon Web Services KMS encryption configuration settings for the firewall.', null=True)),
                ('firewall_status', models.JSONField(blank=True, db_comment='Detailed information about the current status of a Firewall.', null=True)),
                ('subnet_mappings', models.JSONField(blank=True, db_comment='The public subnets that Network Firewall is using for the firewall.', null=True)),
                ('logging_configuration', models.JSONField(blank=True, db_comment='Defines how Network Firewall performs logging for a Firewall.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with the firewall', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_networkfirewall_firewall',
                'db_table_comment': 'AWS Network Firewall Firewall',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsNetworkfirewallFirewallPolicy',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The descriptive name of the rule group.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the rule group.', null=True)),
                ('firewall_policy_id', models.TextField(blank=True, db_comment='The unique identifier for the firewall policy.', null=True)),
                ('consumed_stateful_rule_capacity', models.BigIntegerField(blank=True, db_comment="The number of capacity units currently consumed by the policy's stateful rules.", null=True)),
                ('consumed_stateless_rule_capacity', models.BigIntegerField(blank=True, db_comment="The number of capacity units currently consumed by the policy's stateless rules.", null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the firewall policy.', null=True)),
                ('firewall_policy_status', models.TextField(blank=True, db_comment='The current status of the firewall policy.', null=True)),
                ('last_modified_time', models.DateTimeField(blank=True, db_comment='The last time that the firewall policy was changed.', null=True)),
                ('number_of_associations', models.BigIntegerField(blank=True, db_comment='The number of firewall policies that use this rule group.', null=True)),
                ('encryption_configuration', models.JSONField(blank=True, db_comment='A complex type that contains the Amazon Web Services KMS encryption configuration settings for your firewall policy.', null=True)),
                ('firewall_policy', models.JSONField(blank=True, db_comment='The policy for the specified firewall policy.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_networkfirewall_firewall_policy',
                'db_table_comment': 'AWS Network Firewall Policy',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsNetworkfirewallRuleGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('rule_group_name', models.TextField(blank=True, db_comment='The descriptive name of the rule group.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the rule group.', null=True)),
                ('capacity', models.BigIntegerField(blank=True, db_comment='The maximum operating resources that this rule group can use. Rule group capacity is fixed at creation. When you update a rule group, you are limited to this capacity. When you reference a rule group from a firewall policy, Network Firewall reserves this capacity for the rule group.', null=True)),
                ('consumed_capacity', models.BigIntegerField(blank=True, db_comment='The number of capacity units currently consumed by the rule group rules.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the rule group.', null=True)),
                ('number_of_associations', models.BigIntegerField(blank=True, db_comment='The number of firewall policies that use this rule group.', null=True)),
                ('rule_group_id', models.TextField(blank=True, db_comment='The unique identifier for the rule group.', null=True)),
                ('rule_group_status', models.TextField(blank=True, db_comment='Detailed information about the current status of a rule group.', null=True)),
                ('rule_variables', models.JSONField(blank=True, db_comment='Settings that are available for use in the rules in the rule group. You can only use these for stateful rule groups.', null=True)),
                ('rules_source', models.JSONField(blank=True, db_comment='The stateful rules or stateless rules for the rule group.', null=True)),
                ('stateful_rule_options', models.JSONField(blank=True, db_comment='Additional options governing how Network Firewall handles the rule group. You can only use these for stateful rule groups.', null=True)),
                ('type', models.TextField(blank=True, db_comment='Indicates whether the rule group is stateless or stateful. If the rule group is stateless, it contains stateless rules. If it is stateful, it contains stateful rules.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_networkfirewall_rule_group',
                'db_table_comment': 'AWS Network Firewall Rule Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsOamLink',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The random ID string that Amazon Web Service generates as part of the link ARN.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the link.', null=True)),
                ('sink_arn', models.TextField(blank=True, db_comment='The ARN of the sink that this link is attached to.', null=True)),
                ('label', models.TextField(blank=True, db_comment='The label that was assigned to this link at creation, with the variables resolved to their actual values.', null=True)),
                ('label_template', models.TextField(blank=True, db_comment='The exact label template that was specified when the link was created, with the template variables not resolved.', null=True)),
                ('resource_types', models.JSONField(blank=True, db_comment='The resource types supported by this link.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_oam_link',
                'db_table_comment': 'AWS OAM Link',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsOamSink',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the sink.', primary_key=True, serialize=False)),
                ('id', models.TextField(blank=True, db_comment='The random ID string that Amazon Web Service generates as part of the sink ARN.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the sink.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_oam_sink',
                'db_table_comment': 'AWS OAM Sink',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsOpensearchDomain',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('domain_name', models.TextField(blank=True, db_comment='The name of the domain.', null=True)),
                ('engine_type', models.TextField(blank=True, db_comment='Specifies the EngineType of the domain.', null=True)),
                ('domain_id', models.TextField(blank=True, db_comment='The unique identifier for the specified domain.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the domain.', null=True)),
                ('access_policies', models.TextField(blank=True, db_comment='The IAM access policies of the domain.', null=True)),
                ('created', models.BooleanField(blank=True, db_comment='The domain creation status.', null=True)),
                ('deleted', models.BooleanField(blank=True, db_comment='The domain deletion status.', null=True)),
                ('endpoint', models.TextField(blank=True, db_comment='The domain endpoint that is used to submit index and search requests.', null=True)),
                ('engine_version', models.TextField(blank=True, db_comment="The domain's OpenSearch version.", null=True)),
                ('processing', models.BooleanField(blank=True, db_comment='The status of the domain configuration.', null=True)),
                ('upgrade_processing', models.BooleanField(blank=True, db_comment='The status of the domain version upgrade.', null=True)),
                ('node_to_node_encryption_options_enabled', models.BooleanField(blank=True, db_comment='Specifies the status of the node to node encryption status.', null=True)),
                ('advanced_options', models.JSONField(blank=True, db_comment='Specifies the status of the advanced options.', null=True)),
                ('advanced_security_options', models.JSONField(blank=True, db_comment="Specifies The current status of the OpenSearch domain's advanced security options.", null=True)),
                ('auto_tune_options', models.JSONField(blank=True, db_comment="The current status of the domain's auto-tune options.", null=True)),
                ('cluster_config', models.JSONField(blank=True, db_comment='The type and number of instances in the domain.', null=True)),
                ('cognito_options', models.JSONField(blank=True, db_comment='The cognito options for the specified domain.', null=True)),
                ('domain_endpoint_options', models.JSONField(blank=True, db_comment="The current status of the domain's endpoint options.", null=True)),
                ('ebs_options', models.JSONField(blank=True, db_comment='The EBSOptions for the specified domain.', null=True)),
                ('encryption_at_rest_options', models.JSONField(blank=True, db_comment='The status of the encryption at rest options.', null=True)),
                ('endpoints', models.JSONField(blank=True, db_comment='Map containing the domain endpoints used to submit index and search requests.', null=True)),
                ('log_publishing_options', models.JSONField(blank=True, db_comment='Log publishing options for the given domain.', null=True)),
                ('service_software_options', models.JSONField(blank=True, db_comment="The current status of the domain's service software.", null=True)),
                ('snapshot_options', models.JSONField(blank=True, db_comment='Specifies the status of the snapshot options.', null=True)),
                ('vpc_options', models.JSONField(blank=True, db_comment='The vpc options for the specified domain.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the domain.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_opensearch_domain',
                'db_table_comment': 'AWS OpenSearch Domain',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsOrganizationsAccount',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The friendly name of the account.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The unique identifier (account ID) of the member account.', primary_key=True, serialize=False)),
                ('parent_id', models.TextField(blank=True, db_comment='The unique identifier (ID) for the parent root or organization unit (OU) whose accounts you want to list.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the account.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the account in the organization.', null=True)),
                ('email', models.TextField(blank=True, db_comment='The email address associated with the AWS account.', null=True)),
                ('joined_method', models.TextField(blank=True, db_comment='The method by which the account joined the organization.', null=True)),
                ('joined_timestamp', models.DateTimeField(blank=True, db_comment='The date the account became a part of the organization.', null=True)),
                ('tags_src', models.JSONField(blank=True, null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_organizations_account',
                'db_table_comment': 'AWS Organizations Account',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsOrganizationsOrganizationalUnit',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The friendly name of this OU.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The unique identifier (ID) associated with this OU.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of this OU.', null=True)),
                ('parent_id', models.TextField(blank=True, db_comment='The unique identifier (ID) of the root or OU whose child OUs you want to list.', null=True)),
                ('path', models.TextField(blank=True, db_comment='The OU path is a string representation that uniquely identifies the hierarchical location of an Organizational Unit within the AWS Organizations structure.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_organizations_organizational_unit',
                'db_table_comment': 'AWS Organizations Organizational Unit',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsOrganizationsRoot',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The friendly name of the root.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The unique identifier (ID) for the root.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the root.', null=True)),
                ('policy_types', models.JSONField(blank=True, db_comment='The types of policies that are currently enabled for the root and therefore can be attached to the root or to its OUs or accounts.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_organizations_root',
                'db_table_comment': 'AWS Organizations Root',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsPinpointApp',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The unique identifier for the application.', primary_key=True, serialize=False)),
                ('name', models.TextField(blank=True, db_comment='The display name of the application.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the application.', null=True)),
                ('last_modified_date', models.DateTimeField(blank=True, db_comment="The date and time, in ISO 8601 format, when the application's settings were last modified.", null=True)),
                ('campaign_hook', models.JSONField(blank=True, db_comment='The settings for the AWS Lambda function to invoke by default as a code hook for campaigns in the application.', null=True)),
                ('limits', models.JSONField(blank=True, db_comment='The default sending limits for campaigns in the application.', null=True)),
                ('quiet_time', models.JSONField(blank=True, db_comment='The default quiet time for campaigns in the application.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_pinpoint_app',
                'db_table_comment': 'AWS Pinpoint App',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsPipesPipe',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the pipe.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the pipe.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The time the pipe was created.', null=True)),
                ('current_state', models.TextField(blank=True, db_comment='The state the pipe is in.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the pipe.', null=True)),
                ('desired_state', models.TextField(blank=True, db_comment='The state the pipe should be in.', null=True)),
                ('enrichment', models.TextField(blank=True, db_comment='The ARN of the enrichment resource.', null=True)),
                ('last_modified_time', models.DateTimeField(blank=True, db_comment='When the pipe was last updated.', null=True)),
                ('role_arn', models.TextField(blank=True, db_comment='The ARN of the role that allows the pipe to send data to the target.', null=True)),
                ('source', models.TextField(blank=True, db_comment='The ARN of the source resource.', null=True)),
                ('source_prefix', models.TextField(blank=True, db_comment='The prefix matching the pipe source.', null=True)),
                ('state_reason', models.TextField(blank=True, db_comment='The reason the pipe is in its current state.', null=True)),
                ('target', models.TextField(blank=True, db_comment='The ARN of the target resource.', null=True)),
                ('target_prefix', models.TextField(blank=True, db_comment='The prefix matching the pipe target.', null=True)),
                ('enrichment_parameters', models.JSONField(blank=True, db_comment='The parameters required to set up enrichment on your pipe.', null=True)),
                ('target_parameters', models.JSONField(blank=True, db_comment='The parameters required to set up a target for your pipe.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_pipes_pipe',
                'db_table_comment': 'AWS Pipes Pipe',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsPricingServiceAttribute',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('service_code', models.TextField(blank=True, db_comment='The service code of the AWS service.', null=True)),
                ('attribute_name', models.TextField(blank=True, db_comment='The supported attribute names for the service.', null=True)),
                ('attribute_values', models.JSONField(blank=True, db_comment='The supported attribute values for the service and attribute name.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_pricing_service_attribute',
                'db_table_comment': 'AWS Pricing Service Attribute',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRamPrincipalAssociation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('resource_share_name', models.TextField(blank=True, db_comment='The name of the resource share.', null=True)),
                ('resource_share_arn', models.TextField(blank=True, db_comment='The Amazon Resoure Name (ARN) of the resource share.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current status of the association.', null=True)),
                ('associated_entity', models.TextField(blank=True, db_comment='The ID of an Amazon Web Services account/The Amazon Resoure Name (ARN) of an organization in Organizations/The ARN of an organizational unit (OU) in Organizations/The ARN of an IAM role The ARN of an IAM user.', null=True)),
                ('association_type', models.TextField(blank=True, db_comment='The type of entity included in this association.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The date and time when the association was created.', null=True)),
                ('external', models.BooleanField(blank=True, db_comment='Indicates whether the principal belongs to the same organization in Organizations as the Amazon Web Services account that owns the resource share.', null=True)),
                ('last_updated_time', models.DateTimeField(blank=True, db_comment='The date and time when the association was last updated..', null=True)),
                ('status_message', models.TextField(blank=True, db_comment='A message about the status of the association.', null=True)),
                ('resource_share_permission', models.JSONField(blank=True, db_comment='Information about an RAM permission that is associated with a resource share and any of its resources of a specified type.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ram_principal_association',
                'db_table_comment': 'AWS RAM Principal Association',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRamResourceAssociation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('resource_share_name', models.TextField(blank=True, db_comment='The name of the resource share.', null=True)),
                ('resource_share_arn', models.TextField(blank=True, db_comment='The Amazon Resoure Name (ARN) of the resource share.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current status of the association.', null=True)),
                ('associated_entity', models.TextField(blank=True, db_comment='The Amazon Resoure Name (ARN) of the associated resource.', null=True)),
                ('association_type', models.TextField(blank=True, db_comment='The type of entity included in this association.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The date and time when the association was created.', null=True)),
                ('external', models.BooleanField(blank=True, db_comment='Indicates whether the principal belongs to the same organization in Organizations as the Amazon Web Services account that owns the resource share.', null=True)),
                ('last_updated_time', models.DateTimeField(blank=True, db_comment='The date and time when the association was last updated..', null=True)),
                ('status_message', models.TextField(blank=True, db_comment='A message about the status of the association.', null=True)),
                ('resource_share_permission', models.JSONField(blank=True, db_comment='Information about an RAM permission that is associated with a resource share and any of its resources of a specified type.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ram_resource_association',
                'db_table_comment': 'AWS RAM Resource Association',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbCluster',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_cluster_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Cluster.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the DB Cluster.', null=True)),
                ('status', models.TextField(blank=True, db_comment='Specifies the status of this DB Cluster.', null=True)),
                ('resource_id', models.TextField(blank=True, db_comment='The AWS Region-unique, immutable identifier for the DB cluster.', null=True)),
                ('create_time', models.DateTimeField(blank=True, db_comment='Specifies the time when the DB cluster was created.', null=True)),
                ('activity_stream_kinesis_stream_name', models.TextField(blank=True, db_comment='The name of the Amazon Kinesis data stream used for the database activity stream.', null=True)),
                ('activity_stream_kms_key_id', models.TextField(blank=True, db_comment='The AWS KMS key identifier used for encrypting messages in the database activity stream.', null=True)),
                ('activity_stream_mode', models.TextField(blank=True, db_comment='The mode of the database activity stream.', null=True)),
                ('activity_stream_status', models.TextField(blank=True, db_comment='The status of the database activity stream.', null=True)),
                ('allocated_storage', models.BigIntegerField(blank=True, db_comment='Specifies the allocated storage size in gibibytes (GiB).', null=True)),
                ('auto_minor_version_upgrade', models.BooleanField(blank=True, db_comment='A value that indicates that minor version patches are applied automatically. This setting is only for non-Aurora Multi-AZ DB clusters.', null=True)),
                ('backtrack_consumed_change_records', models.BigIntegerField(blank=True, db_comment='The number of change records stored for Backtrack.', null=True)),
                ('backtrack_window', models.BigIntegerField(blank=True, db_comment='The target backtrack window, in seconds.', null=True)),
                ('backup_retention_period', models.BigIntegerField(blank=True, db_comment='Specifies the number of days for which automatic DB snapshots are retained.', null=True)),
                ('capacity', models.BigIntegerField(blank=True, db_comment='The current capacity of an Aurora Serverless DB cluster.', null=True)),
                ('character_set_name', models.TextField(blank=True, db_comment='Specifies the name of the character set that this cluster is associated with.', null=True)),
                ('clone_group_id', models.TextField(blank=True, db_comment='Identifies the clone group to which the DB cluster is associated.', null=True)),
                ('copy_tags_to_snapshot', models.BooleanField(blank=True, db_comment='Specifies whether tags are copied from the DB cluster to snapshots of the DB cluster, or not.', null=True)),
                ('cross_account_clone', models.BooleanField(blank=True, db_comment='Specifies whether the DB cluster is a clone of a DB cluster owned by a different AWS account, or not.', null=True)),
                ('database_name', models.TextField(blank=True, db_comment='Contains the name of the initial database of this DB cluster that was provided at create time.', null=True)),
                ('db_cluster_parameter_group', models.TextField(blank=True, db_comment='Specifies the name of the DB cluster parameter group for the DB cluster.', null=True)),
                ('db_subnet_group', models.TextField(blank=True, db_comment='Specifies information on the subnet group associated with the DB cluster.', null=True)),
                ('deletion_protection', models.BooleanField(blank=True, db_comment='Specifies whether the DB cluster has deletion protection enabled, or not.', null=True)),
                ('earliest_backtrack_time', models.DateTimeField(blank=True, db_comment='The earliest time to which a DB cluster can be backtracked.', null=True)),
                ('earliest_restorable_time', models.DateTimeField(blank=True, db_comment='The earliest time to which a database can be restored with point-in-time restore.', null=True)),
                ('endpoint', models.TextField(blank=True, db_comment='Specifies the connection endpoint for the primary instance of the DB cluster.', null=True)),
                ('engine', models.TextField(blank=True, db_comment='The name of the database engine to be used for this DB cluster.', null=True)),
                ('engine_mode', models.TextField(blank=True, db_comment='The DB engine mode of the DB cluster.', null=True)),
                ('engine_version', models.TextField(blank=True, db_comment='Indicates the database engine version.', null=True)),
                ('global_write_forwarding_requested', models.BooleanField(blank=True, db_comment='Specifies whether you have requested to enable write forwarding for a secondary cluster in an Aurora global database, or not.', null=True)),
                ('global_write_forwarding_status', models.TextField(blank=True, db_comment='Specifies whether a secondary cluster in an Aurora global database has write forwarding enabled, or not.', null=True)),
                ('hosted_zone_id', models.TextField(blank=True, db_comment='Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.', null=True)),
                ('http_endpoint_enabled', models.BooleanField(blank=True, db_comment='Specifies whether the HTTP endpoint for an Aurora Serverless DB cluster is enabled, or not.', null=True)),
                ('iam_database_authentication_enabled', models.BooleanField(blank=True, db_comment='Specifies whether the the mapping of AWS IAM accounts to database accounts is enabled, or not.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The AWS KMS key identifier for the encrypted DB cluster.', null=True)),
                ('latest_restorable_time', models.DateTimeField(blank=True, db_comment='Specifies the latest time to which a database can be restored with point-in-time restore.', null=True)),
                ('master_user_name', models.TextField(blank=True, db_comment='Contains the master username for the DB cluster.', null=True)),
                ('multi_az', models.BooleanField(blank=True, db_comment='Specifies whether the DB cluster has instances in multiple Availability Zones, or not.', null=True)),
                ('percent_progress', models.TextField(blank=True, db_comment='Specifies the progress of the operation as a percentage.', null=True)),
                ('port', models.BigIntegerField(blank=True, db_comment='Specifies the port that the database engine is listening on.', null=True)),
                ('preferred_backup_window', models.TextField(blank=True, db_comment='Specifies the daily time range during which automated backups are created.', null=True)),
                ('preferred_maintenance_window', models.TextField(blank=True, db_comment='Specifies the weekly time range during which system maintenance can occur', null=True)),
                ('reader_endpoint', models.TextField(blank=True, db_comment='The reader endpoint for the DB cluster.', null=True)),
                ('storage_encrypted', models.BooleanField(blank=True, db_comment='Specifies whether the DB cluster is encrypted, or not.', null=True)),
                ('associated_roles', models.JSONField(blank=True, db_comment='A list of AWS IAM roles that are associated with the DB cluster.', null=True)),
                ('availability_zones', models.JSONField(blank=True, db_comment='A list of Availability Zones (AZs) where instances in the DB cluster can be created.', null=True)),
                ('custom_endpoints', models.JSONField(blank=True, db_comment='A list of all custom endpoints associated with the cluster.', null=True)),
                ('members', models.JSONField(blank=True, db_comment='A list of instances that make up the DB cluster.', null=True)),
                ('option_group_memberships', models.JSONField(blank=True, db_comment='A list of option group memberships for this DB cluster.', null=True)),
                ('domain_memberships', models.JSONField(blank=True, db_comment='A list of Active Directory Domain membership records associated with the DB cluster.', null=True)),
                ('enabled_cloudwatch_logs_exports', models.JSONField(blank=True, db_comment='A list of log types that this DB cluster is configured to export to CloudWatch Logs.', null=True)),
                ('pending_maintenance_actions', models.JSONField(blank=True, db_comment='A list that provides details about the pending maintenance actions for the resource.', null=True)),
                ('read_replica_identifiers', models.JSONField(blank=True, db_comment='A list of identifiers of the read replicas associated with this DB cluster.', null=True)),
                ('vpc_security_groups', models.JSONField(blank=True, db_comment='A list of VPC security groups that the DB cluster belongs to.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the DB Cluster.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_cluster',
                'db_table_comment': 'AWS RDS DB Cluster',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbClusterParameterGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The friendly name to identify the DB cluster parameter group.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the DB cluster parameter group.', null=True)),
                ('description', models.TextField(blank=True, db_comment='Provides the customer-specified description for this DB cluster parameter group.', null=True)),
                ('db_parameter_group_family', models.TextField(blank=True, db_comment='The name of the DB parameter group family that this DB cluster parameter group is compatible with.', null=True)),
                ('parameters', models.JSONField(blank=True, db_comment='A list of detailed parameter for a particular DB Cluster parameter group.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the DB Cluster parameter group.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_cluster_parameter_group',
                'db_table_comment': 'AWS RDS DB Cluster Parameter Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbClusterSnapshot',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_cluster_snapshot_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Cluster Snapshot.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the DB Cluster Snapshot.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of the DB Cluster Snapshot.', null=True)),
                ('status', models.TextField(blank=True, db_comment='Specifies the status of this DB Cluster Snapshot.', null=True)),
                ('db_cluster_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Cluster, that the snapshot snapshot was created from.', null=True)),
                ('create_time', models.DateTimeField(blank=True, db_comment='The time when the snapshot was taken.', null=True)),
                ('allocated_storage', models.BigIntegerField(blank=True, db_comment='Specifies the allocated storage size in gibibytes (GiB).', null=True)),
                ('cluster_create_time', models.DateTimeField(blank=True, db_comment='Specifies the time when the DB cluster was created.', null=True)),
                ('engine', models.TextField(blank=True, db_comment='Specifies the name of the database engine.', null=True)),
                ('engine_version', models.TextField(blank=True, db_comment='Specifies the version of the database engine for this DB cluster snapshot.', null=True)),
                ('iam_database_authentication_enabled', models.BooleanField(blank=True, db_comment='Specifies whether mapping of AWS Identity and Access Management (IAM) accounts to database accounts is enabled, or not.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The AWS KMS key identifier for the AWS KMS customer master key (CMK).', null=True)),
                ('license_model', models.TextField(blank=True, db_comment='Provides the license model information for this DB cluster snapshot.', null=True)),
                ('master_user_name', models.TextField(blank=True, db_comment='Provides the master username for the DB cluster snapshot.', null=True)),
                ('percent_progress', models.BigIntegerField(blank=True, db_comment='Specifies the percentage of the estimated data that has been transferred.', null=True)),
                ('port', models.BigIntegerField(blank=True, db_comment='Specifies the port that the DB cluster was listening on at the time of the snapshot.', null=True)),
                ('source_db_cluster_snapshot_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the source DB cluster snapshot, if the DB cluster snapshot was copied from a source DB cluster snapshot.', null=True)),
                ('storage_encrypted', models.BooleanField(blank=True, db_comment='Specifies whether the DB cluster snapshot is encrypted, or not.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='Provides the VPC ID associated with the DB cluster snapshot.', null=True)),
                ('availability_zones', models.JSONField(blank=True, db_comment='A list of Availability Zones (AZs) where instances in the DB cluster snapshot can be restored.', null=True)),
                ('db_cluster_snapshot_attributes', models.JSONField(blank=True, db_comment='A list of DB cluster snapshot attribute names and values for a manual DB cluster snapshot.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the DB Cluster Snapshot.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_cluster_snapshot',
                'db_table_comment': 'AWS RDS DB Cluster Snapshot',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbEngineVersion',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('engine', models.TextField(blank=True, db_comment='The name of the database engine.', null=True)),
                ('engine_version', models.TextField(blank=True, db_comment='The version number of the database engine.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the custom engine version.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the DB engine version, either available or deprecated.', null=True)),
                ('create_time', models.DateTimeField(blank=True, db_comment='The creation time of the DB engine version.', null=True)),
                ('custom_db_engine_version_manifest', models.TextField(blank=True, db_comment='JSON string that lists the installation files and parameters that RDS Custom uses to create a custom engine version (CEV).', null=True)),
                ('list_supported_character_sets', models.BooleanField(blank=True, db_comment='A value that indicates whether to list the supported character sets for each engine version.', null=True)),
                ('engine_mode', models.TextField(blank=True, db_comment='Accepts DB engine modes.', null=True)),
                ('list_supported_timezones', models.BooleanField(blank=True, db_comment='A value that indicates whether to list the supported time zones for each engine version.', null=True)),
                ('default_only', models.BooleanField(blank=True, db_comment='A value that indicates whether only the default version of the specified engine or engine and major version combination is returned.', null=True)),
                ('db_engine_description', models.TextField(blank=True, db_comment='The description of the database engine.', null=True)),
                ('db_engine_media_type', models.TextField(blank=True, db_comment='A value that indicates the source media provider of the AMI based on the usage operation. Applicable for RDS Custom for SQL Server.', null=True)),
                ('db_engine_version_description', models.TextField(blank=True, db_comment='The description of the database engine version.', null=True)),
                ('db_parameter_group_family', models.TextField(blank=True, db_comment='The name of the DB parameter group family for the database engine.', null=True)),
                ('database_installation_files_s3_bucket_name', models.TextField(blank=True, db_comment='The name of the Amazon S3 bucket that contains your database installation files.', null=True)),
                ('database_installation_files_s3_prefix', models.TextField(blank=True, db_comment='The Amazon S3 directory that contains the database installation files. If not specified, then no prefix is assumed.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The Amazon Web Services KMS key identifier for an encrypted CEV. This parameter is required for RDS Custom, but optional for Amazon RDS.', null=True)),
                ('major_engine_version', models.TextField(blank=True, db_comment='The major engine version of the CEV.', null=True)),
                ('supports_babelfish', models.BooleanField(blank=True, db_comment='A value that indicates whether the engine version supports Babelfish for Aurora PostgreSQL.', null=True)),
                ('supports_certificate_rotation_without_restart', models.BooleanField(blank=True, db_comment='A value that indicates whether the engine version supports rotating the server certificate without rebooting the DB instance.', null=True)),
                ('supports_global_databases', models.BooleanField(blank=True, db_comment='A value that indicates whether you can use Aurora global databases with a specific DB engine version.', null=True)),
                ('supports_log_exports_to_cloudwatch_logs', models.BooleanField(blank=True, db_comment='A value that indicates whether the engine version supports exporting the log types specified by ExportableLogTypes to CloudWatch Logs.', null=True)),
                ('supports_parallel_query', models.BooleanField(blank=True, db_comment='A value that indicates whether you can use Aurora parallel query with a specific DB engine version.', null=True)),
                ('supports_read_replica', models.BooleanField(blank=True, db_comment='Indicates whether the database engine version supports read replicas.', null=True)),
                ('exportable_log_types', models.JSONField(blank=True, db_comment='The types of logs that the database engine has available for export to CloudWatch Logs.', null=True)),
                ('image', models.JSONField(blank=True, db_comment='The EC2 image.', null=True)),
                ('supported_feature_names', models.JSONField(blank=True, db_comment='A list of features supported by the DB engine.', null=True)),
                ('supported_nchar_character_sets', models.JSONField(blank=True, db_comment='A list of the character sets supported by the Oracle DB engine for the NcharCharacterSetName parameter of the CreateDBInstance operation.', null=True)),
                ('supported_timezones', models.JSONField(blank=True, db_comment='A list of the time zones supported by this engine for the Timezone parameter of the CreateDBInstance action.', null=True)),
                ('valid_upgrade_target', models.JSONField(blank=True, db_comment='A list of engine versions that this database engine version can be upgraded to.', null=True)),
                ('tag_list', models.JSONField(blank=True, db_comment='A list of tags.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_engine_version',
                'db_table_comment': 'AWS RDS DB Engine Version',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbEventSubscription',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cust_subscription_id', models.TextField(blank=True, db_comment='The RDS event notification subscription Id.', null=True)),
                ('customer_aws_id', models.TextField(blank=True, db_comment='The AWS customer account associated with the RDS event notification subscription.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the event subscription.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the RDS event notification subscription, it can be one of the following: creating | modifying | deleting | active | no-permission | topic-not-exist.', null=True)),
                ('enabled', models.BooleanField(blank=True, db_comment='A Boolean value indicating if the subscription is enabled. True indicates the subscription is enabled.', null=True)),
                ('sns_topic_arn', models.TextField(blank=True, db_comment='The topic ARN of the RDS event notification subscription.', null=True)),
                ('source_type', models.TextField(blank=True, db_comment='The source type for the RDS event notification subscription.', null=True)),
                ('subscription_creation_time', models.DateTimeField(blank=True, db_comment='The time the RDS event notification subscription was created.', null=True)),
                ('event_categories_list', models.JSONField(blank=True, db_comment='A list of event categories for the RDS event notification subscription.', null=True)),
                ('source_ids_list', models.JSONField(blank=True, db_comment='A list of source IDs for the RDS event notification subscription.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_event_subscription',
                'db_table_comment': 'AWS RDS DB Event Subscription',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbInstance',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_instance_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Instance.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the DB Instance.', null=True)),
                ('db_cluster_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB cluster, that the DB instance is a member of.', null=True)),
                ('status', models.TextField(blank=True, db_comment='Specifies the current state of this database.', null=True)),
                ('class_field', models.TextField(blank=True, db_column='class', db_comment='Contains the name of the compute and memory capacity class of the DB instance.', null=True)),
                ('resource_id', models.TextField(blank=True, db_comment='The AWS Region-unique, immutable identifier for the DB instance.', null=True)),
                ('allocated_storage', models.BigIntegerField(blank=True, db_comment='Specifies the allocated storage size specified in gibibytes(GiB).', null=True)),
                ('auto_minor_version_upgrade', models.BooleanField(blank=True, db_comment='Specifies whether minor version patches are applied automatically, or not.', null=True)),
                ('availability_zone', models.TextField(blank=True, db_comment='Specifies the name of the Availability Zone the DB instance is located in.', null=True)),
                ('backup_retention_period', models.BigIntegerField(blank=True, db_comment='Specifies the number of days for which automatic DB snapshots are retained.', null=True)),
                ('ca_certificate_identifier', models.TextField(blank=True, db_comment='The identifier of the CA certificate for this DB instance.', null=True)),
                ('character_set_name', models.TextField(blank=True, db_comment='Specifies the name of the character set that this instance is associated with.', null=True)),
                ('copy_tags_to_snapshot', models.BooleanField(blank=True, db_comment='Specifies whether tags are copied from the DB instance to snapshots of the DB instance, or not.', null=True)),
                ('customer_owned_ip_enabled', models.BooleanField(blank=True, db_comment='Specifies whether a customer-owned IP address (CoIP) is enabled for an RDS on Outposts DB instance, or not.', null=True)),
                ('port', models.BigIntegerField(blank=True, db_comment='Specifies the port that the DB instance listens on.', null=True)),
                ('db_name', models.TextField(blank=True, db_comment='Contains the name of the initial database of this instance that was provided at create time.', null=True)),
                ('db_subnet_group_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the DB subnet group.', null=True)),
                ('db_subnet_group_description', models.TextField(blank=True, db_comment='Provides the description of the DB subnet group.', null=True)),
                ('db_subnet_group_name', models.TextField(blank=True, db_comment='The name of the DB subnet group.', null=True)),
                ('db_subnet_group_status', models.TextField(blank=True, db_comment='Provides the status of the DB subnet group.', null=True)),
                ('deletion_protection', models.BooleanField(blank=True, db_comment='Specifies whether the DB instance has deletion protection enabled, or not.', null=True)),
                ('endpoint_address', models.TextField(blank=True, db_comment='Specifies the DNS address of the DB instance.', null=True)),
                ('endpoint_hosted_zone_id', models.TextField(blank=True, db_comment='Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.', null=True)),
                ('endpoint_port', models.BigIntegerField(blank=True, db_comment='Specifies the port that the database engine is listening on.', null=True)),
                ('engine', models.TextField(blank=True, db_comment='The name of the database engine to be used for this DB instance.', null=True)),
                ('engine_version', models.TextField(blank=True, db_comment='Indicates the database engine version.', null=True)),
                ('enhanced_monitoring_resource_arn', models.TextField(blank=True, db_comment='The ARN of the Amazon CloudWatch Logs log stream that receives the Enhanced Monitoring metrics data for the DB instance.', null=True)),
                ('iam_database_authentication_enabled', models.BooleanField(blank=True, db_comment='Specifies whether the the mapping of AWS IAM accounts to database accounts is enabled, or not.', null=True)),
                ('create_time', models.DateTimeField(blank=True, db_comment='Provides the date and time the DB instance was created.', null=True)),
                ('iops', models.BigIntegerField(blank=True, db_comment='Specifies the Provisioned IOPS (I/O operations per second) value.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The AWS KMS key identifier for the encrypted DB instance.', null=True)),
                ('latest_restorable_time', models.DateTimeField(blank=True, db_comment='Specifies the latest time to which a database can be restored with point-in-time restore.', null=True)),
                ('license_model', models.TextField(blank=True, db_comment='License model information for this DB instance.', null=True)),
                ('master_user_name', models.TextField(blank=True, db_comment='Contains the master username for the DB instance.', null=True)),
                ('max_allocated_storage', models.BigIntegerField(blank=True, db_comment='The upper limit to which Amazon RDS can automatically scale the storage of the DB instance.', null=True)),
                ('monitoring_interval', models.BigIntegerField(blank=True, db_comment='The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance.', null=True)),
                ('monitoring_role_arn', models.TextField(blank=True, db_comment='The ARN for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs.', null=True)),
                ('multi_az', models.BooleanField(blank=True, db_comment='Specifies if the DB instance is a Multi-AZ deployment.', null=True)),
                ('nchar_character_set_name', models.TextField(blank=True, db_comment='The name of the NCHAR character set for the Oracle DB instance.', null=True)),
                ('performance_insights_enabled', models.BooleanField(blank=True, db_comment='Specifies whether Performance Insights is enabled for the DB instance, or not.', null=True)),
                ('performance_insights_kms_key_id', models.TextField(blank=True, db_comment='The AWS KMS key identifier for encryption of Performance Insights data.', null=True)),
                ('performance_insights_retention_period', models.BigIntegerField(blank=True, db_comment='The amount of time, in days, to retain Performance Insights data.', null=True)),
                ('preferred_backup_window', models.TextField(blank=True, db_comment='Specifies the daily time range during which automated backups are created.', null=True)),
                ('preferred_maintenance_window', models.TextField(blank=True, db_comment='Specifies the weekly time range during which system maintenance can occur.', null=True)),
                ('promotion_tier', models.BigIntegerField(blank=True, db_comment='Specifies the order in which an Aurora Replica is promoted to the primary instance after a failure of the existing primary instance.', null=True)),
                ('publicly_accessible', models.BooleanField(blank=True, db_comment='Specifies the accessibility options for the DB instance.', null=True)),
                ('read_replica_source_db_instance_identifier', models.TextField(blank=True, db_comment='Contains the identifier of the source DB instance if this DB instance is a read replica.', null=True)),
                ('replica_mode', models.TextField(blank=True, db_comment='The mode of an Oracle read replica.', null=True)),
                ('secondary_availability_zone', models.TextField(blank=True, db_comment='Specifies the name of the secondary Availability Zone for a DB instance with multi-AZ support.', null=True)),
                ('storage_encrypted', models.BooleanField(blank=True, db_comment='Specifies whether the DB instance is encrypted, or not.', null=True)),
                ('storage_throughput', models.BigIntegerField(blank=True, db_comment='Specifies the storage throughput for the DB instance. This setting applies only to the gp3 storage type.', null=True)),
                ('storage_type', models.TextField(blank=True, db_comment='Specifies the storage type associated with DB instance.', null=True)),
                ('tde_credential_arn', models.TextField(blank=True, db_comment=' The ARN from the key store with which the instance is associated for TDE encryption.', null=True)),
                ('timezone', models.TextField(blank=True, db_comment='The time zone of the DB instance.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='Provides the VpcId of the DB subnet group.', null=True)),
                ('associated_roles', models.JSONField(blank=True, db_comment='A list of AWS IAM roles that are associated with the DB instance.', null=True)),
                ('certificate', models.JSONField(blank=True, db_comment='The CA certificate associated with the DB instance.', null=True)),
                ('db_parameter_groups', models.JSONField(blank=True, db_comment='A list of DB parameter groups applied to this DB instance.', null=True)),
                ('db_security_groups', models.JSONField(blank=True, db_comment='A list of DB security group associated with the DB instance.', null=True)),
                ('domain_memberships', models.JSONField(blank=True, db_comment='A list of Active Directory Domain membership records associated with the DB instance.', null=True)),
                ('enabled_cloudwatch_logs_exports', models.JSONField(blank=True, db_comment='A list of log types that this DB instance is configured to export to CloudWatch Logs.', null=True)),
                ('option_group_memberships', models.JSONField(blank=True, db_comment='A list of option group memberships for this DB instance', null=True)),
                ('pending_maintenance_actions', models.JSONField(blank=True, db_comment='A list that provides details about the pending maintenance actions for the resource.', null=True)),
                ('processor_features', models.JSONField(blank=True, db_comment='The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.', null=True)),
                ('read_replica_db_cluster_identifiers', models.JSONField(blank=True, db_comment='A list of identifiers of Aurora DB clusters to which the RDS DB instance is replicated as a read replica.', null=True)),
                ('read_replica_db_instance_identifiers', models.JSONField(blank=True, db_comment='A list of identifiers of the read replicas associated with this DB instance.', null=True)),
                ('status_infos', models.JSONField(blank=True, db_comment='The status of a read replica.', null=True)),
                ('subnets', models.JSONField(blank=True, db_comment='A list of subnet elements.', null=True)),
                ('vpc_security_groups', models.JSONField(blank=True, db_comment='A list of VPC security group elements that the DB instance belongs to.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the DB Instance.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_instance',
                'db_table_comment': 'AWS RDS DB Instance',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbInstanceAutomatedBackup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_instance_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Instance.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the replicated automated backups.', null=True)),
                ('db_instance_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the automated backups.', null=True)),
                ('status', models.TextField(blank=True, db_comment='Specifies the current state of this database.', null=True)),
                ('allocated_storage', models.BigIntegerField(blank=True, db_comment='Specifies the allocated storage size in gibibytes (GiB).', null=True)),
                ('availability_zone', models.TextField(blank=True, db_comment='The Availability Zone that the automated backup was created in.', null=True)),
                ('backup_retention_period', models.BigIntegerField(blank=True, db_comment='The retention period for the automated backups.', null=True)),
                ('backup_target', models.TextField(blank=True, db_comment='Specifies where automated backups are stored: Amazon Web Services Outposts or the Amazon Web Services Region.', null=True)),
                ('dbi_resource_id', models.TextField(blank=True, db_comment="The identifier for the source DB instance, which can't be changed and which is unique to an Amazon Web Services Region.", null=True)),
                ('encrypted', models.BooleanField(blank=True, db_comment='Specifies whether the automated backup is encrypted.', null=True)),
                ('engine', models.TextField(blank=True, db_comment='The name of the database engine for this automated backup.', null=True)),
                ('engine_version', models.TextField(blank=True, db_comment='The version of the database engine for the automated backup.', null=True)),
                ('iam_database_authentication_enabled', models.BooleanField(blank=True, db_comment='True if mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled, and otherwise false.', null=True)),
                ('instance_create_time', models.DateTimeField(blank=True, db_comment='True if mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled, and otherwise false.', null=True)),
                ('iops', models.BigIntegerField(blank=True, db_comment='True if mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled, and otherwise false.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The Amazon Web Services KMS key ID for an automated backup. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.', null=True)),
                ('license_model', models.TextField(blank=True, db_comment='The Amazon Web Services KMS key ID for an automated backup. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.', null=True)),
                ('master_username', models.TextField(blank=True, db_comment='The license model of an automated backup.', null=True)),
                ('option_group_name', models.TextField(blank=True, db_comment='The option group the automated backup is associated with. If omitted, the default option group for the engine specified is used.', null=True)),
                ('port', models.BigIntegerField(blank=True, db_comment='The port number that the automated backup used for connections. Default: Inherits from the source DB instance Valid Values: 1150-65535.', null=True)),
                ('storage_throughput', models.BigIntegerField(blank=True, db_comment='Specifies the storage throughput for the automated backup.', null=True)),
                ('storage_type', models.TextField(blank=True, db_comment='Specifies the storage type associated with the automated backup.', null=True)),
                ('tde_credential_arn', models.TextField(blank=True, db_comment='The ARN from the key store with which the automated backup is associated for TDE encryption.', null=True)),
                ('timezone', models.TextField(blank=True, db_comment='The time zone of the automated backup.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='Provides the VPC ID associated with the DB instance.', null=True)),
                ('db_instance_automated_backups_replications', models.JSONField(blank=True, db_comment='The list of replications to different Amazon Web Services Regions associated with the automated backup.', null=True)),
                ('restore_window', models.JSONField(blank=True, db_comment='Earliest and latest time an instance can be restored to.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_instance_automated_backup',
                'db_table_comment': 'AWS RDS DB Instance Automated Backup',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbInstanceMetricConnections',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_instance_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Instance.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_instance_metric_connections',
                'db_table_comment': 'AWS RDS DB Instance Cloudwatch Metrics - DB Connections',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbInstanceMetricConnectionsDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_instance_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Instance.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_instance_metric_connections_daily',
                'db_table_comment': 'AWS RDS DB Instance Cloudwatch Metrics - DB Connections (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbInstanceMetricConnectionsHourly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_instance_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Instance.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_instance_metric_connections_hourly',
                'db_table_comment': 'AWS RDS DB Instance Cloudwatch Metrics - DB Connections (Hourly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbInstanceMetricCpuUtilization',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_instance_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Instance.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_instance_metric_cpu_utilization',
                'db_table_comment': 'AWS RDS DB Instance Cloudwatch Metrics - CPU Utilization',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbInstanceMetricCpuUtilizationDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_instance_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Instance.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_instance_metric_cpu_utilization_daily',
                'db_table_comment': 'AWS RDS DB Instance Cloudwatch Metrics - CPU Utilization (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbInstanceMetricCpuUtilizationHourly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_instance_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Instance.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_instance_metric_cpu_utilization_hourly',
                'db_table_comment': 'AWS RDS DB Instance Cloudwatch Metrics - CPU Utilization (Hourly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbInstanceMetricReadIops',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_instance_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Instance.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_instance_metric_read_iops',
                'db_table_comment': 'AWS RDS DB Instance Cloudwatch Metrics - Read IOPS',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbInstanceMetricReadIopsDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_instance_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Instance.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_instance_metric_read_iops_daily',
                'db_table_comment': 'AWS RDS DB Instance Cloudwatch Metrics - Read IOPS (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbInstanceMetricReadIopsHourly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_instance_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Instance.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_instance_metric_read_iops_hourly',
                'db_table_comment': 'AWS RDS DB Instance Cloudwatch Metrics - Read IOPS (Hourly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbInstanceMetricWriteIops',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_instance_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Instance.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_instance_metric_write_iops',
                'db_table_comment': 'AWS RDS DB Instance Cloudwatch Metrics - Write IOPS',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbInstanceMetricWriteIopsDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_instance_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Instance.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_instance_metric_write_iops_daily',
                'db_table_comment': 'AWS RDS DB Instance Cloudwatch Metrics - Write IOPS (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbInstanceMetricWriteIopsHourly',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_instance_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Instance.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_instance_metric_write_iops_hourly',
                'db_table_comment': 'AWS RDS DB Instance Cloudwatch Metrics - Write IOPS (Hourly)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbOptionGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The friendly name to identify the option group.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the option group.', null=True)),
                ('description', models.TextField(blank=True, db_comment='Provides a description of the option group.', null=True)),
                ('allows_vpc_and_non_vpc_instance_memberships', models.BooleanField(blank=True, db_comment='Specifies whether this option group can be applied to both VPC and non-VPC instances.', null=True)),
                ('engine_name', models.TextField(blank=True, db_comment='Indicates the name of the engine that this option group can be applied to.', null=True)),
                ('major_engine_version', models.TextField(blank=True, db_comment='Indicates the major engine version associated with this option group.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='Indicates the ID of the VPC, option group can be applied.', null=True)),
                ('options', models.JSONField(blank=True, db_comment='Indicates what options are available in the option group.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the option group.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_option_group',
                'db_table_comment': 'AWS RDS DB Option Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbParameterGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The friendly name to identify the DB parameter group.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the DB parameter group.', null=True)),
                ('description', models.TextField(blank=True, db_comment='Provides the customer-specified description for this DB parameter group.', null=True)),
                ('db_parameter_group_family', models.TextField(blank=True, db_comment='The name of the DB parameter group family that this DB parameter group is compatible with.', null=True)),
                ('parameters', models.JSONField(blank=True, db_comment='A list of detailed parameter for a particular DB parameter group.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the DB parameter group.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_parameter_group',
                'db_table_comment': 'AWS RDS DB Parameter Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbProxy',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_proxy_name', models.TextField(blank=True, db_comment='The identifier for the proxy.', null=True)),
                ('db_proxy_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the proxy', null=True)),
                ('created_date', models.DateTimeField(blank=True, db_comment='The date and time when the proxy was first created.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current status of this proxy.', null=True)),
                ('debug_logging', models.BooleanField(blank=True, db_comment='Whether the proxy includes detailed information about SQL statements in its logs.', null=True)),
                ('endpoint', models.TextField(blank=True, db_comment='The endpoint that you can use to connect to the DB proxy.', null=True)),
                ('engine_family', models.TextField(blank=True, db_comment='The kinds of databases that the proxy can connect to.', null=True)),
                ('idle_client_timeout', models.BigIntegerField(blank=True, db_comment='The number of seconds a connection to the proxy can have no activity before the proxy drops the client connection.', null=True)),
                ('require_tls', models.BooleanField(blank=True, db_comment='Indicates whether Transport Layer Security (TLS) encryption is required for connections to the proxy.', null=True)),
                ('role_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the IAM role that the proxy uses to access Amazon Secrets Manager.', null=True)),
                ('updated_date', models.DateTimeField(blank=True, db_comment='The date and time when the proxy was last updated.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='Provides the VPC ID of the DB proxy.', null=True)),
                ('auth', models.JSONField(blank=True, db_comment='One or more data structures specifying the authorization mechanism to connect to the associated RDS DB instance or Aurora DB cluster.', null=True)),
                ('vpc_security_group_ids', models.JSONField(blank=True, db_comment='Provides a list of VPC security groups that the proxy belongs to.', null=True)),
                ('vpc_subnet_ids', models.JSONField(blank=True, db_comment='The EC2 subnet IDs for the proxy.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_proxy',
                'db_table_comment': 'AWS RDS DB Proxy',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbSnapshot',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('db_snapshot_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB snapshot.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the DB snapshot.', null=True)),
                ('type', models.TextField(blank=True, db_comment='Provides the type of the DB snapshot.', null=True)),
                ('status', models.TextField(blank=True, db_comment='Specifies the status of this DB snapshot.', null=True)),
                ('create_time', models.DateTimeField(blank=True, db_comment='Specifies when the snapshot was taken.', null=True)),
                ('allocated_storage', models.BigIntegerField(blank=True, db_comment='Specifies the allocated storage size in gibibytes(GiB).', null=True)),
                ('availability_zone', models.TextField(blank=True, db_comment='Specifies the name of the Availability Zone the DB instance was located in, at the time of the DB snapshot.', null=True)),
                ('db_instance_identifier', models.TextField(blank=True, db_comment='Specifies the DB instance identifier of the DB instance this DB snapshot was created from.', null=True)),
                ('dbi_resource_id', models.TextField(blank=True, db_comment="The identifier for the source DB instance, which can't be changed and which is unique to an AWS Region.", null=True)),
                ('encrypted', models.BooleanField(blank=True, db_comment='Specifies whether the DB snapshot is encrypted, or not.', null=True)),
                ('engine', models.TextField(blank=True, db_comment='Specifies the name of the database engine.', null=True)),
                ('engine_version', models.TextField(blank=True, db_comment='Specifies the version of the database engine.', null=True)),
                ('iam_database_authentication_enabled', models.BooleanField(blank=True, db_comment='Specifies whether the mapping of AWS IAM accounts to database accounts is enabled, or not.', null=True)),
                ('instance_create_time', models.DateTimeField(blank=True, db_comment='Specifies the time when the DB instance, from which the snapshot was taken, was created.', null=True)),
                ('iops', models.BigIntegerField(blank=True, db_comment='Specifies the Provisioned IOPS (I/O operations per second) value of the DB instance at the time of the snapshot.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='Specifies the AWS KMS key identifier for the encrypted DB snapshot.', null=True)),
                ('license_model', models.TextField(blank=True, db_comment='Specifies the License model information for the restored DB instance.', null=True)),
                ('master_user_name', models.TextField(blank=True, db_comment='Provides the master username for the DB snapshot.', null=True)),
                ('option_group_name', models.TextField(blank=True, db_comment='Provides the option group name for the DB snapshot.', null=True)),
                ('percent_progress', models.BigIntegerField(blank=True, db_comment='The percentage of the estimated data that has been transferred.', null=True)),
                ('port', models.BigIntegerField(blank=True, db_comment='Specifies the port that the database engine was listening on at the time of the snapshot.', null=True)),
                ('source_db_snapshot_identifier', models.TextField(blank=True, db_comment='The DB snapshot ARN that the DB snapshot was copied from.', null=True)),
                ('source_region', models.TextField(blank=True, db_comment='The AWS Region that the DB snapshot was created in or copied from.', null=True)),
                ('storage_type', models.TextField(blank=True, db_comment='Specifies the storage type associated with DB snapshot.', null=True)),
                ('tde_credential_arn', models.TextField(blank=True, db_comment='The ARN from the key store with which to associate the instance for TDE encryption.', null=True)),
                ('timezone', models.TextField(blank=True, db_comment='The time zone of the DB snapshot.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='Provides the VPC ID associated with the DB snapshot.', null=True)),
                ('db_snapshot_attributes', models.JSONField(blank=True, db_comment='A list of DB snapshot attribute names and values for a manual DB snapshot.', null=True)),
                ('processor_features', models.JSONField(blank=True, db_comment='The number of CPU cores and the number of threads per core for the DB instance class of the DB instance when the DB snapshot was created.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the DB snapshot.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_snapshot',
                'db_table_comment': 'AWS RDS DB Snapshot',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsDbSubnetGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The friendly name to identify the DB subnet group.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the DB subnet group.', null=True)),
                ('description', models.TextField(blank=True, db_comment='Provides the description of the DB subnet group.', null=True)),
                ('status', models.TextField(blank=True, db_comment='Provides the status of the DB subnet group.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='Provides the VpcId of the DB subnet group.', null=True)),
                ('subnets', models.JSONField(blank=True, db_comment='A list of Subnet elements.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the DB subnet group.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_db_subnet_group',
                'db_table_comment': 'AWS RDS DB Subnet Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRdsReservedDbInstance',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('reserved_db_instance_id', models.TextField(blank=True, db_comment='The unique identifier for the reservation.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the reserved DB Instance.', null=True)),
                ('reserved_db_instances_offering_id', models.TextField(blank=True, db_comment='The offering identifier.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The state of the reserved DB instance.', null=True)),
                ('class_field', models.TextField(blank=True, db_column='class', db_comment='The DB instance class for the reserved DB instance.', null=True)),
                ('currency_code', models.TextField(blank=True, db_comment='The currency code for the reserved DB instance.', null=True)),
                ('db_instance_count', models.BigIntegerField(blank=True, db_comment='The number of reserved DB instances.', null=True)),
                ('duration', models.BigIntegerField(blank=True, db_comment='The duration of the reservation in seconds.', null=True)),
                ('fixed_price', models.FloatField(blank=True, db_comment='The fixed price charged for this reserved DB instance.', null=True)),
                ('lease_id', models.TextField(blank=True, db_comment='The unique identifier for the lease associated with the reserved DB instance.', null=True)),
                ('multi_az', models.BooleanField(blank=True, db_comment='Indicates if the reservation applies to Multi-AZ deployments.', null=True)),
                ('offering_type', models.TextField(blank=True, db_comment='The offering type of this reserved DB instance.', null=True)),
                ('product_description', models.TextField(blank=True, db_comment='The description of the reserved DB instance.', null=True)),
                ('start_time', models.DateTimeField(blank=True, db_comment='The time the reservation started.', null=True)),
                ('usage_price', models.FloatField(blank=True, db_comment='The hourly price charged for this reserved DB instance.', null=True)),
                ('recurring_charges', models.JSONField(blank=True, db_comment='The recurring price charged to run this reserved DB instance.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_rds_reserved_db_instance',
                'db_table_comment': 'AWS RDS Reserved DB Instance',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRedshiftCluster',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cluster_identifier', models.TextField(blank=True, db_comment='The unique identifier of the cluster.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the cluster.', null=True)),
                ('cluster_namespace_arn', models.TextField(blank=True, db_comment='The namespace Amazon Resource Name (ARN) of the cluster.', null=True)),
                ('allow_version_upgrade', models.BooleanField(blank=True, db_comment='A boolean value that, if true, indicates that major version upgrades will be applied automatically to the cluster during the maintenance window.', null=True)),
                ('automated_snapshot_retention_period', models.BigIntegerField(blank=True, db_comment='The number of days that automatic cluster snapshots are retained.', null=True)),
                ('availability_zone', models.TextField(blank=True, db_comment='The name of the Availability Zone in which the cluster is located.', null=True)),
                ('availability_zone_relocation_status', models.TextField(blank=True, db_comment='Describes the status of the Availability Zone relocation operation.', null=True)),
                ('cluster_availability_status', models.TextField(blank=True, db_comment='The availability status of the cluster for queries.', null=True)),
                ('cluster_create_time', models.DateTimeField(blank=True, db_comment='The date and time that the cluster was created.', null=True)),
                ('cluster_nodes', models.JSONField(blank=True, db_comment='The nodes in the cluster.', null=True)),
                ('cluster_parameter_groups', models.JSONField(blank=True, db_comment='The list of cluster parameter groups that are associated with this cluster. Each parameter group in the list is returned with its status.', null=True)),
                ('cluster_public_key', models.TextField(blank=True, db_comment='The public key for the cluster.', null=True)),
                ('cluster_revision_number', models.TextField(blank=True, db_comment='The specific revision number of the database in the cluster.', null=True)),
                ('cluster_security_groups', models.JSONField(blank=True, db_comment='A list of cluster security group that are associated with the cluster. Each security group is represented by an element that contains ClusterSecurityGroup.Name and ClusterSecurityGroup.Status subelements. Cluster security groups are used when the cluster is not created in an Amazon Virtual Private Cloud (VPC). Clusters that are created in a VPC use VPC security groups, which are listed by the VpcSecurityGroups parameter.', null=True)),
                ('cluster_snapshot_copy_status', models.JSONField(blank=True, db_comment='A value that returns the destination region and retention period that are configured for cross-region snapshot copy.', null=True)),
                ('cluster_status', models.TextField(blank=True, db_comment='The current state of the cluster.', null=True)),
                ('cluster_subnet_group_name', models.TextField(blank=True, db_comment='The name of the subnet group that is associated with the cluster. This parameter is valid only when the cluster is in a VPC.', null=True)),
                ('cluster_version', models.TextField(blank=True, db_comment='The version ID of the Amazon Redshift engine that is running on the cluster.', null=True)),
                ('data_transfer_progress', models.JSONField(blank=True, db_comment='Describes the status of a cluster while it is in the process of resizing with an incremental resize.', null=True)),
                ('db_name', models.TextField(blank=True, db_comment='The name of the initial database that was created when the cluster was created. This same name is returned for the life of the cluster. If an initial database was not specified, a database named devdev was created by default.', null=True)),
                ('deferred_maintenance_windows', models.JSONField(blank=True, db_comment='Describes a group of DeferredMaintenanceWindow objects.', null=True)),
                ('elastic_ip_status', models.JSONField(blank=True, db_comment='The status of the elastic IP (EIP) address.', null=True)),
                ('elastic_resize_number_of_node_options', models.TextField(blank=True, db_comment='The number of nodes that you can resize the cluster to with the elastic resize method.', null=True)),
                ('encrypted', models.BooleanField(blank=True, db_comment='A boolean value that, if true, indicates that data in the cluster is encrypted at rest.', null=True)),
                ('endpoint', models.JSONField(blank=True, db_comment='The connection endpoint.', null=True)),
                ('enhanced_vpc_routing', models.BooleanField(blank=True, db_comment='An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. If this option is true, enhanced VPC routing is enabled.', null=True)),
                ('expected_next_snapshot_schedule_time', models.DateTimeField(blank=True, db_comment='The date and time when the next snapshot is expected to be taken for clusters with a valid snapshot schedule and backups enabled.', null=True)),
                ('expected_next_snapshot_schedule_time_status', models.TextField(blank=True, db_comment='The status of next expected snapshot for clusters having a valid snapshot schedule and backups enabled.', null=True)),
                ('hsm_status', models.JSONField(blank=True, db_comment='A value that reports whether the Amazon Redshift cluster has finished applying any hardware security module (HSM) settings changes specified in a modify cluster command.', null=True)),
                ('iam_roles', models.JSONField(blank=True, db_comment='A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The AWS Key Management Service (AWS KMS) key ID of the encryption key used to encrypt data in the cluster.', null=True)),
                ('maintenance_track_name', models.TextField(blank=True, db_comment='The name of the maintenance track for the cluster.', null=True)),
                ('manual_snapshot_retention_period', models.BigIntegerField(blank=True, db_comment="The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots. The value must be either -1 or an integer between 1 and 3,653.", null=True)),
                ('master_username', models.TextField(blank=True, db_comment='The master user name for the cluster. This name is used to connect to the database that is specified in the DBName parameter.', null=True)),
                ('modify_status', models.TextField(blank=True, db_comment='The status of a modify operation, if any, initiated for the cluster.', null=True)),
                ('next_maintenance_window_start_time', models.DateTimeField(blank=True, db_comment='The date and time in UTC when system maintenance can begin.', null=True)),
                ('node_type', models.TextField(blank=True, db_comment='The node type for the nodes in the cluster.', null=True)),
                ('number_of_nodes', models.BigIntegerField(blank=True, db_comment='The number of compute nodes in the cluster.', null=True)),
                ('pending_actions', models.JSONField(blank=True, db_comment='Cluster operations that are waiting to be started.', null=True)),
                ('pending_modified_values', models.JSONField(blank=True, db_comment='A value that, if present, indicates that changes to the cluster are pending. Specific pending changes are identified by subelements.', null=True)),
                ('preferred_maintenance_window', models.TextField(blank=True, db_comment='The weekly time range, in Universal Coordinated Time (UTC), during which system maintenance can occur.', null=True)),
                ('publicly_accessible', models.BooleanField(blank=True, db_comment='A boolean value that, if true, indicates that the cluster can be accessed from a public network.', null=True)),
                ('resize_info', models.JSONField(blank=True, db_comment='Describes a resize operation.', null=True)),
                ('restore_status', models.JSONField(blank=True, db_comment='A value that describes the status of a cluster restore action. This parameter returns null if the cluster was not created by restoring a snapshot.', null=True)),
                ('snapshot_schedule_identifier', models.TextField(blank=True, db_comment='A unique identifier for the cluster snapshot schedule.', null=True)),
                ('snapshot_schedule_state', models.TextField(blank=True, db_comment='The current state of the cluster snapshot schedule.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The identifier of the VPC the cluster is in, if the cluster is in a VPC.', null=True)),
                ('vpc_security_groups', models.JSONField(blank=True, db_comment='A list of Amazon Virtual Private Cloud (Amazon VPC) security groups that are associated with the cluster. This parameter is returned only if the cluster is in a VPC.', null=True)),
                ('logging_status', models.JSONField(blank=True, db_comment='Describes the status of logging for a cluster.', null=True)),
                ('scheduled_actions', models.JSONField(blank=True, db_comment='A list of scheduled actions for specified cluster.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The list of tags for the cluster.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_redshift_cluster',
                'db_table_comment': 'AWS Redshift Cluster',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRedshiftClusterMetricCpuUtilizationDaily',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cluster_identifier', models.TextField(blank=True, db_comment='The friendly name to identify the DB Instance.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_redshift_cluster_metric_cpu_utilization_daily',
                'db_table_comment': 'AWS Redshift Cluster Cloudwatch Metrics - CPU Utilization (Daily)',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRedshiftEventSubscription',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cust_subscription_id', models.TextField(blank=True, db_comment='The name of the Amazon Redshift event notification subscription.', null=True)),
                ('customer_aws_id', models.TextField(blank=True, db_comment='The AWS customer account associated with the Amazon Redshift event notification subscription.', null=True)),
                ('enabled', models.BooleanField(blank=True, db_comment='A boolean value indicating whether the subscription is enabled or disabled', null=True)),
                ('severity', models.TextField(blank=True, db_comment='The event severity specified in the Amazon Redshift event notification subscription.', null=True)),
                ('sns_topic_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the Amazon SNS topic used by the event notification subscription.', null=True)),
                ('source_type', models.TextField(blank=True, db_comment='The source type of the events returned by the Amazon Redshift event notification.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the Amazon Redshift event notification subscription.', null=True)),
                ('subscription_creation_time', models.DateTimeField(blank=True, db_comment='The date and time the Amazon Redshift event notification subscription was created.', null=True)),
                ('event_categories_list', models.JSONField(blank=True, db_comment='The list of Amazon Redshift event categories specified in the event notification subscription.', null=True)),
                ('source_ids_list', models.JSONField(blank=True, db_comment='A list of the sources that publish events to the Amazon Redshift event notification subscription.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The list of tags for the event subscription.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_redshift_event_subscription',
                'db_table_comment': 'AWS Redshift Event Subscription',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRedshiftParameterGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the cluster parameter group.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the parameter group.', null=True)),
                ('family', models.TextField(blank=True, db_comment='The name of the cluster parameter group family that this cluster parameter group is compatible with.', null=True)),
                ('parameters', models.JSONField(blank=True, db_comment='A list of Parameter instances. Each instance lists the parameters of one cluster parameter group.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the parameter group.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_redshift_parameter_group',
                'db_table_comment': 'AWS Redshift Parameter Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRedshiftserverlessNamespace',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('namespace_name', models.TextField(blank=True, db_comment='The name of the namespace.', null=True)),
                ('namespace_id', models.TextField(blank=True, db_comment='The unique identifier of the namespace.', null=True)),
                ('namespace_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that links to the namespace.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the namespace.', null=True)),
                ('admin_username', models.TextField(blank=True, db_comment='The username of the administrator for the first database created in the namespace.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The creation date of the namespace.', null=True)),
                ('db_name', models.TextField(blank=True, db_comment='The name of the first database created in the namespace.', null=True)),
                ('default_iam_role_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The ID of the Amazon Web Services Key Management Service key used to encrypt your data.', null=True)),
                ('iam_roles', models.JSONField(blank=True, db_comment='A list of IAM roles to associate with the namespace.', null=True)),
                ('log_exports', models.JSONField(blank=True, db_comment='The types of logs the namespace can export. Available export types are User log, Connection log, and User activity log.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The list of tags for the namespace.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_redshiftserverless_namespace',
                'db_table_comment': 'AWS Redshift Serverless Namespace',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRedshiftserverlessWorkgroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('workgroup_name', models.TextField(blank=True, db_comment='The name of the workgroup.', null=True)),
                ('workgroup_id', models.TextField(blank=True, db_comment='The unique identifier of the workgroup.', null=True)),
                ('workgroup_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that links to the workgroup.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the workgroup.', null=True)),
                ('base_capacity', models.BigIntegerField(blank=True, db_comment='The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The creation date of the workgroup.', null=True)),
                ('enhanced_vpc_routing', models.BooleanField(blank=True, db_comment='The value that specifies whether to enable enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.', null=True)),
                ('namespace_name', models.TextField(blank=True, db_comment='The namespace the workgroup is associated with.', null=True)),
                ('publicly_accessible', models.BooleanField(blank=True, db_comment='A value that specifies whether the workgroup can be accessible from a public network.', null=True)),
                ('config_parameters', models.JSONField(blank=True, db_comment='An array of parameters to set for finer control over a database.', null=True)),
                ('endpoint', models.JSONField(blank=True, db_comment='The endpoint that is created from the workgroup.', null=True)),
                ('security_group_ids', models.JSONField(blank=True, db_comment='An array of security group IDs to associate with the workgroup.', null=True)),
                ('subnet_ids', models.JSONField(blank=True, db_comment='An array of subnet IDs the workgroup is associated with.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The list of tags for the workgroup.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_redshiftserverless_workgroup',
                'db_table_comment': 'AWS Redshift Serverless Workgroup',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRedshiftSnapshot',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('snapshot_identifier', models.TextField(blank=True, db_comment='The unique identifier of the cluster.', null=True)),
                ('cluster_identifier', models.TextField(blank=True, db_comment='The identifier of the cluster for which the snapshot was taken.', null=True)),
                ('snapshot_type', models.TextField(blank=True, db_comment='The snapshot type.', null=True)),
                ('actual_incremental_backup_size_in_mega_bytes', models.FloatField(blank=True, db_comment='The size of the incremental backup.', null=True)),
                ('availability_zone', models.TextField(blank=True, db_comment='The Availability Zone in which the cluster was created.', null=True)),
                ('backup_progress_in_mega_bytes', models.FloatField(blank=True, db_column='backup_progress_in_mega-bytes', db_comment='The number of megabytes that have been transferred to the snapshot backup.', null=True)),
                ('cluster_create_time', models.DateTimeField(blank=True, db_comment='The time (UTC) when the cluster was originally created.', null=True)),
                ('cluster_version', models.TextField(blank=True, db_comment='The version ID of the Amazon Redshift engine that is running on the cluster.', null=True)),
                ('current_backup_rate_in_mega_bytes_per_second', models.FloatField(blank=True, db_comment='The number of megabytes per second being transferred to the snapshot backup.', null=True)),
                ('db_name', models.TextField(blank=True, db_comment='The name of the database that was created when the cluster was created.', null=True)),
                ('elapsed_time_in_seconds', models.TextField(blank=True, db_comment='The amount of time an in-progress snapshot backup has been running, or the amount of time it took a completed backup to finish.', null=True)),
                ('encrypted', models.BooleanField(blank=True, db_comment='If true, the data in the snapshot is encrypted at rest.', null=True)),
                ('encrypted_with_hsm', models.BooleanField(blank=True, db_comment='A boolean that indicates whether the snapshot data is encrypted using the HSM keys of the source cluster.', null=True)),
                ('engine_full_version', models.TextField(blank=True, db_comment='The cluster version of the cluster used to create the snapshot.', null=True)),
                ('enhanced_vpc_routing', models.BooleanField(blank=True, db_comment='An option that specifies whether to create the cluster with enhanced VPC routing enabled.', null=True)),
                ('estimated_seconds_to_completion', models.TextField(blank=True, db_comment='The estimate of the time remaining before the snapshot backup will complete.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The AWS KMS key ID of the encryption key that was used to encrypt data in the cluster from which the snapshot was taken.', null=True)),
                ('maintenance_track_name', models.TextField(blank=True, db_comment='The name of the maintenance track for the snapshot.', null=True)),
                ('manual_snapshot_remaining_days', models.BigIntegerField(blank=True, db_comment='The number of days until a manual snapshot will pass its retention period.', null=True)),
                ('manual_snapshot_retention_period', models.BigIntegerField(blank=True, db_comment='The number of days that a manual snapshot is retained.', null=True)),
                ('master_username', models.TextField(blank=True, db_comment='The master user name for the cluster.', null=True)),
                ('node_type', models.TextField(blank=True, db_comment='The node type of the nodes in the cluster.', null=True)),
                ('number_of_nodes', models.BigIntegerField(blank=True, db_comment='The number of nodes in the cluster.', null=True)),
                ('owner_account', models.TextField(blank=True, db_comment='The AWS customer account used to create or copy the snapshot.', null=True)),
                ('port', models.BigIntegerField(blank=True, db_comment='The port that the cluster is listening on.', null=True)),
                ('snapshot_create_time', models.DateTimeField(blank=True, db_comment='The time (in UTC format) when Amazon Redshift began the snapshot.', null=True)),
                ('snapshot_retention_start_time', models.DateTimeField(blank=True, db_comment='A timestamp representing the start of the retention period for the snapshot.', null=True)),
                ('source_region', models.TextField(blank=True, db_comment='The source region from which the snapshot was copied.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The snapshot status.', null=True)),
                ('total_backup_size_in_mega_bytes', models.FloatField(blank=True, db_comment='The size of the complete set of backup data that would be used to restore the cluster.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The VPC identifier of the cluster if the snapshot is from a cluster in a VPC.', null=True)),
                ('accounts_with_restore_access', models.JSONField(blank=True, db_comment='A list of the AWS customer accounts authorized to restore the snapshot.', null=True)),
                ('restorable_node_types', models.JSONField(blank=True, db_comment='The list of node types that this cluster snapshot is able to restore into.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The list of tags for the cluster.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_redshift_snapshot',
                'db_table_comment': 'AWS Redshift Snapshot',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRedshiftSubnetGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cluster_subnet_group_name', models.TextField(blank=True, db_comment='The name of the cluster subnet group.', null=True)),
                ('subnet_group_status', models.TextField(blank=True, db_comment='The status of the cluster subnet group.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the cluster subnet group.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The VPC ID of the cluster subnet group.', null=True)),
                ('subnets', models.JSONField(blank=True, db_comment='A list of the VPC Subnet elements.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags attached to the subnet group.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_redshift_subnet_group',
                'db_table_comment': 'AWS Redshift Subnet Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRegion',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the region', null=True)),
                ('opt_in_status', models.TextField(blank=True, db_comment='The Region opt-in status. The possible values are opt-in-not-required, opted-in, and not-opted-in', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_region',
                'db_table_comment': 'AWS Region',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsResourceExplorerIndex',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon resource name (ARN) of the index.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of index. It can be one of the following values: LOCAL, AGGREGATOR.', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the index exists.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_resource_explorer_index',
                'db_table_comment': 'AWS Resource Explorer Index',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsResourceExplorerSupportedResourceType',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('resource_type', models.TextField(blank=True, db_comment='The unique identifier of the resource type.', null=True)),
                ('service', models.TextField(blank=True, db_comment='The Amazon Web Service that is associated with the resource type. This is the primary service that lets you create and interact with resources of this type.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_resource_explorer_supported_resource_type',
                'db_table_comment': 'AWS Resource Explorer Supported Resource Type',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRoute53Domain',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('domain_name', models.TextField(blank=True, db_comment='The name of the domain.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the domain.', null=True)),
                ('abuse_contact_email', models.TextField(blank=True, db_comment='Email address to contact to report incorrect contact information for a domain,to report that the domain is being used to send spam, to report that someone is cyber squatting on a domain name, or report some other type of abuse.', null=True)),
                ('abuse_contact_phone', models.TextField(blank=True, db_comment='Phone number for reporting abuse.', null=True)),
                ('admin_privacy', models.BooleanField(blank=True, db_comment='Specifies whether contact information is concealed from WHOIS queries.', null=True)),
                ('auto_renew', models.BooleanField(blank=True, db_comment='Indicates whether the domain is automatically renewed upon expiration.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The date when the domain was created as found in the response to a WHOIS query.', null=True)),
                ('expiration_date', models.DateTimeField(blank=True, db_comment='The date when the registration for the domain is set to expire. The date and time is in Unix time format and Coordinated Universal time (UTC).', null=True)),
                ('registrant_privacy', models.BooleanField(blank=True, db_comment='Specifies whether contact information is concealed from WHOIS queries.', null=True)),
                ('registrar_name', models.TextField(blank=True, db_comment='Name of the registrar of the domain as identified in the registry. Domains with a .com, .net, or .org TLD are registered by Amazon Registrar.', null=True)),
                ('registrar_url', models.TextField(blank=True, db_comment='Web address of the registrar.', null=True)),
                ('registry_domain_id', models.TextField(blank=True, db_comment='Reserved for future use.', null=True)),
                ('reseller', models.TextField(blank=True, db_comment='Reseller of the domain. Domains registered or transferred using Route 53 domains will have Amazon as the reseller.', null=True)),
                ('tech_privacy', models.BooleanField(blank=True, db_comment='Specifies whether contact information is concealed from WHOIS queries.', null=True)),
                ('transfer_lock', models.BooleanField(blank=True, db_comment='Indicates whether a domain is locked from unauthorized transfer to another party.', null=True)),
                ('updated_date', models.DateTimeField(blank=True, db_comment='The last updated date of the domain as found in the response to a WHOIS query.The date and time is in Unix time format and Coordinated Universal time (UTC).', null=True)),
                ('who_is_server', models.TextField(blank=True, db_comment='The fully qualified name of the WHOIS server that can answer the WHOIS query for the domain.', null=True)),
                ('nameservers', models.JSONField(blank=True, db_comment='The name of the domain.', null=True)),
                ('registrant_contact', models.JSONField(blank=True, db_comment='Provides details about the domain registrant.', null=True)),
                ('status_list', models.JSONField(blank=True, db_comment='An array of domain name status codes, also known as Extensible Provisioning Protocol (EPP) status codes.', null=True)),
                ('tech_contact', models.JSONField(blank=True, db_comment='Provides details about the domain technical contact.', null=True)),
                ('admin_contact', models.JSONField(blank=True, db_comment='Provides details about the domain administrative contact.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_route53_domain',
                'db_table_comment': 'AWS Route53 Domain',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRoute53HealthCheck',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The identifier that Amazon Route 53 assigned to the health check.', primary_key=True, serialize=False)),
                ('caller_reference', models.TextField(blank=True, db_comment='A unique string that you specified when you created the health check.', null=True)),
                ('health_check_version', models.BigIntegerField(blank=True, db_comment='The version of the health check.', null=True)),
                ('linked_service_principal', models.TextField(blank=True, db_comment='If the health check was created by another service, the service that created the resource.', null=True)),
                ('linked_service_description', models.TextField(blank=True, db_comment='If the health check was created by another service, an configurationtional description that can be provided by the other service.', null=True)),
                ('cloud_watch_alarm_configuration', models.JSONField(blank=True, db_comment='A complex type that contains information about the CloudWatch alarm that Amazon Route 53 is monitoring for this health check.', null=True)),
                ('health_check_config', models.JSONField(blank=True, db_comment='A complex type that contains detailed information about one health check.', null=True)),
                ('health_check_status', models.JSONField(blank=True, db_comment='A list that contains one HealthCheckObservation element for each Amazon Route 53 health checker that is reporting a status about the health check endpoint.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_route53_health_check',
                'db_table_comment': 'AWS Route53 Health Check',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRoute53QueryLog',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The ID for a configuration for DNS query logging.', primary_key=True, serialize=False)),
                ('hosted_zone_id', models.TextField(blank=True, db_comment='The ID of the hosted zone that CloudWatch Logs is logging queries for.', null=True)),
                ('cloud_watch_logs_log_group_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the CloudWatch Logs log group that Amazon Route 53 is publishing logs to.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_route53_query_log',
                'db_table_comment': 'AWS Route53 Query Logging Configuration',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRoute53Record',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the record.', null=True)),
                ('zone_id', models.TextField(blank=True, db_comment='The ID of the hosted zone to contain this record.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The record type. Valid values are A, AAAA, CAA, CNAME, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.', null=True)),
                ('alias_target', models.JSONField(blank=True, db_comment='Alias resource record sets only: Information about the AWS resource, such as a CloudFront distribution or an Amazon S3 bucket, that you want to route traffic to.', null=True)),
                ('failover', models.TextField(blank=True, db_comment='Failover resource record sets only: To configure failover, you add the Failover element to two resource record sets. For one resource record set, you specify PRIMARY as the value for Failover; for the other resource record set, you specify SECONDARY. In addition, you include the HealthCheckId element and specify the health check that you want Amazon Route 53 to perform for each resource record set.', null=True)),
                ('geo_location', models.JSONField(blank=True, db_comment='Geolocation resource record sets only: A complex type that lets you control how Amazon Route 53 responds to DNS queries based on the geographic origin of the query. For example, if you want all queries from Africa to be routed to a web server with an IP address of 192.0.2.111, create a resource record set with a Type of A and a ContinentCode of AF.', null=True)),
                ('health_check_id', models.TextField(blank=True, db_comment='The health check the record should be associated with.', null=True)),
                ('multi_value_answer', models.BooleanField(blank=True, db_comment='Multivalue answer resource record sets only: To route traffic approximately randomly to multiple resources, such as web servers, create one multivalue answer record for each resource and specify true for MultiValueAnswer.', null=True)),
                ('latency_region', models.TextField(blank=True, db_comment='An AWS region from which to measure latency', null=True)),
                ('records', models.JSONField(blank=True, db_comment='If the health check or hosted zone was created by another service, an optional description that can be provided by the other service.', null=True)),
                ('set_identifier', models.TextField(blank=True, db_comment='Unique identifier to differentiate records with routing policies from one another.', null=True)),
                ('ttl', models.TextField(blank=True, db_comment='The resource record cache time to live (TTL), in seconds.', null=True)),
                ('traffic_policy_instance_id', models.TextField(blank=True, db_comment='The ID of the traffic policy instance that Route 53 created this resource record set for.', null=True)),
                ('weight', models.BigIntegerField(blank=True, db_comment="Weighted resource record sets only: Among resource record sets that have the same combination of DNS name and type, a value that determines the proportion of DNS queries that Amazon Route 53 responds to using the current resource record set. Route 53 calculates the sum of the weights for the resource record sets that have the same combination of DNS name and type. Route 53 then responds to queries based on the ratio of a resource's weight to the total.", null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_route53_record',
                'db_table_comment': 'AWS Route53 Record',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRoute53ResolverEndpoint',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name that you assigned to the Resolver endpoint when you submitted a CreateResolverEndpoint.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The ID of the Resolver endpoint.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The ARN (Amazon Resource Name) for the Resolver endpoint.', null=True)),
                ('creation_time', models.TextField(blank=True, db_comment='The date and time that the endpoint was created, in Unix time format and Coordinated Universal Time (UTC).', null=True)),
                ('creator_request_id', models.TextField(blank=True, db_comment='A unique string that identifies the request that created the Resolver endpoint.The CreatorRequestId allows failed requests to be retried without the risk of executing the operation twice.', null=True)),
                ('direction', models.TextField(blank=True, db_comment='Indicates whether the Resolver endpoint allows inbound or outbound DNS queries.', null=True)),
                ('host_vpc_id', models.TextField(blank=True, db_comment='The ID of the VPC that you want to create the Resolver endpoint in.', null=True)),
                ('ip_address_count', models.BigIntegerField(blank=True, db_comment='The number of IP addresses that the Resolver endpoint can use for DNS queries.', null=True)),
                ('modification_time', models.TextField(blank=True, db_comment='The date and time that the endpoint was last modified, in Unix time format and Coordinated Universal Time (UTC).', null=True)),
                ('status', models.TextField(blank=True, db_comment='A code that specifies the current status of the Resolver endpoint.', null=True)),
                ('status_message', models.TextField(blank=True, db_comment='A detailed description of the status of the Resolver endpoint.', null=True)),
                ('ip_addresses', models.JSONField(blank=True, db_comment='Information about the IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward DNS queries to (for inbound endpoints).', null=True)),
                ('security_group_ids', models.JSONField(blank=True, db_comment='The ID of one or more security groups that control access to this VPC.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the Resolver endpoint.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_route53_resolver_endpoint',
                'db_table_comment': 'AWS Route53 Resolver Endpoint',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRoute53ResolverQueryLogConfig',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The ID for the query logging configuration.', primary_key=True, serialize=False)),
                ('name', models.TextField(blank=True, db_comment='The name of the query logging configuration.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN (Amazon Resource Name) for the query logging configuration.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The date and time that the query logging configuration was created, in Unix time format and Coordinated Universal Time (UTC).', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the specified query logging configuration. Valid values include CREATING|CREATED|DELETING|FAILED.', null=True)),
                ('association_count', models.BigIntegerField(blank=True, db_comment='The number of VPCs that are associated with the query logging configuration.', null=True)),
                ('ip_address_count', models.BigIntegerField(blank=True, db_comment='The number of IP addresses that you have associated with the Resolver endpoint.', null=True)),
                ('creator_request_id', models.TextField(blank=True, db_comment='A unique string that identifies the request that created the query logging configuration.', null=True)),
                ('destination_arn', models.TextField(blank=True, db_comment='The ARN of the resource that you want Resolver to send query logs: an Amazon S3 bucket, a CloudWatch Logs log group, or a Kinesis Data Firehose delivery stream.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='The Amazon Web Services account ID for the account that created the query logging configuration.', null=True)),
                ('share_status', models.TextField(blank=True, db_comment='An indication of whether the query logging configuration is shared with other Amazon Web Services accounts, or was shared with the current account by another Amazon Web Services account. Sharing is configured through Resource Access Manager (RAM).', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_route53_resolver_query_log_config',
                'db_table_comment': 'AWS Route53 Resolver Query Logging Configuration',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRoute53ResolverRule',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name for the Resolver rule, which you specified when you created the Resolver rule.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The ID that Resolver assigned to the Resolver rule when you created it.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The ARN (Amazon Resource Name) for the Resolver rule specified by Id.', null=True)),
                ('status', models.TextField(blank=True, db_comment='A code that specifies the current status of the Resolver rule.', null=True)),
                ('creator_request_id', models.TextField(blank=True, db_comment='A unique string that you specified when you created the Resolver rule. CreatorRequestId identifies the request and allows failed requests to be retried without the risk of executing the operation twice.', null=True)),
                ('domain_name', models.TextField(blank=True, db_comment='DNS queries for this domain name are forwarded to the IP addresses that are specified in TargetIps.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='When a rule is shared with another AWS account, the account ID of the account that the rule is shared with.', null=True)),
                ('resolver_endpoint_id', models.TextField(blank=True, db_comment='The ID of the endpoint that the rule is associated with.', null=True)),
                ('rule_type', models.TextField(blank=True, db_comment='When you want to forward DNS queries for specified domain name to resolvers on your network, specify FORWARD.When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for a subdomain of that domain, specify SYSTEM.', null=True)),
                ('share_status', models.TextField(blank=True, db_comment='Indicates whether the rules is shared and, if so, whether the current account is sharing the rule with another account, or another account is sharing the rule with the current account.', null=True)),
                ('status_message', models.TextField(blank=True, db_comment='A detailed description of the status of a Resolver rule.', null=True)),
                ('creation_time', models.TextField(blank=True, db_comment='The date and time that the Resolver rule was created, in Unix time format and Coordinated Universal Time (UTC).', null=True)),
                ('modification_time', models.TextField(blank=True, db_comment='The date and time that the Resolver rule was last updated, in Unix time format and Coordinated Universal Time (UTC).', null=True)),
                ('resolver_rule_associations', models.JSONField(blank=True, db_comment='The associations that were created between Resolver rules and VPCs using the current AWS account, and that match the specified filters, if any.', null=True)),
                ('target_ips', models.JSONField(blank=True, db_comment='An array that contains the IP addresses and ports that an outbound endpoint forwards DNS queries to. Typically, these are the IP addresses of DNS resolvers on your network. Specify IPv4 addresses. IPv6 is not supported.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the Resolver Rule.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_route53_resolver_rule',
                'db_table_comment': 'AWS Route53 Resolver Rule',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRoute53TrafficPolicy',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name that you specified when traffic policy was created.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The ID that Amazon Route 53 assigned to a traffic policy when it was created.', primary_key=True, serialize=False)),
                ('type', models.TextField(blank=True, db_comment='The DNS type of the resource record sets that Amazon Route 53 creates when you use a traffic policy to create a traffic policy instance.', null=True)),
                ('version', models.BigIntegerField(blank=True, db_comment='The version number that Amazon Route 53 assigns to a traffic policy.', null=True)),
                ('comment', models.TextField(blank=True, db_comment='The comment that you specified when traffic policy was created.', null=True)),
                ('document', models.JSONField(blank=True, db_comment='The definition of a traffic policy in JSON format.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_route53_traffic_policy',
                'db_table_comment': 'AWS Route53 Traffic Policy',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRoute53TrafficPolicyInstance',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The DNS name for which Amazon Route 53 responds to queries.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The id that Amazon Route 53 assigned to the new traffic policy instance.', primary_key=True, serialize=False)),
                ('hosted_zone_id', models.TextField(blank=True, db_comment='The id of the hosted zone that Amazon Route 53 created resource record sets in.', null=True)),
                ('message', models.TextField(blank=True, db_comment='If State is Failed, an explanation of the reason for the failure.', null=True)),
                ('state', models.TextField(blank=True, db_comment='Current state of the instance.', null=True)),
                ('traffic_policy_id', models.TextField(blank=True, db_comment='The ID of the traffic policy that Amazon Route 53 used to create resource record sets in the specified hosted zone.', null=True)),
                ('traffic_policy_type', models.TextField(blank=True, db_comment='The DNS type that Amazon Route 53 assigned to all of the resource record sets that it created for this traffic policy instance.', null=True)),
                ('traffic_policy_version', models.BigIntegerField(blank=True, db_comment='The version of the traffic policy that Amazon Route 53 used to create resource record sets in the specified hosted zone.', null=True)),
                ('ttl', models.BigIntegerField(blank=True, db_comment='The TTL that Amazon Route 53 assigned to all of the resource record sets that it created in the specified hosted zone.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_route53_traffic_policy_instance',
                'db_table_comment': 'AWS Route53 Traffic Policy Instance',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRoute53VpcAssociationAuthorization',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('hosted_zone_id', models.TextField(blank=True, db_comment='The ID of the hosted zone for which you want a list of VPCs that can be associated with the hosted zone.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='(Private hosted zones only) The ID of an Amazon VPC.', null=True)),
                ('vpc_region', models.TextField(blank=True, db_comment='(Private hosted zones only) The region that an Amazon VPC was created in.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_route53_vpc_association_authorization',
                'db_table_comment': 'AWS Route53 VPC Association Authorization',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsRoute53Zone',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the domain. For public hosted zones, this is the name that is registered with your DNS registrar.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The ID that Amazon Route 53 assigned to the hosted zone when it was created.', primary_key=True, serialize=False)),
                ('caller_reference', models.TextField(blank=True, db_comment='The value that you specified for CallerReference when you created the hosted zone.', null=True)),
                ('comment', models.TextField(blank=True, db_comment='A comment for the zone.', null=True)),
                ('private_zone', models.BooleanField(blank=True, db_comment='If true, the zone is Private hosted Zone, otherwise it is public.', null=True)),
                ('linked_service_principal', models.TextField(blank=True, db_comment='If the health check or hosted zone was created by another service, the service that created the resource.', null=True)),
                ('linked_service_description', models.TextField(blank=True, db_comment='If the health check or hosted zone was created by another service, an optional description that can be provided by the other service.', null=True)),
                ('resource_record_set_count', models.BigIntegerField(blank=True, db_comment='The number of resource record sets in the hosted zone.', null=True)),
                ('query_logging_configs', models.JSONField(blank=True, db_comment='A list of configuration for DNS query logging that is associated with the current AWS account.', null=True)),
                ('dnssec_key_signing_keys', models.JSONField(blank=True, db_comment='The key-signing keys (KSKs) in AWS account.', null=True)),
                ('dnssec_status', models.JSONField(blank=True, db_comment='The status of DNSSEC.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('vpcs', models.JSONField(blank=True, db_comment='The list of VPCs that are authorized to be associated with the specified hosted zone.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('resource_record_set_limit', models.JSONField(blank=True, db_comment='The maximum number of resource record sets allowed in the hosted zone.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_route53_zone',
                'db_table_comment': 'AWS Route53 Zone',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsS3AccessPoint',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='Specifies the name of the access point.', null=True)),
                ('access_point_arn', models.TextField(blank=True, db_comment='Amazon Resource Name (ARN) of the access point.', null=True)),
                ('bucket_name', models.TextField(blank=True, db_comment='The name of the bucket associated with this access point.', null=True)),
                ('access_point_policy_is_public', models.BooleanField(blank=True, db_comment='Indicates whether this access point policy is public, or not.', null=True)),
                ('block_public_acls', models.BooleanField(blank=True, db_comment='Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account.', null=True)),
                ('block_public_policy', models.BooleanField(blank=True, db_comment='Specifies whether Amazon S3 should block public bucket policies for buckets in this account.', null=True)),
                ('ignore_public_acls', models.BooleanField(blank=True, db_comment='Specifies whether Amazon S3 should ignore public ACLs for buckets in this account.', null=True)),
                ('restrict_public_buckets', models.BooleanField(blank=True, db_comment='Specifies whether Amazon S3 should restrict public bucket policies for buckets in this account.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The date and time when the specified access point was created.', null=True)),
                ('network_origin', models.TextField(blank=True, db_comment="Indicates whether this access point allows access from the public internet. If VpcConfiguration is specified for this access point, then NetworkOrigin is VPC, and the access point doesn't allow access from the public internet.", null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='Specifies the VPC ID from which the access point will only allow connections.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='The access point policy associated with the specified access point.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the policy in a canonical form for easier searching.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_s3_access_point',
                'db_table_comment': 'AWS S3 Access Point',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsS3AccountSettings',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('block_public_acls', models.BooleanField(blank=True, db_comment='Specifies whether Amazon S3 should block public access control lists (ACLs) for this bucket and objects in this bucket', null=True)),
                ('block_public_policy', models.BooleanField(blank=True, db_comment='Specifies whether Amazon S3 should block public bucket policies for this bucket. If TRUE it causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access', null=True)),
                ('ignore_public_acls', models.BooleanField(blank=True, db_comment='Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on this bucket and objects in this bucket', null=True)),
                ('restrict_public_buckets', models.BooleanField(blank=True, db_comment='Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS service principals and authorized users within this account if the bucket has a public policy', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_s3_account_settings',
                'db_table_comment': 'AWS S3 Account Block Public Access Settings',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsS3Bucket',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The user friendly name of the bucket.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the AWS S3 Bucket.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The date and time when bucket was created.', null=True)),
                ('bucket_policy_is_public', models.BooleanField(blank=True, db_comment='The policy status for an Amazon S3 bucket, indicating whether the bucket is public.', null=True)),
                ('versioning_enabled', models.BooleanField(blank=True, db_comment='The versioning state of a bucket.', null=True)),
                ('versioning_mfa_delete', models.BooleanField(blank=True, db_comment='The MFA Delete status of the versioning state.', null=True)),
                ('block_public_acls', models.BooleanField(blank=True, db_comment='Specifies whether Amazon S3 should block public access control lists (ACLs) for this bucket and objects in this bucket.', null=True)),
                ('block_public_policy', models.BooleanField(blank=True, db_comment='Specifies whether Amazon S3 should block public bucket policies for this bucket. If TRUE it causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.', null=True)),
                ('ignore_public_acls', models.BooleanField(blank=True, db_comment='Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on this bucket and objects in this bucket.', null=True)),
                ('restrict_public_buckets', models.BooleanField(blank=True, db_comment='Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS service principals and authorized users within this account if the bucket has a public policy.', null=True)),
                ('event_notification_configuration', models.JSONField(blank=True, db_comment='A container for specifying the notification configuration of the bucket. If this element is empty, notifications are turned off for the bucket.', null=True)),
                ('server_side_encryption_configuration', models.JSONField(blank=True, db_comment='The default encryption configuration for an Amazon S3 bucket.', null=True)),
                ('acl', models.JSONField(blank=True, db_comment='The access control list (ACL) of a bucket.', null=True)),
                ('lifecycle_rules', models.JSONField(blank=True, db_comment='The lifecycle configuration information of the bucket.', null=True)),
                ('logging', models.JSONField(blank=True, db_comment='The logging status of a bucket and the permissions users have to view and modify that status.', null=True)),
                ('object_lock_configuration', models.JSONField(blank=True, db_comment="The specified bucket's object lock configuration.", null=True)),
                ('object_ownership_controls', models.JSONField(blank=True, db_comment='The Ownership Controls for an Amazon S3 bucket.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='The resource IAM access document for the bucket.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the policy in a canonical form for easier searching.', null=True)),
                ('replication', models.JSONField(blank=True, db_comment='The replication configuration of a bucket.', null=True)),
                ('website_configuration', models.JSONField(blank=True, db_comment='The website configuration information of the bucket.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to bucket.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_s3_bucket',
                'db_table_comment': 'AWS S3 Bucket',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsS3BucketIntelligentTieringConfiguration',
            fields=[
                ('bucket_name', models.TextField(blank=True, db_comment='The name of the container bucket of this object.', primary_key=True, serialize=False)),
                ('id', models.TextField(blank=True, db_comment='The ID used to identify the S3 Intelligent-Tiering configuration.', null=True)),
                ('status', models.TextField(blank=True, db_comment='Specifies the status of the configuration.', null=True)),
                ('tierings', models.JSONField(blank=True, db_comment='Specifies the S3 Intelligent-Tiering storage class tier of the configuration.', null=True)),
                ('filter', models.JSONField(blank=True, db_comment="Specifies a bucket filter. The configuration only includes objects that meet the filter's criteria.", null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_s3_bucket_intelligent_tiering_configuration',
                'db_table_comment': 'AWS S3 Bucket Intelligent Tiering Configuration',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsS3MultiRegionAccessPoint',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the Multi-Region Access Point.', null=True)),
                ('alias', models.TextField(blank=True, db_comment='The alias for the Multi-Region Access Point.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='When the Multi-Region Access Point create request was received.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current status of the Multi-Region Access Point. CREATING and DELETING are temporary states that exist while the request is propagating and being completed.', null=True)),
                ('public_access_block', models.JSONField(blank=True, db_comment='The PublicAccessBlock configuration that you want to apply to this Amazon S3 account.', null=True)),
                ('regions', models.JSONField(blank=True, db_comment='A collection of the Regions and buckets associated with the Multi-Region Access Point.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_s3_multi_region_access_point',
                'db_table_comment': 'AWS S3 Multi Region Access Point',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSagemakerApp',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The app name.', null=True)),
                ('app_type', models.TextField(blank=True, db_comment='The type of app.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the app.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='A timestamp that indicates when the app was created.', null=True)),
                ('domain_id', models.TextField(blank=True, db_comment='The domain ID.', null=True)),
                ('failure_reason', models.TextField(blank=True, db_comment='The failure reason.', null=True)),
                ('last_health_check_timestamp', models.DateTimeField(blank=True, db_comment='The timestamp of the last health check.', null=True)),
                ('last_user_activity_timestamp', models.DateTimeField(blank=True, db_comment='The timestamp of the last user activity.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the app.', null=True)),
                ('user_profile_name', models.TextField(blank=True, db_comment='The user profile name.', null=True)),
                ('resource_spec', models.JSONField(blank=True, db_comment='The instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_sagemaker_app',
                'db_table_comment': 'AWS Sagemaker App',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSagemakerDomain',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The domain ID.', primary_key=True, serialize=False)),
                ('name', models.TextField(blank=True, db_comment='The domain name.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the domain.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='A timestamp that indicates when the domain was created.', null=True)),
                ('app_network_access_type', models.TextField(blank=True, db_comment='Specifies the VPC used for non-EFS traffic.', null=True)),
                ('app_security_group_management', models.TextField(blank=True, db_comment='The entity that creates and manages the required security groups for inter-app communication in VPCOnly mode.', null=True)),
                ('auth_mode', models.TextField(blank=True, db_comment="The domain's authentication mode.", null=True)),
                ('failure_reason', models.TextField(blank=True, db_comment="The domain's failure reason.", null=True)),
                ('home_efs_file_system_id', models.TextField(blank=True, db_comment='The ID of the Amazon Elastic File System (EFS) managed by this domain.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The Amazon Web Services KMS customer managed key used to encrypt the EFS volume attached to the domain.', null=True)),
                ('last_modified_time', models.DateTimeField(blank=True, db_comment="The domain's last modified time.", null=True)),
                ('security_group_id_for_domain_boundary', models.TextField(blank=True, db_comment='The ID of the security group that authorizes traffic between the RSessionGateway apps and the RStudioServerPro app.', null=True)),
                ('single_sign_on_managed_application_instance_id', models.TextField(blank=True, db_comment='The SSO managed application instance ID.', null=True)),
                ('status', models.TextField(blank=True, db_comment="The domain's status.", null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The list of tags for the domain.', null=True)),
                ('url', models.TextField(blank=True, db_comment="The domain's URL.", null=True)),
                ('default_user_settings', models.JSONField(blank=True, db_comment='Settings which are applied to UserProfiles in this domain if settings are not explicitly specified in a given UserProfile.', null=True)),
                ('domain_settings', models.JSONField(blank=True, db_comment='A collection of domain settings.', null=True)),
                ('subnet_ids', models.JSONField(blank=True, db_comment='The VPC subnets that studio uses for communication.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_sagemaker_domain',
                'db_table_comment': 'AWS Sagemaker Domain',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSagemakerEndpointConfiguration',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the endpoint configuration.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the endpoint configuration.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='A timestamp that shows when the endpoint configuration was created.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='AWS KMS key ID Amazon SageMaker uses to encrypt data when storing it on the ML storage volume attached to the instance.', null=True)),
                ('data_capture_config', models.JSONField(blank=True, db_comment='Specifies the parameters to capture input/output of Sagemaker models endpoints.', null=True)),
                ('production_variants', models.JSONField(blank=True, db_comment='An array of ProductionVariant objects, one for each model that you want to host at this endpoint.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The list of tags for the endpoint configuration.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_sagemaker_endpoint_configuration',
                'db_table_comment': 'AWS Sagemaker Endpoint Configuration',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSagemakerModel',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the model.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the model.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='A timestamp that indicates when the model was created.', null=True)),
                ('enable_network_isolation', models.BooleanField(blank=True, db_comment='If True, no inbound or outbound network calls can be made to or from the model container.', null=True)),
                ('execution_role_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the IAM role that you specified for the model.', null=True)),
                ('containers', models.JSONField(blank=True, db_comment='The containers in the inference pipeline.', null=True)),
                ('inference_execution_config', models.JSONField(blank=True, db_comment='Specifies details of how containers in a multi-container endpoint are called.', null=True)),
                ('primary_container', models.JSONField(blank=True, db_comment='The location of the primary inference code, associated artifacts, and custom environment map that the inference code uses when it is deployed in production.', null=True)),
                ('vpc_config', models.JSONField(blank=True, db_comment='A VpcConfig object that specifies the VPC that this model has access to.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The list of tags for the model.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_sagemaker_model',
                'db_table_comment': 'AWS Sagemaker Model',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSagemakerNotebookInstance',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the notebook instance.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the notebook instance.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='A timestamp that shows when the notebook instance was created.', null=True)),
                ('default_code_repository', models.TextField(blank=True, db_comment='The Git repository associated with the notebook instance as its default code repository.', null=True)),
                ('direct_internet_access', models.TextField(blank=True, db_comment='Describes whether Amazon SageMaker provides internet access to the notebook instance.', null=True)),
                ('failure_reason', models.TextField(blank=True, db_comment='If status is Failed, the reason it failed.', null=True)),
                ('instance_type', models.TextField(blank=True, db_comment='The type of ML compute instance that the notebook instance is running on.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The AWS KMS key ID Amazon SageMaker uses to encrypt data when storing it on the ML storage volume attached to the instance.', null=True)),
                ('last_modified_time', models.DateTimeField(blank=True, db_comment='A timestamp that shows when the notebook instance was last modified.', null=True)),
                ('network_interface_id', models.TextField(blank=True, db_comment='The network interface IDs that Amazon SageMaker created at the time of creating the instance.', null=True)),
                ('notebook_instance_lifecycle_config_name', models.TextField(blank=True, db_comment='The name of a notebook instance lifecycle configuration associated with this notebook instance.', null=True)),
                ('notebook_instance_status', models.TextField(blank=True, db_comment='The status of the notebook instance.', null=True)),
                ('role_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the IAM role associated with the instance.', null=True)),
                ('root_access', models.TextField(blank=True, db_comment='Whether root access is enabled or disabled for users of the notebook instance.Lifecycle configurations need root access to be able to set up a notebook instance', null=True)),
                ('subnet_id', models.TextField(blank=True, db_comment='The ID of the VPC subnet.', null=True)),
                ('url', models.TextField(blank=True, db_comment='The URL that you use to connect to the Jupyter notebook that is running in your notebook instance.', null=True)),
                ('volume_size_in_gb', models.BigIntegerField(blank=True, db_comment='The size, in GB, of the ML storage volume attached to the notebook instance.', null=True)),
                ('accelerator_types', models.JSONField(blank=True, db_comment='The list of the Elastic Inference (EI) instance types associated with this notebook instance.', null=True)),
                ('additional_code_repositories', models.JSONField(blank=True, db_comment='An array of up to three Git repositories associated with the notebook instance.', null=True)),
                ('security_groups', models.JSONField(blank=True, db_comment='The IDs of the VPC security groups.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The list of tags for the notebook instance.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_sagemaker_notebook_instance',
                'db_table_comment': 'AWS Sagemaker Notebook Instance',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSagemakerTrainingJob',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the training job.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the training job.', null=True)),
                ('training_job_status', models.TextField(blank=True, db_comment='The status of the training job.', null=True)),
                ('auto_ml_job_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of an AutoML job.', null=True)),
                ('billable_time_in_seconds', models.BigIntegerField(blank=True, db_comment='The billable time in seconds. Billable time refers to the absolute wall-clock time.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='A timestamp that shows when the training job was created.', null=True)),
                ('enable_managed_spot_training', models.BooleanField(blank=True, db_comment='A Boolean indicating whether managed spot training is enabled or not.', null=True)),
                ('enable_network_isolation', models.BooleanField(blank=True, db_comment='Specifies enable network isolation for training jobs.', null=True)),
                ('enable_inter_container_traffic_encryption', models.BooleanField(blank=True, db_comment='To encrypt all communications between ML compute instances in distributed training, choose True.', null=True)),
                ('failure_reason', models.TextField(blank=True, db_comment='If the training job failed, the reason it failed.', null=True)),
                ('labeling_job_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the Amazon SageMaker Ground Truth labeling job that created the transform or training job.', null=True)),
                ('last_modified_time', models.DateTimeField(blank=True, db_comment='Timestamp when the training job was last modified.', null=True)),
                ('profiling_status', models.TextField(blank=True, db_comment='Profiling status of a training job.', null=True)),
                ('role_arn', models.TextField(blank=True, db_comment='The AWS Identity and Access Management (IAM) role configured for the training job.', null=True)),
                ('secondary_status', models.TextField(blank=True, db_comment='Provides detailed information about the state of the training job.', null=True)),
                ('training_end_time', models.DateTimeField(blank=True, db_comment='A timestamp that shows when the training job ended.', null=True)),
                ('training_start_time', models.DateTimeField(blank=True, db_comment='Indicates the time when the training job starts on training instances.', null=True)),
                ('training_time_in_seconds', models.BigIntegerField(blank=True, db_comment='The training time in seconds.', null=True)),
                ('tuning_job_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the associated hyperparameter tuning job if the training job was launched by a hyperparameter tuning job.', null=True)),
                ('algorithm_specification', models.JSONField(blank=True, db_comment='Information about the algorithm used for training, and algorithm metadata.', null=True)),
                ('checkpoint_config', models.JSONField(blank=True, db_comment='Contains information about the output location for managed spot training checkpoint data.', null=True)),
                ('debug_hook_config', models.JSONField(blank=True, db_comment='Configuration information for the Debugger hook parameters, metric and tensor collections, and storage paths.', null=True)),
                ('debug_rule_configurations', models.JSONField(blank=True, db_comment='Configuration information for Debugger rules for debugging output tensors.', null=True)),
                ('debug_rule_evaluation_statuses', models.JSONField(blank=True, db_comment='Evaluation status of Debugger rules for debugging on a training job.', null=True)),
                ('environment', models.JSONField(blank=True, db_comment='The environment variables to set in the Docker container.', null=True)),
                ('experiment_config', models.JSONField(blank=True, db_comment='Associates a SageMaker job as a trial component with an experiment and trial.', null=True)),
                ('final_metric_data_list', models.JSONField(blank=True, db_comment='A collection of MetricData objects that specify the names, values, and dates and times that the training algorithm emitted to Amazon CloudWatch.', null=True)),
                ('hyper_parameters', models.JSONField(blank=True, db_comment='Algorithm-specific parameters.', null=True)),
                ('input_data_config', models.JSONField(blank=True, db_comment='An array of Channel objects that describes each data input channel.', null=True)),
                ('model_artifacts', models.JSONField(blank=True, db_comment='Information about the Amazon S3 location that is configured for storing model artifacts.', null=True)),
                ('output_data_config', models.JSONField(blank=True, db_comment='The S3 path where model artifacts that you configured when creating the job are stored.', null=True)),
                ('profiler_config', models.JSONField(blank=True, db_comment='Configuration information for Debugger system monitoring,framework profiling and storage paths.', null=True)),
                ('profiler_rule_configurations', models.JSONField(blank=True, db_comment='Configuration information for Debugger rules for profiling system and framework metrics.', null=True)),
                ('profiler_rule_evaluation_statuses', models.JSONField(blank=True, db_comment='Evaluation status of Debugger rules for profiling on a training job.', null=True)),
                ('resource_config', models.JSONField(blank=True, db_comment='Resources, including ML compute instances and ML storage volumes, that are configured for model training.', null=True)),
                ('secondary_status_transitions', models.JSONField(blank=True, db_comment='A history of all of the secondary statuses that the training job has transitioned through.', null=True)),
                ('stopping_condition', models.JSONField(blank=True, db_comment='Specifies a limit to how long a model training job can run.', null=True)),
                ('tensor_board_output_config', models.JSONField(blank=True, db_comment='Configuration of storage locations for the Debugger TensorBoard output data.', null=True)),
                ('vpc_config', models.JSONField(blank=True, db_comment='A VpcConfig object that specifies the VPC that this training job has access to.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the training job.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_sagemaker_training_job',
                'db_table_comment': 'AWS SageMaker Training Job',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSecretsmanagerSecret',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The friendly name of the secret.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the secret.', null=True)),
                ('created_date', models.DateTimeField(blank=True, db_comment='The date and time when a secret was created.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The user-provided description of the secret.', null=True)),
                ('kms_key_id', models.TextField(blank=True, db_comment='The ARN or alias of the AWS KMS customer master key (CMK) used to encrypt the SecretString and SecretBinary fields in each version of the secret.', null=True)),
                ('deleted_date', models.DateTimeField(blank=True, db_comment='The date and time the deletion of the secret occurred.', null=True)),
                ('last_accessed_date', models.DateTimeField(blank=True, db_comment='The last date that this secret was accessed.', null=True)),
                ('last_changed_date', models.DateTimeField(blank=True, db_comment='The last date and time that this secret was modified in any way.', null=True)),
                ('last_rotated_date', models.DateTimeField(blank=True, db_comment='The most recent date and time that the Secrets Manager rotation process was successfully completed.', null=True)),
                ('owning_service', models.TextField(blank=True, db_comment='Returns the name of the service that created the secret.', null=True)),
                ('primary_region', models.TextField(blank=True, db_comment='The Region where Secrets Manager originated the secret.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='A JSON-formatted string that describes the permissions that are associated with the attached secret.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the permissions that are associated with the attached secret in a canonical form for easier searching.', null=True)),
                ('replication_status', models.JSONField(blank=True, db_comment='Describes a list of replication status objects as InProgress, Failed or InSync.', null=True)),
                ('rotation_enabled', models.BooleanField(blank=True, db_comment='Indicates whether automatic, scheduled rotation is enabled for this secret.', null=True)),
                ('rotation_lambda_arn', models.TextField(blank=True, db_comment='The ARN of an AWS Lambda function invoked by Secrets Manager to rotate and expire the secret either automatically per the schedule or manually by a call to RotateSecret.', null=True)),
                ('rotation_rules', models.JSONField(blank=True, db_comment='A structure that defines the rotation configuration for the secret.', null=True)),
                ('secret_versions_to_stages', models.JSONField(blank=True, db_comment='A list of all of the currently assigned SecretVersionStage staging labels and the SecretVersionId attached to each one.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The list of user-defined tags associated with the secret.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_secretsmanager_secret',
                'db_table_comment': 'AWS Secrets Manager Secret',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSecurityhubActionTarget',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the action target.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN for the target action.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the target action.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_securityhub_action_target',
                'db_table_comment': 'AWS Security Hub Action Target',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSecurityhubFinding',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The security findings provider-specific identifier for a finding.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the finding.', null=True)),
                ('company_name', models.TextField(blank=True, db_comment='The name of the company for the product that generated the finding.', null=True)),
                ('confidence', models.BigIntegerField(blank=True, db_comment="A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify.", null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='Indicates when the security-findings provider created the potential security issue that a finding captured.', null=True)),
                ('compliance_status', models.TextField(blank=True, db_comment='The result of a compliance standards check.', null=True)),
                ('updated_at', models.DateTimeField(blank=True, db_comment='Indicates when the security-findings provider last updated the finding record.', null=True)),
                ('criticality', models.BigIntegerField(blank=True, db_comment='The level of importance assigned to the resources associated with the finding.', null=True)),
                ('description', models.TextField(blank=True, db_comment="A finding's description.", null=True)),
                ('first_observed_at', models.DateTimeField(blank=True, db_comment='Indicates when the security-findings provider first observed the potential security issue that a finding captured.', null=True)),
                ('generator_id', models.TextField(blank=True, db_comment='The identifier for the solution-specific component (a discrete unit of logic) that generated a finding.', null=True)),
                ('last_observed_at', models.DateTimeField(blank=True, db_comment='Indicates when the security-findings provider most recently observed the potential security issue that a finding captured.', null=True)),
                ('product_arn', models.TextField(blank=True, db_comment='The ARN generated by Security Hub that uniquely identifies a product that generates findings.', null=True)),
                ('product_name', models.TextField(blank=True, db_comment='The name of the product that generated the finding.', null=True)),
                ('record_state', models.TextField(blank=True, db_comment='The record state of a finding.', null=True)),
                ('schema_version', models.TextField(blank=True, db_comment='The schema version that a finding is formatted for.', null=True)),
                ('source_url', models.TextField(blank=True, db_comment="A URL that links to a page about the current finding in the security-findings provider's solution.", null=True)),
                ('verification_state', models.TextField(blank=True, db_comment='Indicates the veracity of a finding.', null=True)),
                ('workflow_state', models.TextField(blank=True, db_comment='[DEPRECATED] This column has been deprecated and will be removed in a future release. The workflow state of a finding.', null=True)),
                ('workflow_status', models.TextField(blank=True, db_comment='The workflow status of a finding. Possible values are NEW, NOTIFIED, SUPPRESSED, RESOLVED.', null=True)),
                ('standards_control_arn', models.TextField(blank=True, db_comment='The ARN of the security standard control.', null=True)),
                ('action', models.JSONField(blank=True, db_comment='Provides details about an action that affects or that was taken on a resource.', null=True)),
                ('compliance', models.JSONField(blank=True, db_comment='This data type is exclusive to findings that are generated as the result of a check run against a specific rule in a supported security standard, such as CIS Amazon Web Services Foundations.', null=True)),
                ('finding_provider_fields', models.JSONField(blank=True, db_comment='In a BatchImportFindings request, finding providers use FindingProviderFields to provide and update their own values for confidence, criticality, related findings, severity, and types.', null=True)),
                ('malware', models.JSONField(blank=True, db_comment='A list of malware related to a finding.', null=True)),
                ('network', models.JSONField(blank=True, db_comment='The details of network-related information about a finding.', null=True)),
                ('network_path', models.JSONField(blank=True, db_comment='Provides information about a network path that is relevant to a finding. Each entry under NetworkPath represents a component of that path.', null=True)),
                ('note', models.JSONField(blank=True, db_comment='A user-defined note added to a finding.', null=True)),
                ('patch_summary', models.JSONField(blank=True, db_comment='Provides an overview of the patch compliance status for an instance against a selected compliance standard.', null=True)),
                ('process', models.JSONField(blank=True, db_comment='The details of process-related information about a finding.', null=True)),
                ('product_fields', models.JSONField(blank=True, db_comment="A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format.", null=True)),
                ('related_findings', models.JSONField(blank=True, db_comment='A list of related findings.', null=True)),
                ('remediation', models.JSONField(blank=True, db_comment='A data type that describes the remediation options for a finding.', null=True)),
                ('resources', models.JSONField(blank=True, db_comment='A set of resource data types that describe the resources that the finding refers to.', null=True)),
                ('severity', models.JSONField(blank=True, db_comment="A finding's severity.", null=True)),
                ('threat_intel_indicators', models.JSONField(blank=True, db_comment='Threat intelligence details related to a finding.', null=True)),
                ('user_defined_fields', models.JSONField(blank=True, db_comment='A list of name/value string pairs associated with the finding.', null=True)),
                ('vulnerabilities', models.JSONField(blank=True, db_comment='Provides a list of vulnerabilities associated with the findings.', null=True)),
                ('source_account_id', models.TextField(blank=True, db_comment='The account id where the affected resource lives.', null=True)),
                ('title', models.TextField(blank=True, db_comment="A finding's title.", null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_securityhub_finding',
                'db_table_comment': 'AWS Security Hub Finding',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSecurityhubFindingAggregator',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the finding aggregator.', null=True)),
                ('finding_aggregation_region', models.TextField(blank=True, db_comment='The aggregation Region.', null=True)),
                ('region_linking_mode', models.TextField(blank=True, db_comment='Indicates whether to link all Regions, all Regions except for a list of excluded Regions, or a list of included Regions.', null=True)),
                ('regions', models.JSONField(blank=True, db_comment='The list of excluded Regions or included Regions.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_securityhub_finding_aggregator',
                'db_table_comment': 'AWS Security Hub Finding Aggregator',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSecurityhubHub',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('hub_arn', models.TextField(blank=True, db_comment='The ARN of the Hub resource that was retrieved.', null=True)),
                ('administrator_account', models.JSONField(blank=True, db_comment='Provides the details for the Security Hub administrator account for the current member account.', null=True)),
                ('auto_enable_controls', models.BooleanField(blank=True, db_comment='Whether to automatically enable new controls when they are added to standards that are enabled.', null=True)),
                ('subscribed_at', models.DateTimeField(blank=True, db_comment='The date and time when Security Hub was enabled in the account.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment="The title of hub. This is a constant value 'default'", null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_securityhub_hub',
                'db_table_comment': 'AWS Security Hub',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSecurityhubInsight',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of a Security Hub insight.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of a Security Hub insight.', null=True)),
                ('group_by_attribute', models.TextField(blank=True, db_comment="The grouping attribute for the insight's findings. Indicates how to group the matching findings,and identifies the type of item that the insight applies to. For example, if an insight is grouped by resource identifier, then the insight produces a list of resource identifiers.", null=True)),
                ('filters', models.JSONField(blank=True, db_comment='One or more attributes used to filter the findings included in the insight. The insight only includes findings that match the criteria defined in the filters.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_securityhub_insight',
                'db_table_comment': 'AWS Securityhub Insight',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSecurityhubMember',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('member_account_id', models.TextField(blank=True, db_comment='The Amazon Web Services account ID of the member account.', null=True)),
                ('administrator_id', models.TextField(blank=True, db_comment='The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.', null=True)),
                ('email', models.TextField(blank=True, db_comment='The email address of the member account.', null=True)),
                ('invited_at', models.DateTimeField(blank=True, db_comment='A timestamp for the date and time when the invitation was sent to the member account.', null=True)),
                ('master_id', models.TextField(blank=True, db_comment='The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.', null=True)),
                ('member_status', models.TextField(blank=True, db_comment='The status of the relationship between the member account and its administrator account.', null=True)),
                ('updated_at', models.DateTimeField(blank=True, db_comment='The timestamp for the date and time when the member account was updated.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_securityhub_member',
                'db_table_comment': 'AWS Securityhub Member',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSecurityhubProduct',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the product.', null=True)),
                ('product_arn', models.TextField(blank=True, db_comment='The ARN assigned to the product.', null=True)),
                ('activation_url', models.TextField(blank=True, db_comment='The URL used to activate the product.', null=True)),
                ('company_name', models.TextField(blank=True, db_comment='The name of the company that provides the product.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the product.', null=True)),
                ('marketplace_url', models.TextField(blank=True, db_comment='The URL for the page that contains more information about the product.', null=True)),
                ('categories', models.JSONField(blank=True, db_comment='The categories assigned to the product.', null=True)),
                ('integration_types', models.JSONField(blank=True, db_comment='The types of integration that the product supports.', null=True)),
                ('product_subscription_resource_policy', models.JSONField(blank=True, db_comment='The resource policy associated with the product.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_securityhub_product',
                'db_table_comment': 'AWS Securityhub Product',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSecurityhubStandardsControl',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('control_id', models.TextField(blank=True, db_comment='The identifier of the security standard control.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the security standard control.', null=True)),
                ('control_status', models.TextField(blank=True, db_comment='The current status of the security standard control. Indicates whether the control is enabled or disabled. Security Hub does not check against disabled controls.', null=True)),
                ('severity_rating', models.TextField(blank=True, db_comment='The severity of findings generated from this security standard control.', null=True)),
                ('control_status_updated_at', models.DateTimeField(blank=True, db_comment='The date and time that the status of the security standard control was most recently updated.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The longer description of the security standard control.', null=True)),
                ('disabled_reason', models.TextField(blank=True, db_comment='The reason provided for the most recent change in status for the control.', null=True)),
                ('remediation_url', models.TextField(blank=True, db_comment='A link to remediation information for the control in the Security Hub user documentation.', null=True)),
                ('related_requirements', models.JSONField(blank=True, db_comment='The list of requirements that are related to this control.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_securityhub_standards_control',
                'db_table_comment': 'AWS Security Hub Standards Control',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSecurityhubStandardsSubscription',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the standard.', null=True)),
                ('standards_arn', models.TextField(blank=True, db_comment='The ARN of a standard.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the standard.', null=True)),
                ('enabled_by_default', models.BooleanField(blank=True, db_comment='Indicates whether the standard is enabled by default.', null=True)),
                ('standards_status', models.TextField(blank=True, db_comment='The status of the standard subscription.', null=True)),
                ('standards_status_reason_code', models.TextField(blank=True, db_comment='The reason code that represents the reason for the current status of a standard subscription.', null=True)),
                ('standards_subscription_arn', models.TextField(blank=True, db_comment='The ARN of a resource that represents your subscription to a supported standard.', null=True)),
                ('standards_input', models.JSONField(blank=True, db_comment='A key-value pair of input for the standard.', null=True)),
                ('standards_managed_by', models.JSONField(blank=True, db_comment='Provides details about the management of a security standard.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_securityhub_standards_subscription',
                'db_table_comment': 'AWS Security Hub Standards Subscription',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsServerlessapplicationrepositoryApplication',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the application.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The application Amazon Resource Name (ARN).', null=True)),
                ('author', models.TextField(blank=True, db_comment='The name of the author publishing the app.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The date and time this resource was created.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the application.', null=True)),
                ('home_page_url', models.TextField(blank=True, db_comment='A URL with more information about the application.', null=True)),
                ('is_verified_author', models.BooleanField(blank=True, db_comment='Whether the author is verified.', null=True)),
                ('license_url', models.TextField(blank=True, db_comment='The URL of the license.', null=True)),
                ('readme_url', models.TextField(blank=True, db_comment='The URL of the Readme.', null=True)),
                ('spdx_license_id', models.TextField(blank=True, db_comment='A valid identifier from https://spdx.org/licenses/.', null=True)),
                ('verified_author_url', models.TextField(blank=True, db_comment='The URL of the verified author.', null=True)),
                ('labels', models.JSONField(blank=True, db_comment='Labels to improve discovery of apps in search results.', null=True)),
                ('statements', models.JSONField(blank=True, db_comment='The contents of the access policy.', null=True)),
                ('version', models.JSONField(blank=True, db_comment='The policy statement of the application.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_serverlessapplicationrepository_application',
                'db_table_comment': 'AWS Serverless Application Repository Application',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsServicecatalogPortfolio',
            fields=[
                ('display_name', models.TextField(blank=True, db_comment='The name to use for display purposes.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The portfolio identifier.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The ARN assigned to the portfolio.', null=True)),
                ('created_time', models.DateTimeField(blank=True, db_comment='The UTC timestamp of the creation time.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the portfolio.', null=True)),
                ('provider_name', models.TextField(blank=True, db_comment='The name of the portfolio provider.', null=True)),
                ('budgets', models.JSONField(blank=True, db_comment='Information about the associated budgets.', null=True)),
                ('tag_options', models.JSONField(blank=True, db_comment='Information about the tag options associated with the portfolio.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='Information about the tags associated with the portfolio.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_servicecatalog_portfolio',
                'db_table_comment': 'AWS Service Catalog Portfolio',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsServicecatalogProduct',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the product.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The product view identifier.', primary_key=True, serialize=False)),
                ('product_id', models.TextField(blank=True, db_comment='The product identifier.', null=True)),
                ('source_product_id', models.TextField(blank=True, db_comment='The source product identifier.', null=True)),
                ('distributor', models.TextField(blank=True, db_comment='The distributor of the product. Contact the product administrator for the significance of this value.', null=True)),
                ('accept_language', models.TextField(blank=True, db_comment='The language code.', null=True)),
                ('full_text_search', models.TextField(blank=True, db_comment='The full text for the product.', null=True)),
                ('has_default_path', models.BooleanField(blank=True, db_comment='Indicates whether the product has a default path. If the product does not have a default path, call ListLaunchPaths to disambiguate between paths.', null=True)),
                ('owner', models.TextField(blank=True, db_comment='The owner of the product. Contact the product administrator for the significance of this value.', null=True)),
                ('short_description', models.TextField(blank=True, db_comment='Short description of the product.', null=True)),
                ('support_description', models.TextField(blank=True, db_comment='The description of the support for this product.', null=True)),
                ('support_email', models.TextField(blank=True, db_comment='The email contact information to obtain support for this product.', null=True)),
                ('support_url', models.TextField(blank=True, db_comment='The URL information to obtain support for this product.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The product type. Contact the product administrator for the significance of this value. If this value is MARKETPLACE, the product was created by Amazon Web Services Marketplace.', null=True)),
                ('budgets', models.JSONField(blank=True, db_comment='Information about the associated budgets.', null=True)),
                ('launch_paths', models.JSONField(blank=True, db_comment='Information about the associated launch paths.', null=True)),
                ('provisioning_artifacts', models.JSONField(blank=True, db_comment='Information about the provisioning artifacts for the specified product.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_servicecatalog_product',
                'db_table_comment': 'AWS Service Catalog Product',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsServicecatalogProvisionedProduct',
            fields=[
                ('arn', models.TextField(blank=True, db_comment='The ARN of the provisioned product.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The identifier of the provisioned product.', primary_key=True, serialize=False)),
                ('created_time', models.DateTimeField(blank=True, db_comment='The UTC time stamp of the creation time.', null=True)),
                ('idempotency_token', models.TextField(blank=True, db_comment='A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.', null=True)),
                ('last_provisioning_record_id', models.TextField(blank=True, db_comment='The record identifier of the last request performed on this provisioned product.', null=True)),
                ('accept_language', models.TextField(blank=True, db_comment='The language code.', null=True)),
                ('last_record_id', models.TextField(blank=True, db_comment='The record identifier of the last request performed on this provisioned product.', null=True)),
                ('last_successful_provisioning_record_id', models.TextField(blank=True, db_comment='The record identifier of the last successful request performed on this provisioned product.', null=True)),
                ('launch_role_arn', models.TextField(blank=True, db_comment='The ARN of the launch role associated with the provisioned product.', null=True)),
                ('name', models.TextField(blank=True, db_comment='The user-friendly name of the provisioned product.', null=True)),
                ('product_id', models.TextField(blank=True, db_comment='The product identifier. For example, prod-abcdzk7xy33qa.', null=True)),
                ('provisioning_artifact_id', models.TextField(blank=True, db_comment='The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current status of the provisioned product.', null=True)),
                ('status_message', models.TextField(blank=True, db_comment='The current status message of the provisioned product.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of provisioned product. The supported values are CFN_STACK and CFN_STACKSET.', null=True)),
                ('cloud_watch_dashboards', models.JSONField(blank=True, db_comment='Any CloudWatch dashboards that were created when provisioning the product.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_servicecatalog_provisioned_product',
                'db_table_comment': 'AWS Service Catalog Provisioned Product',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsServiceDiscoveryInstance',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The ID of the instance.', primary_key=True, serialize=False)),
                ('service_id', models.TextField(blank=True, db_comment='The ID of the service.', null=True)),
                ('ec2_instance_id', models.TextField(blank=True, db_comment='The Amazon EC2 instance ID for the instance. When the AWS_EC2_INSTANCE_ID attribute is specified, then the AWS_INSTANCE_IPV4 attribute contains the primary private IPv4 address.', null=True)),
                ('alias_dns_name', models.TextField(blank=True, db_comment="For an alias record that routes traffic to an Elastic Load Balancing load balancer, the DNS name that's associated with the load balancer.", null=True)),
                ('instance_cname', models.TextField(blank=True, db_comment='A CNAME record, the domain name that Route 53 returns in response to DNS queries (for example, example.com ).', null=True)),
                ('init_health_status', models.TextField(blank=True, db_comment="If the service configuration includes HealthCheckCustomConfig, you can optionally use AWS_INIT_HEALTH_STATUS to specify the initial status of the custom health check, HEALTHY or UNHEALTHY. If you don't specify a value for AWS_INIT_HEALTH_STATUS, the initial status is HEALTHY.", null=True)),
                ('instance_ipv4', models.GenericIPAddressField(blank=True, db_comment='For an A record, the IPv4 address that Route 53 returns in response to DNS queries.', null=True)),
                ('instance_ipv6', models.GenericIPAddressField(blank=True, db_comment='For an AAAA record, the IPv6 address that Route 53 returns in response to DNS queries.', null=True)),
                ('instance_port', models.BigIntegerField(blank=True, db_comment='For an SRV record, the value that Route 53 returns for the port. In addition, if the service includes HealthCheckConfig, the port on the endpoint that Route 53 sends requests to.', null=True)),
                ('attributes', models.JSONField(blank=True, db_comment='Attributes of the instance.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_service_discovery_instance',
                'db_table_comment': 'AWS Service Discovery Instance',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsServiceDiscoveryNamespace',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the namespace.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The ID of the namespace.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that Cloud Map assigns to the namespace when you create it.', null=True)),
                ('create_date', models.DateTimeField(blank=True, db_comment='The date and time that the namespace was created.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description for the namespace.', null=True)),
                ('service_count', models.BigIntegerField(blank=True, db_comment='The number of services that were created using the namespace.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of the namespace, either public or private.', null=True)),
                ('dns_properties', models.JSONField(blank=True, db_comment='A complex type that contains the ID for the Route 53 hosted zone that Cloud Map creates when you create a namespace.', null=True)),
                ('http_properties', models.JSONField(blank=True, db_comment='A complex type that contains the name of an HTTP namespace.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='Information about the tags associated with the namespace.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_service_discovery_namespace',
                'db_table_comment': 'AWS Service Discovery Namespace',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsServiceDiscoveryService',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the service.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The ID that Cloud Map assigned to the service when you created it.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that Cloud Map assigns to the service when you create it.', null=True)),
                ('create_date', models.DateTimeField(blank=True, db_comment='The date and time that the service was created.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description for the service.', null=True)),
                ('namespace_id', models.TextField(blank=True, db_comment='The ID of the namespace.', null=True)),
                ('instance_count', models.BigIntegerField(blank=True, db_comment='The number of instances that are currently associated with the service.', null=True)),
                ('type', models.TextField(blank=True, db_comment='Describes the systems that can be used to discover the service instances. DNS_HTTP The service instances can be discovered using either DNS queries or the DiscoverInstances API operation. HTTP The service instances can only be discovered using the DiscoverInstances API operation. DNS Reserved.', null=True)),
                ('routing_policy', models.TextField(blank=True, db_comment='The routing policy that you want to apply to all Route 53 DNS records that Cloud Map creates when you register an instance and specify this service.', null=True)),
                ('dns_records', models.JSONField(blank=True, db_comment='An array that contains one DnsRecord object for each Route 53 DNS record that you want Cloud Map to create when you register an instance.', null=True)),
                ('health_check_config', models.JSONField(blank=True, db_comment='Public DNS and HTTP namespaces only. Settings for an optional health check. If you specify settings for a health check, Cloud Map associates the health check with the records that you specify in DnsConfig.', null=True)),
                ('health_check_custom_config', models.JSONField(blank=True, db_comment='Information about an optional custom health check.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='Information about the tags associated with the namespace.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_service_discovery_service',
                'db_table_comment': 'AWS Service Discovery Service',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsServicequotasDefaultServiceQuota',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('quota_name', models.TextField(blank=True, db_comment='The quota name.', null=True)),
                ('quota_code', models.TextField(blank=True, db_comment='The quota code.', null=True)),
                ('quota_arn', models.TextField(blank=True, db_comment='The arn of the service quota.', null=True)),
                ('global_quota', models.BooleanField(blank=True, db_comment='Indicates whether the quota is global.', null=True)),
                ('service_name', models.TextField(blank=True, db_comment='The service name.', null=True)),
                ('service_code', models.TextField(blank=True, db_comment='The service identifier.', null=True)),
                ('adjustable', models.BooleanField(blank=True, db_comment='Indicates whether the quota value can be increased.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The unit of measurement.', null=True)),
                ('value', models.BigIntegerField(blank=True, db_comment='The quota value.', null=True)),
                ('error_reason', models.JSONField(blank=True, db_comment='The error code and error reason.', null=True)),
                ('period', models.JSONField(blank=True, db_comment='The period of time for the quota.', null=True)),
                ('usage_metric', models.JSONField(blank=True, db_comment='Information about the measurement.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_servicequotas_default_service_quota',
                'db_table_comment': 'AWS Service Quotas Default Service Quota',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsServicequotasService',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('service_name', models.TextField(blank=True, db_comment='Specifies the service name.', null=True)),
                ('service_code', models.TextField(blank=True, db_comment='Specifies the service identifier.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_servicequotas_service',
                'db_table_comment': 'AWS Service Quotas Service',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsServicequotasServiceQuota',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('quota_name', models.TextField(blank=True, db_comment='The quota name.', null=True)),
                ('quota_code', models.TextField(blank=True, db_comment='The quota code.', null=True)),
                ('quota_arn', models.TextField(blank=True, db_comment='The arn of the service quota.', null=True)),
                ('global_quota', models.BooleanField(blank=True, db_comment='Indicates whether the quota is global.', null=True)),
                ('service_name', models.TextField(blank=True, db_comment='The service name.', null=True)),
                ('service_code', models.TextField(blank=True, db_comment='The service identifier.', null=True)),
                ('adjustable', models.BooleanField(blank=True, db_comment='Indicates whether the quota value can be increased.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The unit of measurement.', null=True)),
                ('value', models.BigIntegerField(blank=True, db_comment='The quota value.', null=True)),
                ('error_reason', models.JSONField(blank=True, db_comment='The error code and error reason.', null=True)),
                ('period', models.JSONField(blank=True, db_comment='The period of time for the quota.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The list of tags associated with the service quota.', null=True)),
                ('usage_metric', models.JSONField(blank=True, db_comment='Information about the measurement.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_servicequotas_service_quota',
                'db_table_comment': 'AWS Service Quotas Service Quota',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsServicequotasServiceQuotaChangeRequest',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The unique identifier.', primary_key=True, serialize=False)),
                ('case_id', models.TextField(blank=True, db_comment='The case ID.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The state of the quota increase request.', null=True)),
                ('quota_name', models.TextField(blank=True, db_comment='The quota name.', null=True)),
                ('quota_code', models.TextField(blank=True, db_comment='The quota code.', null=True)),
                ('quota_arn', models.TextField(blank=True, db_comment='The arn of the service quota.', null=True)),
                ('desired_value', models.FloatField(blank=True, db_comment='The increased value for the quota.', null=True)),
                ('created', models.DateTimeField(blank=True, db_comment='The date and time when the quota increase request was received and the case ID was created.', null=True)),
                ('global_quota', models.BooleanField(blank=True, db_comment='Indicates whether the quota is global.', null=True)),
                ('last_updated', models.DateTimeField(blank=True, db_comment='The date and time of the most recent change.', null=True)),
                ('requester', models.TextField(blank=True, db_comment='The IAM identity of the requester.', null=True)),
                ('service_name', models.TextField(blank=True, db_comment='The service name.', null=True)),
                ('service_code', models.TextField(blank=True, db_comment='The service identifier.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The unit of measurement.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The list of tags associated with the change request.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_servicequotas_service_quota_change_request',
                'db_table_comment': 'AWS Service Quotas Service Quota Change Request',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSesDomainIdentity',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('identity', models.TextField(blank=True, db_comment='The domain identity.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the AWS SES identity.', null=True)),
                ('verification_status', models.TextField(blank=True, db_comment='The verification status of the identity.', null=True)),
                ('verification_token', models.TextField(blank=True, db_comment='The verification token for a domain identity.', null=True)),
                ('dkim_attributes', models.JSONField(blank=True, db_comment='The DKIM attributes for an email address or a domain.', null=True)),
                ('identity_mail_from_domain_attributes', models.JSONField(blank=True, db_comment='The custom MAIL FROM attributes for a list of identities.', null=True)),
                ('notification_attributes', models.JSONField(blank=True, db_comment='Represents the notification attributes of an identity.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ses_domain_identity',
                'db_table_comment': 'AWS SES Domain Identity',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSesEmailIdentity',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('identity', models.TextField(blank=True, db_comment='The email identity.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the AWS SES identity.', null=True)),
                ('verification_status', models.TextField(blank=True, db_comment='The verification status of the identity.', null=True)),
                ('verification_token', models.TextField(blank=True, db_comment='[DEPRECATED] This column has been deprecated and will be removed in a future release. The verification token for a domain identity.', null=True)),
                ('notification_attributes', models.JSONField(blank=True, db_comment='Represents the notification attributes of an identity.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ses_email_identity',
                'db_table_comment': 'AWS SES Email Identity',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSfnStateMachine',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the state machine.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that identifies the state machine.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current status of the state machine.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of the state machine.', null=True)),
                ('creation_date', models.DateTimeField(blank=True, db_comment='The date the state machine is created.', null=True)),
                ('definition', models.TextField(blank=True, db_comment='The Amazon States Language definition of the state machine.', null=True)),
                ('role_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the IAM role used when creating this state machine.', null=True)),
                ('logging_configuration', models.JSONField(blank=True, db_comment='The LoggingConfiguration data type is used to set CloudWatch Logs options.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The list of tags associated with the state machine.', null=True)),
                ('tracing_configuration', models.JSONField(blank=True, db_comment='Selects whether AWS X-Ray tracing is enabled.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_sfn_state_machine',
                'db_table_comment': 'AWS Step Functions State Machine',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSfnStateMachineExecution',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the execution.', null=True)),
                ('execution_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that identifies the execution.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current status of the execution.', null=True)),
                ('input', models.TextField(blank=True, db_comment='The string that contains the JSON input data of the execution.', null=True)),
                ('output', models.TextField(blank=True, db_comment='The JSON output data of the execution.', null=True)),
                ('start_date', models.DateTimeField(blank=True, db_comment='The date the execution started.', null=True)),
                ('state_machine_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the executed state machine.', null=True)),
                ('stop_date', models.DateTimeField(blank=True, db_comment='If the execution already ended, the date the execution stopped.', null=True)),
                ('trace_header', models.TextField(blank=True, db_comment='The AWS X-Ray trace header that was passed to the execution.', null=True)),
                ('input_details', models.JSONField(blank=True, db_comment='Provides details about execution input or output.', null=True)),
                ('output_details', models.JSONField(blank=True, db_comment='Provides details about execution input or output.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_sfn_state_machine_execution',
                'db_table_comment': 'AWS Step Functions State Machine Execution',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSfnStateMachineExecutionHistory',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The id of the event.', primary_key=True, serialize=False)),
                ('execution_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) that identifies the execution.', null=True)),
                ('previous_event_id', models.TextField(blank=True, db_comment='The id of the previous event.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The date and time the event occurred.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of the event.', null=True)),
                ('activity_failed_event_details', models.JSONField(blank=True, db_comment='Contains details about an activity that failed during an execution.', null=True)),
                ('activity_schedule_failed_event_details', models.JSONField(blank=True, db_comment='Contains details about an activity schedule event that failed during an execution.', null=True)),
                ('activity_scheduled_event_details', models.JSONField(blank=True, db_comment='Contains details about an activity scheduled during an execution.', null=True)),
                ('activity_started_event_details', models.JSONField(blank=True, db_comment='Contains details about the start of an activity during an execution.', null=True)),
                ('activity_succeeded_event_details', models.JSONField(blank=True, db_comment='Contains details about an activity that successfully terminated during an execution.', null=True)),
                ('activity_timed_out_event_details', models.JSONField(blank=True, db_comment='Contains details about an activity timeout that occurred during an execution.', null=True)),
                ('execution_aborted_event_details', models.JSONField(blank=True, db_comment='Contains details about an abort of an execution.', null=True)),
                ('execution_failed_event_details', models.JSONField(blank=True, db_comment='Contains details about an execution failure event.', null=True)),
                ('execution_started_event_details', models.JSONField(blank=True, db_comment='Contains details about the start of the execution.', null=True)),
                ('execution_succeeded_event_details', models.JSONField(blank=True, db_comment='Contains details about the successful termination of the execution.', null=True)),
                ('execution_timed_out_event_details', models.JSONField(blank=True, db_comment='Contains details about the execution timeout that occurred during the execution.', null=True)),
                ('lambda_function_failed_event_details', models.JSONField(blank=True, db_comment='Contains details about a lambda function that failed during an execution.', null=True)),
                ('lambda_function_schedule_failed_event_details', models.JSONField(blank=True, db_comment='Contains details about a failed lambda function schedule event that occurred during an execution.', null=True)),
                ('lambda_function_scheduled_event_details', models.JSONField(blank=True, db_comment='Contains details about a lambda function scheduled during an execution.', null=True)),
                ('lambda_function_start_failed_event_details', models.JSONField(blank=True, db_comment='Contains details about a lambda function that failed to start during an execution.', null=True)),
                ('lambda_function_succeeded_event_details', models.JSONField(blank=True, db_comment='Contains details about a lambda function that terminated successfully during an execution.', null=True)),
                ('lambda_function_timed_out_event_details', models.JSONField(blank=True, db_comment='Contains details about a lambda function timeout that occurred during an execution.', null=True)),
                ('map_iteration_aborted_event_details', models.JSONField(blank=True, db_comment='Contains details about an iteration of a Map state that was aborted.', null=True)),
                ('map_iteration_failed_event_details', models.JSONField(blank=True, db_comment='Contains details about an iteration of a Map state that failed.', null=True)),
                ('map_iteration_started_event_details', models.JSONField(blank=True, db_comment='Contains details about an iteration of a Map state that was started.', null=True)),
                ('map_iteration_succeeded_event_details', models.JSONField(blank=True, db_comment='Contains details about an iteration of a Map state that succeeded.', null=True)),
                ('map_state_started_event_details', models.JSONField(blank=True, db_comment='Contains details about Map state that was started.', null=True)),
                ('state_entered_event_details', models.JSONField(blank=True, db_comment='Contains details about a state entered during an execution.', null=True)),
                ('state_exited_event_details', models.JSONField(blank=True, db_comment='Contains details about an exit from a state during an execution.', null=True)),
                ('task_failed_event_details', models.JSONField(blank=True, db_comment='Contains details about the failure of a task.', null=True)),
                ('task_scheduled_event_details', models.JSONField(blank=True, db_comment='Contains details about a task that was scheduled.', null=True)),
                ('task_start_failed_event_details', models.JSONField(blank=True, db_comment='Contains details about a task that failed to start.', null=True)),
                ('task_started_event_details', models.JSONField(blank=True, db_comment='Contains details about a task that was started.', null=True)),
                ('task_submit_failed_event_details', models.JSONField(blank=True, db_comment='Contains details about a task that where the submit failed.', null=True)),
                ('task_submitted_event_details', models.JSONField(blank=True, db_comment='Contains details about a submitted task.', null=True)),
                ('task_succeeded_event_details', models.JSONField(blank=True, db_comment='Contains details about a task that succeeded.', null=True)),
                ('task_timed_out_event_details', models.JSONField(blank=True, db_comment='Contains details about a task that timed out.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_sfn_state_machine_execution_history',
                'db_table_comment': 'AWS Step Functions State Machine Execution History',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSimspaceweaverSimulation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the simulation.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the simulation.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The time when the simulation was created, expressed as the number of seconds and milliseconds in UTC since the Unix epoch (0:0:0.000, January 1, 1970).', null=True)),
                ('status', models.TextField(blank=True, db_comment='The current status of the simulation.', null=True)),
                ('execution_id', models.TextField(blank=True, db_comment='A universally unique identifier (UUID) for this simulation.', null=True)),
                ('maximum_duration', models.TextField(blank=True, db_comment='The maximum running time of the simulation, specified as a number of months (m or M), hours (h or H), or days (d or D).', null=True)),
                ('role_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that the simulation assumes to perform actions.', null=True)),
                ('schema_error', models.TextField(blank=True, db_comment='An error message that SimSpace Weaver returns only if there is a problem with the simulation schema.', null=True)),
                ('live_simulation_state', models.JSONField(blank=True, db_comment='A collection of additional state information, such as domain and clock configuration.', null=True)),
                ('logging_configuration', models.JSONField(blank=True, db_comment='Settings that control how SimSpace Weaver handles your simulation log data.', null=True)),
                ('schema_s3_location', models.JSONField(blank=True, db_comment='The location of the simulation schema in Amazon Simple Storage Service (Amazon S3).', null=True)),
                ('target_status', models.JSONField(blank=True, db_comment='The desired status of the simulation.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_simspaceweaver_simulation',
                'db_table_comment': 'AWS SimSpace Weaver Simulation',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSnsSubscription',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('subscription_arn', models.TextField(blank=True, db_comment='Amazon Resource Name of the subscription.', null=True)),
                ('topic_arn', models.TextField(blank=True, db_comment='The topic ARN that the subscription is associated with.', null=True)),
                ('owner', models.TextField(blank=True, db_comment="The AWS account ID of the subscription's owner.", null=True)),
                ('protocol', models.TextField(blank=True, db_comment="The subscription's protocol.", null=True)),
                ('endpoint', models.TextField(blank=True, db_comment="The subscription's endpoint (format depends on the protocol).", null=True)),
                ('confirmation_was_authenticated', models.BooleanField(blank=True, db_comment='Reflects authentication status of the subscription.', null=True)),
                ('pending_confirmation', models.BooleanField(blank=True, db_comment="Reflects the confirmation status of the subscription. True if the subscription hasn't been confirmed.", null=True)),
                ('raw_message_delivery', models.BooleanField(blank=True, db_comment='true if raw message delivery is enabled for the subscription.', null=True)),
                ('delivery_policy', models.JSONField(blank=True, db_comment="The JSON of the subscription's delivery policy.", null=True)),
                ('effective_delivery_policy', models.JSONField(blank=True, db_comment='The JSON of the effective delivery policy that takes into account the topic delivery policy and account system defaults.', null=True)),
                ('redrive_policy', models.JSONField(blank=True, db_comment="When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue. Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable) or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held in the dead-letter queue for further analysis or reprocessing.", null=True)),
                ('filter_policy', models.JSONField(blank=True, db_comment='The filter policy JSON that is assigned to the subscription.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_sns_subscription',
                'db_table_comment': 'AWS SNS Subscription',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSnsTopic',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('topic_arn', models.TextField(blank=True, db_comment='Amazon Resource Name (ARN) of the Topic.', null=True)),
                ('display_name', models.TextField(blank=True, db_comment='The human-readable name used in the From field for notifications to email and email-json endpoints.', null=True)),
                ('application_failure_feedback_role_arn', models.TextField(blank=True, db_comment='IAM role for failed deliveries of notification messages sent to topics with platform application endpoint.', null=True)),
                ('application_success_feedback_role_arn', models.TextField(blank=True, db_comment='IAM role for successful deliveries of notification messages sent to topics with platform application endpoint.', null=True)),
                ('application_success_feedback_sample_rate', models.TextField(blank=True, db_comment='Sample rate for successful deliveries of notification messages sent to topics with platform application endpoint.', null=True)),
                ('firehose_failure_feedback_role_arn', models.TextField(blank=True, db_comment='IAM role for failed deliveries of notification messages sent to topics with kinesis data firehose endpoint.', null=True)),
                ('firehose_success_feedback_role_arn', models.TextField(blank=True, db_comment='IAM role for successful deliveries of notification messages sent to topics with kinesis data firehose endpoint.', null=True)),
                ('firehose_success_feedback_sample_rate', models.TextField(blank=True, db_comment='Sample rate for successful deliveries of notification messages sent to topics with firehose endpoint.', null=True)),
                ('http_failure_feedback_role_arn', models.TextField(blank=True, db_comment='IAM role for failed deliveries of notification messages sent to topics with http endpoint.', null=True)),
                ('http_success_feedback_role_arn', models.TextField(blank=True, db_comment='IAM role for successful deliveries of notification messages sent to topics with http endpoint.', null=True)),
                ('http_success_feedback_sample_rate', models.TextField(blank=True, db_comment='Sample rate for successful deliveries of notification messages sent to topics with http endpoint.', null=True)),
                ('lambda_failure_feedback_role_arn', models.TextField(blank=True, db_comment='IAM role for failed deliveries of notification messages sent to topics with lambda endpoint.', null=True)),
                ('lambda_success_feedback_role_arn', models.TextField(blank=True, db_comment='IAM role for successful deliveries of notification messages sent to topics with lambda endpoint.', null=True)),
                ('lambda_success_feedback_sample_rate', models.TextField(blank=True, db_comment='Sample rate for successful deliveries of notification messages sent to topics with lambda endpoint.', null=True)),
                ('owner', models.TextField(blank=True, db_comment="The AWS account ID of the topic's owner.", null=True)),
                ('sqs_failure_feedback_role_arn', models.TextField(blank=True, db_comment='IAM role for failed deliveries of notification messages sent to topics with sqs endpoint.', null=True)),
                ('sqs_success_feedback_role_arn', models.TextField(blank=True, db_comment='IAM role for successful deliveries of notification messages sent to topics with sqs endpoint.', null=True)),
                ('sqs_success_feedback_sample_rate', models.TextField(blank=True, db_comment='Sample rate for successful deliveries of notification messages sent to topics with sqs endpoint.', null=True)),
                ('subscriptions_confirmed', models.BigIntegerField(blank=True, db_comment='The number of confirmed subscriptions for the topic.', null=True)),
                ('subscriptions_deleted', models.BigIntegerField(blank=True, db_comment='The number of deleted subscriptions for the topic.', null=True)),
                ('subscriptions_pending', models.BigIntegerField(blank=True, db_comment='The number of subscriptions pending confirmation for the topic.', null=True)),
                ('kms_master_key_id', models.TextField(blank=True, db_comment='The ID of an AWS-managed customer master key (CMK) for Amazon SNS or a custom CMK.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The list of tags associated with the topic.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment="The topic's access control policy (i.e. Resource IAM Policy).", null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the policy in a canonical form for easier searching.', null=True)),
                ('delivery_policy', models.JSONField(blank=True, db_comment="The JSON object of the topic's delivery policy.", null=True)),
                ('effective_delivery_policy', models.JSONField(blank=True, db_comment='The effective delivery policy, taking system defaults into account.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_sns_topic',
                'db_table_comment': 'AWS SNS Topic',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSnsTopicSubscription',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('subscription_arn', models.TextField(blank=True, db_comment='Amazon Resource Name of the subscription.', null=True)),
                ('topic_arn', models.TextField(blank=True, db_comment='The topic ARN that the subscription is associated with.', null=True)),
                ('owner', models.TextField(blank=True, db_comment="The AWS account ID of the subscription's owner.", null=True)),
                ('protocol', models.TextField(blank=True, db_comment="The subscription's protocol.", null=True)),
                ('endpoint', models.TextField(blank=True, db_comment="The subscription's endpoint (format depends on the protocol).", null=True)),
                ('confirmation_was_authenticated', models.BooleanField(blank=True, db_comment='Reflects authentication status of the subscription.', null=True)),
                ('pending_confirmation', models.BooleanField(blank=True, db_comment="Reflects the confirmation status of the subscription. True if the subscription hasn't been confirmed.", null=True)),
                ('raw_message_delivery', models.BooleanField(blank=True, db_comment='true if raw message delivery is enabled for the subscription.', null=True)),
                ('delivery_policy', models.JSONField(blank=True, db_comment="The JSON of the subscription's delivery policy.", null=True)),
                ('effective_delivery_policy', models.JSONField(blank=True, db_comment='The JSON of the effective delivery policy that takes into account the topic delivery policy and account system defaults.', null=True)),
                ('redrive_policy', models.JSONField(blank=True, db_comment="When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue. Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable) or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held in the dead-letter queue for further analysis or reprocessing.", null=True)),
                ('filter_policy', models.JSONField(blank=True, db_comment='The filter policy JSON that is assigned to the subscription.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_sns_topic_subscription',
                'db_table_comment': 'AWS SNS Topic Subscription',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSqsQueue',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('queue_url', models.TextField(blank=True, db_comment='The URL of the Amazon SQS queue.', null=True)),
                ('queue_arn', models.TextField(blank=True, db_comment='The Amazon resource name (ARN) of the queue.', null=True)),
                ('fifo_queue', models.BooleanField(blank=True, db_comment='Returns true if the queue is FIFO.', null=True)),
                ('fifo_throughput_limit', models.TextField(blank=True, db_comment='Specifies whether the FIFO queue throughput quota applies to the entire queue or per message group.', null=True)),
                ('delay_seconds', models.TextField(blank=True, db_comment='The default delay on the queue in seconds.', null=True)),
                ('max_message_size', models.TextField(blank=True, db_comment='The limit of how many bytes a message can contain before Amazon SQS rejects it.', null=True)),
                ('message_retention_seconds', models.TextField(blank=True, db_comment='The length of time, in seconds, for which Amazon SQS retains a message.', null=True)),
                ('receive_wait_time_seconds', models.TextField(blank=True, db_comment='The length of time, in seconds, for which the ReceiveMessage action waits for a message to arrive.', null=True)),
                ('sqs_managed_sse_enabled', models.BooleanField(blank=True, db_comment='Returns true if the queue is using SSE-SQS encryption with SQS-owned encryption keys.', null=True)),
                ('visibility_timeout_seconds', models.TextField(blank=True, db_comment='The visibility timeout for the queue in seconds.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='The resource IAM policy of the queue.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the policy in a canonical form for easier searching.', null=True)),
                ('redrive_policy', models.JSONField(blank=True, db_comment='The string that includes the parameters for the dead-letter queue functionality of the source queue as a JSON object.', null=True)),
                ('content_based_deduplication', models.TextField(blank=True, db_comment='Mentions whether content-based deduplication is enabled for the queue.', null=True)),
                ('deduplication_scope', models.TextField(blank=True, db_comment='Specifies whether message deduplication occurs at the message group or queue level.', null=True)),
                ('kms_master_key_id', models.TextField(blank=True, db_comment='The ID of an AWS-managed customer master key (CMK) for Amazon SQS or a custom CMK.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_sqs_queue',
                'db_table_comment': 'AWS SQS Queue',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSsmAssociation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('association_id', models.TextField(blank=True, db_comment='The ID created by the system when you create an association.', null=True)),
                ('association_name', models.TextField(blank=True, db_comment='The Name of association.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the association.', null=True)),
                ('document_name', models.TextField(blank=True, db_comment='The name of the Systems Manager document.', null=True)),
                ('date', models.DateTimeField(blank=True, db_comment='The date when the association was made.', null=True)),
                ('compliance_severity', models.TextField(blank=True, db_comment='A cron expression that specifies a schedule when the association runs.', null=True)),
                ('apply_only_at_cron_interval', models.BooleanField(blank=True, db_comment="By default, when you create a new associations, the system runs it immediately after it is created and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you create it. This parameter is not supported for rate expressions.", null=True)),
                ('association_version', models.TextField(blank=True, db_comment='The association version.', null=True)),
                ('automation_target_parameter_name', models.TextField(blank=True, db_comment='Specify the target for the association. This target is required for associations that use an Automation document and target resources by using rate controls.', null=True)),
                ('document_version', models.TextField(blank=True, db_comment='The version of the document used in the association.', null=True)),
                ('instance_id', models.TextField(blank=True, db_comment='The ID of the instance.', null=True)),
                ('last_execution_date', models.DateTimeField(blank=True, db_comment='The date on which the association was last run.', null=True)),
                ('last_successful_execution_date', models.DateTimeField(blank=True, db_comment='The last date on which the association was successfully run.', null=True)),
                ('last_update_association_date', models.DateTimeField(blank=True, db_comment='The date when the association was last updated.', null=True)),
                ('schedule_expression', models.TextField(blank=True, db_comment='A cron expression that specifies a schedule when the association runs.', null=True)),
                ('max_concurrency', models.TextField(blank=True, db_comment='The maximum number of targets allowed to run the association at the same time.', null=True)),
                ('max_errors', models.TextField(blank=True, db_comment='The number of errors that are allowed before the system stops sending requests to run the association on additional targets.', null=True)),
                ('sync_compliance', models.TextField(blank=True, db_comment='The mode for generating association compliance. You can specify AUTO or MANUAL.', null=True)),
                ('overview', models.JSONField(blank=True, db_comment='Information about the association.', null=True)),
                ('output_location', models.JSONField(blank=True, db_comment='An S3 bucket where you want to store the output details of the request.', null=True)),
                ('parameters', models.JSONField(blank=True, db_comment='A description of the parameters for a document.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of the association. Status can be: Pending, Success, or Failed.', null=True)),
                ('targets', models.JSONField(blank=True, db_comment='A cron expression that specifies a schedule when the association runs.', null=True)),
                ('target_locations', models.JSONField(blank=True, db_comment='The combination of AWS Regions and AWS accounts where you want to run the association.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ssm_association',
                'db_table_comment': 'AWS SSM Association',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSsmDocument',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the Systems Manager document.', null=True)),
                ('account_ids', models.JSONField(blank=True, db_comment='[DEPRECATED] The account IDs that have permission to use this document.The ID can be either an AWS account or All.', null=True)),
                ('account_sharing_info_list', models.JSONField(blank=True, db_comment='[DEPRECATED] A list of AWS accounts where the current document is shared and the version shared with each account.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the document.', null=True)),
                ('approved_version', models.TextField(blank=True, db_comment='The version of the document currently approved for use in the organization.', null=True)),
                ('attachments_information', models.JSONField(blank=True, db_comment='Details about the document attachments, including names, locations, sizes,and so on.', null=True)),
                ('author', models.TextField(blank=True, db_comment='The user in your organization who created the document.', null=True)),
                ('created_date', models.DateTimeField(blank=True, db_comment='The date when the document was created.', null=True)),
                ('default_version', models.TextField(blank=True, db_comment='The default version.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the document.', null=True)),
                ('document_format', models.TextField(blank=True, db_comment='The document format, either JSON or YAML.', null=True)),
                ('document_type', models.TextField(blank=True, db_comment='The type of document.', null=True)),
                ('document_version', models.TextField(blank=True, db_comment='The document version.', null=True)),
                ('hash', models.TextField(blank=True, db_comment='The Sha256 or Sha1 hash created by the system when the document was created.', null=True)),
                ('hash_type', models.TextField(blank=True, db_comment='The hash type of the document.', null=True)),
                ('latest_version', models.TextField(blank=True, db_comment='The latest version of the document.', null=True)),
                ('owner_type', models.TextField(blank=True, db_comment='The AWS user account type to filter the documents. Possible values: Self, Amazon, Public, Private, ThirdParty, All, Default.', null=True)),
                ('owner', models.TextField(blank=True, db_comment='The AWS user account that created the document.', null=True)),
                ('parameters', models.JSONField(blank=True, db_comment='A description of the parameters for a document.', null=True)),
                ('pending_review_version', models.TextField(blank=True, db_comment='The version of the document that is currently under review.', null=True)),
                ('platform_types', models.JSONField(blank=True, db_comment='The operating system platform.', null=True)),
                ('requires', models.JSONField(blank=True, db_comment='A list of SSM documents required by a document.', null=True)),
                ('review_information', models.JSONField(blank=True, db_comment='Details about the review of a document.', null=True)),
                ('review_status', models.TextField(blank=True, db_comment='The current status of the review.', null=True)),
                ('schema_version', models.TextField(blank=True, db_comment='The schema version.', null=True)),
                ('sha1', models.TextField(blank=True, db_comment='The SHA1 hash of the document, which you can use for verification.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The user in your organization who created the document.', null=True)),
                ('status_information', models.TextField(blank=True, db_comment='A message returned by AWS Systems Manager that explains the Status value.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with document', null=True)),
                ('target_type', models.TextField(blank=True, db_comment='The target type which defines the kinds of resources the document can run on.', null=True)),
                ('version_name', models.TextField(blank=True, db_comment='The version of the artifact associated with the document.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ssm_document',
                'db_table_comment': 'AWS SSM Document',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSsmincidentsResponsePlan',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the response plan.', null=True)),
                ('name', models.TextField(blank=True, db_comment='The name of the response plan.', null=True)),
                ('display_name', models.TextField(blank=True, db_comment='The human readable name of the response plan.', null=True)),
                ('incident_template', models.JSONField(blank=True, db_comment='Details used to create the incident when using this response plan.', null=True)),
                ('actions', models.JSONField(blank=True, db_comment='The actions that this response plan takes at the beginning of the incident.', null=True)),
                ('chat_channel', models.JSONField(blank=True, db_comment='The Chatbot chat channel used for collaboration during an incident.', null=True)),
                ('engagements', models.JSONField(blank=True, db_comment='The Amazon Resource Name (ARN) for the contacts and escalation plans that the response plan engages during an incident.', null=True)),
                ('integrations', models.JSONField(blank=True, db_comment='Information about third-party services integrated into the Incident Manager response plan.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ssmincidents_response_plan',
                'db_table_comment': 'AWS SSMIncidents Response Plan',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSsmInventory',
            fields=[
                ('id', models.TextField(blank=True, db_comment='ID of the inventory result entity.', primary_key=True, serialize=False)),
                ('type_name', models.TextField(blank=True, db_comment='The type of inventory item returned by the request.', null=True)),
                ('filter_key', models.TextField(blank=True, db_comment="The name of the filter key. Example: inventory filter key where managed node ID 'AWS:InstanceInformation.InstanceId'.", null=True)),
                ('filter_value', models.TextField(blank=True, db_comment="Inventory filter values. Example: inventory filter where managed node IDs are specified as values 'i-a12b3c4d5e6g'.", null=True)),
                ('component_attribute_key', models.TextField(blank=True, db_comment='The attribute key that are supported for type name AWS:AWSComponent, Possible values are: Name,ApplicationType,Publisher,Version,InstalledTime,Architecture and URL.', null=True)),
                ('component_attribute_value', models.TextField(blank=True, db_comment='The value for the component attribute key.', null=True)),
                ('application_attribute_key', models.TextField(blank=True, db_comment='The attribute key of the type name AWS:Application.', null=True)),
                ('application_attribute_value', models.TextField(blank=True, db_comment='The value for the attribute key of the type name AWS:Application.', null=True)),
                ('compliance_attribute_key', models.TextField(blank=True, db_comment='The attribute key of the type name AWS:ComplianceItem.', null=True)),
                ('compliance_attribute_value', models.TextField(blank=True, db_comment='The value for the attribute key of the type name AWS:ComplianceItem.', null=True)),
                ('file_attribute_key', models.TextField(blank=True, db_comment='The attribute key of the type name AWS:File.', null=True)),
                ('file_attribute_value', models.TextField(blank=True, db_comment='The value for the attribute key of the type name AWS:File.', null=True)),
                ('instance_detailed_information_attribute_key', models.TextField(blank=True, db_comment='The attribute key of the type name AWS:InstanceDetailedInformation.', null=True)),
                ('instance_detailed_information_attribute_value', models.TextField(blank=True, db_comment='The value for the attribute key of the type name AWS:InstanceDetailedInformation.', null=True)),
                ('instance_information_attribute_key', models.TextField(blank=True, db_comment='The attribute key of the type name AWS:InstanceInformation.', null=True)),
                ('instance_information_attribute_value', models.TextField(blank=True, db_comment='The value for the attribute key of the type name AWS:InstanceInformation.', null=True)),
                ('network_attribute_key', models.TextField(blank=True, db_comment='The attribute key of the type name AWS:Network.', null=True)),
                ('network_attribute_value', models.TextField(blank=True, db_comment='The value for the attribute key of the type name AWS:Network.', null=True)),
                ('windows_registry_attribute_key', models.TextField(blank=True, db_comment='The attribute key of the type name AWS:WindowsRegistry.', null=True)),
                ('windows_registry_attribute_value', models.TextField(blank=True, db_comment='The value for the attribute key of the type name AWS:WindowsRegistry.', null=True)),
                ('patch_compliance_attribute_key', models.TextField(blank=True, db_comment='The attribute key of the type name AWS:PatchCompliance.', null=True)),
                ('patch_compliance_attribute_value', models.TextField(blank=True, db_comment='The value for the attribute key of the type name AWS:PatchCompliance.', null=True)),
                ('patch_summary_attribute_key', models.TextField(blank=True, db_comment='The attribute key of the type name AWS:PatchSummary.', null=True)),
                ('patch_summary_attribute_value', models.TextField(blank=True, db_comment='The value for the attribute key of the type name AWS:PatchSummary.', null=True)),
                ('resource_group_attribute_key', models.TextField(blank=True, db_comment='The attribute key of the type name AWS:ResourceGroup.', null=True)),
                ('resource_group_attribute_value', models.TextField(blank=True, db_comment='The value for the attribute key of the type name AWS:ResourceGroup.', null=True)),
                ('service_attribute_key', models.TextField(blank=True, db_comment='The attribute key of the type name AWS:Service.', null=True)),
                ('service_attribute_value', models.TextField(blank=True, db_comment='The value for the attribute key of the type name AWS:Service.', null=True)),
                ('tag_attribute_key', models.TextField(blank=True, db_comment='The attribute key of the type name AWS:Tag.', null=True)),
                ('tag_attribute_value', models.TextField(blank=True, db_comment='The value for the attribute key of the type name AWS:Tag.', null=True)),
                ('windows_role_attribute_key', models.TextField(blank=True, db_comment='The attribute key of the type name AWS:WindowsRole.', null=True)),
                ('windows_role_attribute_value', models.TextField(blank=True, db_comment='The value for the attribute key of the type name AWS:WindowsRole.', null=True)),
                ('windows_update_attribute_key', models.TextField(blank=True, db_comment='The attribute key of the type name AWS:WindowsUpdate.', null=True)),
                ('windows_update_attribute_value', models.TextField(blank=True, db_comment='The value for the attribute key of the type name AWS:WindowsUpdate.', null=True)),
                ('capture_time', models.DateTimeField(blank=True, db_comment='The time that inventory information was collected for the managed node(s).', null=True)),
                ('schema_version', models.TextField(blank=True, db_comment='The inventory schema version used by the managed node(s).', null=True)),
                ('content', models.JSONField(blank=True, db_comment='Contains all the inventory data of the item type. Results include attribute names and values.', null=True)),
                ('schema', models.JSONField(blank=True, db_comment='The inventory item schema definition. Users can use this to compose inventory query filters.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ssm_inventory',
                'db_table_comment': 'AWS SSM Inventory',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSsmInventoryEntry',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('instance_id', models.TextField(blank=True, db_comment='The managed node ID targeted by the request to query inventory information.', null=True)),
                ('type_name', models.TextField(blank=True, db_comment='The type of inventory item returned by the request.', null=True)),
                ('capture_time', models.DateTimeField(blank=True, db_comment='The time that inventory information was collected for the managed node(s).', null=True)),
                ('schema_version', models.TextField(blank=True, db_comment='The inventory schema version used by the managed node(s).', null=True)),
                ('entries', models.JSONField(blank=True, db_comment='The inventory items on the managed node(s).', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ssm_inventory_entry',
                'db_table_comment': 'AWS SSM Inventory Entry',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSsmMaintenanceWindow',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the Maintenance Window.', null=True)),
                ('window_id', models.TextField(blank=True, db_comment='The ID of the Maintenance Window.', null=True)),
                ('enabled', models.BooleanField(blank=True, db_comment='Indicates whether the Maintenance Window is enabled.', null=True)),
                ('allow_unassociated_targets', models.BooleanField(blank=True, db_comment='Indicates whether targets must be registered with the Maintenance Window before tasks can be defined for those targets.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the Maintenance Window.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the Maintenance Window', null=True)),
                ('duration', models.BigIntegerField(blank=True, db_comment='The duration of the Maintenance Window in hours.', null=True)),
                ('cutoff', models.BigIntegerField(blank=True, db_comment='The number of hours before the end of the Maintenance Window that Systems Manager stops scheduling new tasks for execution.', null=True)),
                ('schedule', models.TextField(blank=True, db_comment='The schedule of the Maintenance Window in the form of a cron or rate expression.', null=True)),
                ('schedule_offset', models.BigIntegerField(blank=True, db_comment='The number of days to wait to run a Maintenance Window after the scheduled CRON expression date and time.', null=True)),
                ('targets', models.JSONField(blank=True, db_comment='The targets of Maintenance Window.', null=True)),
                ('tasks', models.JSONField(blank=True, db_comment='The Tasks of Maintenance Window.', null=True)),
                ('created_date', models.DateTimeField(blank=True, db_comment='The date the maintenance window was created.', null=True)),
                ('end_date', models.TextField(blank=True, db_comment='The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become inactive. The maintenance window will not run after this specified time.', null=True)),
                ('schedule_timezone', models.TextField(blank=True, db_comment='The schedule of the maintenance window in the form of a cron or rate expression.', null=True)),
                ('start_date', models.TextField(blank=True, db_comment='The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become active.', null=True)),
                ('modified_date', models.DateTimeField(blank=True, db_comment='The date the Maintenance Window was last modified.', null=True)),
                ('next_execution_time', models.TextField(blank=True, db_comment='The next time the maintenance window will actually run, taking into account any specified times for the Maintenance Window to become active or inactive.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ssm_maintenance_window',
                'db_table_comment': 'AWS SSM Maintenance Window',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSsmManagedInstance',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name assigned to an on-premises server or virtual machine (VM) when it is activated as a Systems Manager managed instance.', null=True)),
                ('instance_id', models.TextField(blank=True, db_comment='The ID of the instance.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the instance.', null=True)),
                ('resource_type', models.TextField(blank=True, db_comment='The type of instance. Instances are either EC2 instances or managed instances.', null=True)),
                ('ping_status', models.TextField(blank=True, db_comment='Connection status of SSM Agent.', null=True)),
                ('activation_id', models.TextField(blank=True, db_comment='The activation ID created by Systems Manager when the server or VM was registered.', null=True)),
                ('agent_version', models.TextField(blank=True, db_comment='The version of SSM Agent running on your Linux instance.', null=True)),
                ('association_status', models.TextField(blank=True, db_comment='The status of the association.', null=True)),
                ('computer_name', models.TextField(blank=True, db_comment='The fully qualified host name of the managed instance.', null=True)),
                ('ip_address', models.GenericIPAddressField(blank=True, db_comment='The IP address of the managed instance.', null=True)),
                ('is_latest_version', models.BooleanField(blank=True, db_comment='Indicates whether the latest version of SSM Agent is running on your Linux Managed Instance.', null=True)),
                ('last_association_execution_date', models.DateTimeField(blank=True, db_comment='The date the association was last run.', null=True)),
                ('last_ping_date_time', models.DateTimeField(blank=True, db_comment='The date and time when the agent last pinged the Systems Manager service.', null=True)),
                ('last_successful_association_execution_date', models.DateTimeField(blank=True, db_comment='The last date the association was successfully run.', null=True)),
                ('platform_name', models.TextField(blank=True, db_comment='The name of the operating system platform running on your instance.', null=True)),
                ('platform_type', models.TextField(blank=True, db_comment='The operating system platform type.', null=True)),
                ('platform_version', models.TextField(blank=True, db_comment='The version of the OS platform running on your instance.', null=True)),
                ('registration_date', models.DateTimeField(blank=True, db_comment='The date the server or VM was registered with AWS as a managed instance.', null=True)),
                ('association_overview', models.JSONField(blank=True, db_comment='Information about the association.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ssm_managed_instance',
                'db_table_comment': 'AWS SSM Managed Instance',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSsmManagedInstancePatchState',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('instance_id', models.TextField(blank=True, db_comment='The ID of the managed node the high-level patch compliance information was collected for.', null=True)),
                ('baseline_id', models.TextField(blank=True, db_comment='The ID of the patch baseline used to patch the managed node.', null=True)),
                ('operation', models.TextField(blank=True, db_comment='The type of patching operation that was performed.', null=True)),
                ('operation_end_time', models.DateTimeField(blank=True, db_comment='The time the most recent patching operation completed on the managed node.', null=True)),
                ('operation_start_time', models.DateTimeField(blank=True, db_comment='The time the most recent patching operation was started on the managed node.', null=True)),
                ('patch_group', models.TextField(blank=True, db_comment='The name of the patch group the managed node belongs to.', null=True)),
                ('critical_non_compliant_count', models.BigIntegerField(blank=True, db_comment="The number of patches per node that are specified as Critical for compliance reporting in the patch baseline aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is NON_COMPLIANT.", null=True)),
                ('failed_count', models.BigIntegerField(blank=True, db_comment='The number of patches from the patch baseline that were attempted to be installed during the last patching operation, but failed to install.', null=True)),
                ('installed_count', models.BigIntegerField(blank=True, db_comment='The number of patches from the patch baseline that are installed on the managed node.', null=True)),
                ('installed_other_count', models.BigIntegerField(blank=True, db_comment='The number of patches not specified in the patch baseline that are installed on the managed node.', null=True)),
                ('installed_pending_reboot_count', models.BigIntegerField(blank=True, db_comment='The number of patches installed by Patch Manager since the last time the managed node was rebooted.', null=True)),
                ('installed_rejected_count', models.BigIntegerField(blank=True, db_comment='The number of patches installed on a managed node that are specified in a RejectedPatches list. Patches with a status of InstalledRejected were typically installed before they were added to a RejectedPatches list.', null=True)),
                ('last_no_reboot_install_operation_time', models.DateTimeField(blank=True, db_comment='The time of the last attempt to patch the managed node with NoReboot specified as the reboot option.', null=True)),
                ('missing_count', models.BigIntegerField(blank=True, db_comment="The number of patches from the patch baseline that are applicable for the managed node but aren't currently installed.", null=True)),
                ('not_applicable_count', models.BigIntegerField(blank=True, db_comment="The number of patches from the patch baseline that aren't applicable for the managed node and therefore aren't installed on the node. This number may be truncated if the list of patch names is very large. The number of patches beyond this limit are reported in UnreportedNotApplicableCount.", null=True)),
                ('other_non_compliant_count', models.BigIntegerField(blank=True, db_comment="The number of patches per node that are specified as other than Critical or Security but aren't compliant with the patch baseline. The status of these managed nodes is NON_COMPLIANT.", null=True)),
                ('owner_information', models.TextField(blank=True, db_comment='Placeholder information. This field will always be empty in the current release of the service.', null=True)),
                ('reboot_option', models.TextField(blank=True, db_comment="Indicates the reboot option specified in the patch baseline. Reboot options apply to Install operations only. Reboots aren't attempted for Patch Manager Scan operations.", null=True)),
                ('security_non_compliant_count', models.BigIntegerField(blank=True, db_comment="The number of patches per node that are specified as Security in a patch advisory aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is NON_COMPLIANT.", null=True)),
                ('snapshot_id', models.TextField(blank=True, db_comment='The ID of the patch baseline snapshot used during the patching operation when this compliance data was collected.', null=True)),
                ('unreported_not_applicable_count', models.BigIntegerField(blank=True, db_comment="The number of patches beyond the supported limit of NotApplicableCount that aren't reported by name to Inventory. Inventory is a capability of Amazon Web Services Systems Manager.", null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ssm_managed_instance_patch_state',
                'db_table_comment': 'AWS SSM Managed Instance Patch State',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSsmParameter',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The parameter name.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of parameter. Valid parameter types include the following: String, StringList, and SecureString.', null=True)),
                ('value', models.TextField(blank=True, db_comment='The value of parameter.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the parameter.', null=True)),
                ('data_type', models.TextField(blank=True, db_comment='The data type of the parameter, such as text or aws:ec2:image. The default is text.', null=True)),
                ('key_id', models.TextField(blank=True, db_comment='The ID of the query key used for this parameter.', null=True)),
                ('last_modified_date', models.DateTimeField(blank=True, db_comment='Date the parameter was last changed or updated.', null=True)),
                ('last_modified_user', models.TextField(blank=True, db_comment='Amazon Resource Name (ARN) of the AWS user who last changed the parameter.', null=True)),
                ('version', models.BigIntegerField(blank=True, db_comment='The parameter version.', null=True)),
                ('selector', models.TextField(blank=True, db_comment='Either the version number or the label used to retrieve the parameter value.', null=True)),
                ('source_result', models.TextField(blank=True, db_comment='SourceResult is the raw result or response from the source. Applies to parameters that reference information in other AWS services.', null=True)),
                ('tier', models.TextField(blank=True, db_comment='The parameter tier.', null=True)),
                ('policies', models.JSONField(blank=True, db_comment='A list of policies associated with a parameter. Parameter policies help you manage a growing set of parameters by enabling you to assign specific criteria to a parameter such as an expiration date or time to live. Parameter policies are especially helpful in forcing you to update or delete passwords and configuration data stored in Parameter Store.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the parameter.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ssm_parameter',
                'db_table_comment': 'AWS SSM Parameter',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSsmPatchBaseline',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the patch baseline.', null=True)),
                ('baseline_id', models.TextField(blank=True, db_comment='The ID of the retrieved patch baseline.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the patch baseline.', null=True)),
                ('operating_system', models.TextField(blank=True, db_comment='Returns the operating system specified for the patch baseline.', null=True)),
                ('created_date', models.DateTimeField(blank=True, db_comment='The date the patch baseline was created.', null=True)),
                ('modified_date', models.DateTimeField(blank=True, db_comment='The date the patch baseline was last modified.', null=True)),
                ('approved_patches_compliance_level', models.TextField(blank=True, db_comment='Returns the specified compliance severity level for approved patches in the patch baseline.', null=True)),
                ('approved_patches_enable_non_security', models.BooleanField(blank=True, db_comment="Indicates whether the list of approved patches includes non-security updates that should be applied to the instances. The default value is 'false'. Applies to Linux instances only.", null=True)),
                ('approval_rules', models.JSONField(blank=True, db_comment='A set of rules used to include patches in the baseline.', null=True)),
                ('approved_patches', models.JSONField(blank=True, db_comment='A list of explicitly approved patches for the baseline.', null=True)),
                ('global_filters', models.JSONField(blank=True, db_comment='A set of global filters used to exclude patches from the baseline.', null=True)),
                ('patch_groups', models.JSONField(blank=True, db_comment='Patch groups included in the patch baseline.', null=True)),
                ('rejected_patches_action', models.TextField(blank=True, db_comment='The action specified to take on patches included in the RejectedPatches list. A patch can be allowed only if it is a dependency of another package, or blocked entirely along with packages that include it as a dependency.', null=True)),
                ('rejected_patches', models.JSONField(blank=True, db_comment='A list of explicitly rejected patches for the baseline.', null=True)),
                ('sources', models.JSONField(blank=True, db_comment='Information about the patches to use to update the instances, including target operating systems and source repositories. Applies to Linux instances only.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the patch baseline.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ssm_patch_baseline',
                'db_table_comment': 'AWS SSM Patch Baseline',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSsoadminInstance',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the SSO instance under which the operation will be executed.', null=True)),
                ('identity_store_id', models.TextField(blank=True, db_comment='The identifier of the identity store that is connected to the SSO instance.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ssoadmin_instance',
                'db_table_comment': 'AWS SSO Instance',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsSsoadminPermissionSet',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the permission set.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the permission set.', null=True)),
                ('created_date', models.DateTimeField(blank=True, db_comment='The date that the permission set was created.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the permission set.', null=True)),
                ('instance_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the SSO Instance under which the operation will be executed.', null=True)),
                ('relay_state', models.TextField(blank=True, db_comment='Used to redirect users within the application during the federation authentication process.', null=True)),
                ('session_duration', models.TextField(blank=True, db_comment='The length of time that the application user sessions are valid for in the ISO-8601 standard.', null=True)),
                ('tags_src', models.JSONField(blank=True, null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_ssoadmin_permission_set',
                'db_table_comment': 'AWS SSO Permission Set',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsStsCallerIdentity',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Web Services ARN associated with the calling entity.', null=True)),
                ('user_id', models.TextField(blank=True, db_comment='The unique identifier of the calling entity. The exact value depends on the type of entity that is making the call.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_sts_caller_identity',
                'db_table_comment': 'AWS STS Caller Identity',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsTaggingResource',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the resource.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the resource.', null=True)),
                ('compliance_status', models.BooleanField(blank=True, db_comment='Whether a resource is compliant with the effective tag policy.', null=True)),
                ('keys_with_noncompliant_values', models.JSONField(blank=True, db_comment='These are keys defined in the effective policy that are on the resource with either incorrect case treatment or noncompliant values.', null=True)),
                ('noncompliant_keys', models.JSONField(blank=True, db_comment='These tag keys on the resource are noncompliant with the effective tag policy.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the parameter.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_tagging_resource',
                'db_table_comment': 'AWS Tagging Resource',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsTransferServer',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the server.', null=True)),
                ('server_id', models.TextField(blank=True, db_comment='The system-assigned unique identifier for the server.', null=True)),
                ('domain', models.TextField(blank=True, db_comment='Specifies the domain of the storage system that is used for file transfers.', null=True)),
                ('identity_provider_type', models.TextField(blank=True, db_comment='The mode of authentication for a server.', null=True)),
                ('endpoint_type', models.TextField(blank=True, db_comment='Specifies the type of VPC endpoint that your server is connected to.', null=True)),
                ('logging_role', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The condition of the server that was described.', null=True)),
                ('user_count', models.BigIntegerField(blank=True, db_comment='Specifies the number of users that are assigned to a server.', null=True)),
                ('certificate', models.TextField(blank=True, db_comment='Specifies the ARN of the Amazon Web ServicesCertificate Manager (ACM) certificate.', null=True)),
                ('host_key_fingerprint', models.TextField(blank=True, db_comment="Specifies the Base64-encoded SHA256 fingerprint of the server's host key.", null=True)),
                ('pre_authentication_login_banner', models.TextField(blank=True, db_comment='Specifies a string to display when users connect to a server. This string is displayed before the user authenticates.', null=True)),
                ('post_authentication_login_banner', models.TextField(blank=True, db_comment='Specifies a string to display when users connect to a server. This string is displayed after the user authenticates.', null=True)),
                ('security_policy_name', models.TextField(blank=True, db_comment='Specifies the name of the security policy that is attached to the server.', null=True)),
                ('identity_provider_details', models.JSONField(blank=True, db_comment='Specifies information to call a customer-supplied authentication API.', null=True)),
                ('protocol_details', models.JSONField(blank=True, db_comment='The protocol settings that are configured for your server.', null=True)),
                ('endpoint_details', models.JSONField(blank=True, db_comment='The virtual private cloud (VPC) endpoint settings that are configured for your server.', null=True)),
                ('protocols', models.JSONField(blank=True, db_comment="Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint.", null=True)),
                ('workflow_details', models.JSONField(blank=True, db_comment="Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow.", null=True)),
                ('structured_log_destinations', models.JSONField(blank=True, db_comment='Specifies the log groups to which your server logs are sent.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_transfer_server',
                'db_table_comment': 'AWS Transfer Server',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsTransferUser',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the user.', null=True)),
                ('server_id', models.TextField(blank=True, db_comment='The ID of the server that the user is attached to.', null=True)),
                ('user_name', models.TextField(blank=True, db_comment='Specifies the name of the user whose ARN was specified. User names are used for authentication purposes.', null=True)),
                ('home_directory', models.TextField(blank=True, db_comment='Specifies the landing directory (folder) for a user when they log in to the server.', null=True)),
                ('home_directory_mappings', models.JSONField(blank=True, db_comment='The landing directory (folder) for a user when they log in to the server using the client.', null=True)),
                ('home_directory_type', models.TextField(blank=True, db_comment='The type of landing directory (folder) you mapped for your users to see when they log in to the server.', null=True)),
                ('role', models.TextField(blank=True, db_comment="The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system.", null=True)),
                ('ssh_public_key_count', models.BigIntegerField(blank=True, db_comment='The number of SSH public keys stored for the user on the server.', null=True)),
                ('ssh_public_keys', models.JSONField(blank=True, db_comment='The public SSH keys stored for the user on the server.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_transfer_user',
                'db_table_comment': 'AWS Transfer User',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpc',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('vpc_id', models.TextField(blank=True, db_comment='The ID of the VPC.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the vpc.', null=True)),
                ('cidr_block', models.TextField(blank=True, db_comment='The primary IPv4 CIDR block for the VPC.', null=True)),
                ('state', models.TextField(blank=True, db_comment='Contains the current state of the VPC.', null=True)),
                ('is_default', models.BooleanField(blank=True, db_comment='Indicates whether the VPC is the default VPC.', null=True)),
                ('dhcp_options_id', models.TextField(blank=True, db_comment='Contains the ID of the set of DHCP options, associated with the VPC.', null=True)),
                ('instance_tenancy', models.TextField(blank=True, db_comment='The allowed tenancy of instances launched into the VPC.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='Contains ID of the AWS account that owns the VPC.', null=True)),
                ('cidr_block_association_set', models.JSONField(blank=True, db_comment='Information about the IPv4 CIDR blocks associated with the VPC.', null=True)),
                ('ipv6_cidr_block_association_set', models.JSONField(blank=True, db_comment='Information about the IPv6 CIDR blocks associated with the VPC.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are attached with the VPC.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc',
                'db_table_comment': 'AWS VPC',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcCustomerGateway',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('customer_gateway_id', models.TextField(blank=True, db_comment='The ID of the customer gateway.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of VPN connection the customer gateway supports (ipsec.1).', null=True)),
                ('state', models.TextField(blank=True, db_comment='The current state of the customer gateway (pending | available | deleting | deleted).', null=True)),
                ('bgp_asn', models.TextField(blank=True, db_comment="The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).", null=True)),
                ('certificate_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) for the customer gateway certificate.', null=True)),
                ('device_name', models.TextField(blank=True, db_comment='The name of customer gateway device.', null=True)),
                ('ip_address', models.GenericIPAddressField(blank=True, db_comment="The Internet-routable IP address of the customer gateway's outside interface.", null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are attached to customer gateway.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_customer_gateway',
                'db_table_comment': 'AWS VPC Customer Gateway',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcDhcpOptions',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('dhcp_options_id', models.TextField(blank=True, db_comment='The ID of the set of DHCP options.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='The ID of the AWS account that owns the DHCP options set.', null=True)),
                ('domain_name', models.JSONField(blank=True, db_comment='The domain name for instances. This value is used to complete unqualified DNS hostnames.', null=True)),
                ('domain_name_servers', models.JSONField(blank=True, db_comment='The IP addresses of up to four domain name servers, or AmazonProvidedDNS.', null=True)),
                ('netbios_name_servers', models.JSONField(blank=True, db_comment='The IP addresses of up to four NetBIOS name servers.', null=True)),
                ('netbios_node_type', models.JSONField(blank=True, db_comment='The NetBIOS node type (1, 2, 4, or 8).', null=True)),
                ('ntp_servers', models.JSONField(blank=True, db_comment='The IP addresses of up to four Network Time Protocol (NTP) servers.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are attached to vpc dhcp options.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_dhcp_options',
                'db_table_comment': 'AWS VPC DHCP Options',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcEgressOnlyInternetGateway',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The ID of the egress-only internet gateway.', primary_key=True, serialize=False)),
                ('attachments', models.JSONField(blank=True, db_comment='Information about the attachment of the egress-only internet gateway.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are attached to egress only internet gateway.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_egress_only_internet_gateway',
                'db_table_comment': 'AWS VPC Egress Only Internet Gateway',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcEip',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('allocation_id', models.TextField(blank=True, db_comment='Contains the ID representing the allocation of the address for use with EC2-VPC.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the VPC EIP.', null=True)),
                ('public_ip', models.GenericIPAddressField(blank=True, db_comment='Contains the Elastic IP address.', null=True)),
                ('public_ipv4_pool', models.TextField(blank=True, db_comment='The ID of an address pool.', null=True)),
                ('domain', models.TextField(blank=True, db_comment='Indicates whether Elastic IP address is for use with instances in EC2-Classic (standard) or instances in a VPC (vpc).', null=True)),
                ('association_id', models.TextField(blank=True, db_comment='Contains the ID representing the association of the address with an instance in a VPC.', null=True)),
                ('carrier_ip', models.TextField(blank=True, db_comment='The carrier IP address associated. This option is only available for network interfaces which reside in a subnet in a Wavelength Zone (for example an EC2 instance).', null=True)),
                ('customer_owned_ip', models.GenericIPAddressField(blank=True, db_comment='The customer-owned IP address.', null=True)),
                ('customer_owned_ipv4_pool', models.TextField(blank=True, db_comment='The ID of the customer-owned address pool.', null=True)),
                ('instance_id', models.TextField(blank=True, db_comment='Contains the ID of the instance that the address is associated with.', null=True)),
                ('network_border_group', models.TextField(blank=True, db_comment='The name of the unique set of Availability Zones, Local Zones, or Wavelength Zones from which AWS advertises IP addresses.', null=True)),
                ('network_interface_id', models.TextField(blank=True, db_comment='The ID of the network interface.', null=True)),
                ('network_interface_owner_id', models.TextField(blank=True, db_comment='The ID of the AWS account that owns the network interface.', null=True)),
                ('private_ip_address', models.GenericIPAddressField(blank=True, db_comment='The private IP address associated with the Elastic IP address.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are attached to the vpc.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_eip',
                'db_table_comment': 'AWS VPC Elastic IP',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcEipAddressTransfer',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('allocation_id', models.TextField(blank=True, db_comment='The allocation ID of an Elastic IP address.', null=True)),
                ('address_transfer_status', models.TextField(blank=True, db_comment='The Elastic IP address transfer status.', null=True)),
                ('public_ip', models.TextField(blank=True, db_comment='The Elastic IP address being transferred.', null=True)),
                ('transfer_account_id', models.TextField(blank=True, db_comment='The ID of the account that you want to transfer the Elastic IP address to.', null=True)),
                ('transfer_offer_accepted_timestamp', models.DateTimeField(blank=True, db_comment='The timestamp when the Elastic IP address transfer was accepted.', null=True)),
                ('transfer_offer_expiration_timestamp', models.DateTimeField(blank=True, db_comment='The timestamp when the Elastic IP address transfer expired.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_eip_address_transfer',
                'db_table_comment': 'AWS VPC Elastic IP Address Transfer',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcEndpoint',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('vpc_endpoint_id', models.TextField(blank=True, db_comment='The ID of the VPC endpoint.', null=True)),
                ('service_name', models.TextField(blank=True, db_comment='The name of the service to which the endpoint is associated.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='The ID of the AWS account that owns the VPC endpoint.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The ID of the VPC to which the endpoint is associated.', null=True)),
                ('vpc_endpoint_type', models.TextField(blank=True, db_comment='The type of endpoint.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The state of the VPC endpoint.', null=True)),
                ('private_dns_enabled', models.BooleanField(blank=True, db_comment='Indicates whether the VPC is associated with a private hosted zone.', null=True)),
                ('requester_managed', models.BooleanField(blank=True, db_comment='Indicates whether the VPC endpoint is being managed by its service.', null=True)),
                ('policy', models.JSONField(blank=True, db_comment='The policy document associated with the endpoint, if applicable.', null=True)),
                ('policy_std', models.JSONField(blank=True, db_comment='Contains the policy in a canonical form for easier searching.', null=True)),
                ('subnet_ids', models.JSONField(blank=True, db_comment='One or more subnets in which the endpoint is located.', null=True)),
                ('route_table_ids', models.JSONField(blank=True, db_comment='One or more route tables associated with the endpoint.', null=True)),
                ('groups', models.JSONField(blank=True, db_comment='Information about the security groups that are associated with the network interface.', null=True)),
                ('network_interface_ids', models.JSONField(blank=True, db_comment='One or more network interfaces for the endpoint.', null=True)),
                ('dns_entries', models.JSONField(blank=True, db_comment='The DNS entries for the endpoint.', null=True)),
                ('creation_timestamp', models.DateTimeField(blank=True, db_comment='The date and time that the VPC endpoint was created.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the VPC endpoint.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_endpoint',
                'db_table_comment': 'AWS VPC Endpoint',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcEndpointService',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('service_name', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the service.', null=True)),
                ('service_id', models.TextField(blank=True, db_comment='The ID of the endpoint service.', null=True)),
                ('owner', models.TextField(blank=True, db_comment='The AWS account ID of the service owner.', null=True)),
                ('acceptance_required', models.BooleanField(blank=True, db_comment='Indicates whether VPC endpoint connection requests to the service must be accepted by the service owner.', null=True)),
                ('manages_vpc_endpoints', models.BooleanField(blank=True, db_comment='Indicates whether the service manages its VPC endpoints. Management of the service VPC endpoints using the VPC endpoint API is restricted.', null=True)),
                ('private_dns_name', models.TextField(blank=True, db_comment='The private DNS name for the service.', null=True)),
                ('private_dns_name_verification_state', models.TextField(blank=True, db_comment='The verification state of the VPC endpoint service. Consumers of the endpoint service cannot use the private name when the state is not verified.', null=True)),
                ('vpc_endpoint_policy_supported', models.BooleanField(blank=True, db_comment='Indicates whether the service supports endpoint policies.', null=True)),
                ('availability_zones', models.JSONField(blank=True, db_comment='The Availability Zones in which the service is available.', null=True)),
                ('base_endpoint_dns_names', models.JSONField(blank=True, db_comment='The DNS names for the service.', null=True)),
                ('service_type', models.JSONField(blank=True, db_comment='The type of service.', null=True)),
                ('vpc_endpoint_connections', models.JSONField(blank=True, db_comment='Information about one or more VPC endpoint connections.', null=True)),
                ('vpc_endpoint_service_permissions', models.JSONField(blank=True, db_comment='Information about one or more allowed principals.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the service.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_endpoint_service',
                'db_table_comment': 'AWS VPC Endpoint Service',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcFlowLog',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('flow_log_id', models.TextField(blank=True, db_comment='The ID of the flow log.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The date and time the flow log was created.', null=True)),
                ('deliver_logs_error_message', models.TextField(blank=True, db_comment='Information about the error that occurred.', null=True)),
                ('deliver_logs_permission_arn', models.TextField(blank=True, db_comment='The ARN of the IAM role that posts logs to CloudWatch Logs.', null=True)),
                ('deliver_logs_status', models.TextField(blank=True, db_comment='The status of the logs delivery (SUCCESS | FAILED).', null=True)),
                ('flow_log_status', models.TextField(blank=True, db_comment='The status of the flow log (ACTIVE).', null=True)),
                ('log_group_name', models.TextField(blank=True, db_comment='The name of the flow log group.', null=True)),
                ('resource_id', models.TextField(blank=True, db_comment='The ID of the VPC, subnet, or network interface.', null=True)),
                ('traffic_type', models.TextField(blank=True, db_comment="The type of traffic. Valid values are: 'ACCEPT', 'REJECT',  'ALL'.", null=True)),
                ('log_destination_type', models.TextField(blank=True, db_comment='Specifies the type of destination to which the flow log data is published.', null=True)),
                ('log_destination', models.TextField(blank=True, db_comment='Specifies the destination to which the flow log data is published.', null=True)),
                ('bucket_name', models.TextField(blank=True, db_comment='The name of the destination bucket to which the flow log data is published.', null=True)),
                ('log_format', models.TextField(blank=True, db_comment='The format of the flow log record.', null=True)),
                ('max_aggregation_interval', models.BigIntegerField(blank=True, db_comment='The maximum interval of time, in seconds, during which a flow of packets is captured and aggregated into a flow log record.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the VPC flowlog.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_flow_log',
                'db_table_comment': 'AWS VPC Flowlog',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcInternetGateway',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('internet_gateway_id', models.TextField(blank=True, db_comment='The ID of the internet gateway.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='The ID of the AWS account that owns the internet gateway.', null=True)),
                ('attachments', models.JSONField(blank=True, db_comment='Any VPCs attached to the internet gateway.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='tags assigned to the internet gateway.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_internet_gateway',
                'db_table_comment': 'AWS VPC Internet Gateway',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcNatGateway',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nat_gateway_id', models.TextField(blank=True, db_comment='The ID of the NAT gateway.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the NAT gateway.', null=True)),
                ('nat_gateway_addresses', models.JSONField(blank=True, db_comment='Information about the IP addresses and network interface associated with the NAT gateway.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The current state of the NAT gateway (pending | failed | available | deleting | deleted).', null=True)),
                ('create_time', models.DateTimeField(blank=True, db_comment='The date and time the NAT gateway was created.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The ID of the VPC in which the NAT gateway is located.', null=True)),
                ('subnet_id', models.TextField(blank=True, db_comment='The ID of the subnet in which the NAT gateway is located.', null=True)),
                ('delete_time', models.DateTimeField(blank=True, db_comment='The date and time the NAT gateway was deleted, if applicable.', null=True)),
                ('failure_code', models.TextField(blank=True, db_comment='If the NAT gateway could not be created, specifies the error code for the failure. (InsufficientFreeAddressesInSubnet | Gateway.NotAttached | InvalidAllocationID.NotFound | Resource.AlreadyAssociated | InternalError | InvalidSubnetID.NotFound).', null=True)),
                ('failure_message', models.TextField(blank=True, db_comment='If the NAT gateway could not be created, specifies the error message for the failure.', null=True)),
                ('provisioned_bandwidth', models.JSONField(blank=True, db_comment='Reserved. If you need to sustain traffic greater than the documented limits (https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html).', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are attached to NAT gateway.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_nat_gateway',
                'db_table_comment': 'AWS VPC Network Address Translation Gateway',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcNatGatewayMetricBytesOutToDestination',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nat_gateway_id', models.TextField(blank=True, db_comment='The ID of the NAT gateway.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric.', null=True)),
                ('namespace', models.TextField(blank=True, db_comment='The metric namespace.', null=True)),
                ('average', models.FloatField(blank=True, db_comment='The average of the metric values that correspond to the data point.', null=True)),
                ('maximum', models.FloatField(blank=True, db_comment='The maximum metric value for the data point.', null=True)),
                ('minimum', models.FloatField(blank=True, db_comment='The minimum metric value for the data point.', null=True)),
                ('sample_count', models.FloatField(blank=True, db_comment='The number of metric values that contributed to the aggregate value of this data point.', null=True)),
                ('sum', models.FloatField(blank=True, db_comment='The sum of the metric values for the data point.', null=True)),
                ('unit', models.TextField(blank=True, db_comment='The standard unit for the data point.', null=True)),
                ('timestamp', models.DateTimeField(blank=True, db_comment='The time stamp used for the data point.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_nat_gateway_metric_bytes_out_to_destination',
                'db_table_comment': 'AWS VPC Nat Gateway Cloudwatch Metrics - BytesOutToDestination',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcNetworkAcl',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('network_acl_id', models.TextField(blank=True, db_comment='The ID of the network ACL.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the network ACL.', null=True)),
                ('is_default', models.BooleanField(blank=True, db_comment='Indicates whether this is the default network ACL for the VPC.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The ID of the VPC for the network ACL.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='The ID of the AWS account that owns the network ACL.', null=True)),
                ('associations', models.JSONField(blank=True, db_comment='Any associations between the network ACL and one or more subnets.', null=True)),
                ('entries', models.JSONField(blank=True, db_comment='One or more entries (rules) in the network ACL.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are attached to Network ACL.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_network_acl',
                'db_table_comment': 'AWS VPC Network ACL',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcPeeringConnection',
            fields=[
                ('id', models.TextField(blank=True, db_comment='The ID of the VPC peering connection.', primary_key=True, serialize=False)),
                ('status_code', models.TextField(blank=True, db_comment="The status of the VPC peering connection. Possible values include: 'pending-acceptance', 'failed', 'expired', 'provisioning', 'active', 'deleting', 'deleted' or 'rejected'.", null=True)),
                ('accepter_cidr_block', models.TextField(blank=True, db_comment='The IPv4 CIDR block for the accepter VPC.', null=True)),
                ('accepter_owner_id', models.TextField(blank=True, db_comment='The ID of the Amazon Web Services account that owns the accepter VPC.', null=True)),
                ('accepter_region', models.TextField(blank=True, db_comment='The Region in which the accepter VPC is located.', null=True)),
                ('accepter_vpc_id', models.TextField(blank=True, db_comment='The ID of the accepter VPC.', null=True)),
                ('expiration_time', models.DateTimeField(blank=True, db_comment='The time that an unaccepted VPC peering connection will expire.', null=True)),
                ('requester_cidr_block', models.TextField(blank=True, db_comment='The IPv4 CIDR block for the requester VPC.', null=True)),
                ('requester_owner_id', models.TextField(blank=True, db_comment='The ID of the Amazon Web Services account that owns the requester VPC.', null=True)),
                ('requester_region', models.TextField(blank=True, db_comment='The Region in which the requester VPC is located.', null=True)),
                ('requester_vpc_id', models.TextField(blank=True, db_comment='The ID of the requester VPC.', null=True)),
                ('status_message', models.TextField(blank=True, db_comment='A message that provides more information about the status, if applicable.', null=True)),
                ('accepter_cidr_block_set', models.JSONField(blank=True, db_comment='Information about the IPv4 CIDR blocks for the accepter VPC.', null=True)),
                ('accepter_ipv6_cidr_block_set', models.JSONField(blank=True, db_comment='The IPv6 CIDR block for the accepter VPC.', null=True)),
                ('accepter_peering_options', models.JSONField(blank=True, db_comment='Information about the VPC peering connection options for the accepter VPC.', null=True)),
                ('requester_cidr_block_set', models.JSONField(blank=True, db_comment='Information about the IPv4 CIDR blocks for the requester VPC.', null=True)),
                ('requester_ipv6_cidr_block_set', models.JSONField(blank=True, db_comment='The IPv6 CIDR block for the requester VPC.', null=True)),
                ('requester_peering_options', models.JSONField(blank=True, db_comment='Information about the VPC peering connection options for the requester VPC.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The tags assigned to the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_peering_connection',
                'db_table_comment': 'AWS VPC Peering Connection',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcRoute',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('route_table_id', models.TextField(blank=True, db_comment='The ID of the route table containing the route.', null=True)),
                ('state', models.TextField(blank=True, db_comment="The state of the route. The blackhole state indicates that the route's target isn't available (for example, the specified gateway isn't attached to the VPC, or the specified NAT instance has been terminated).", null=True)),
                ('destination_cidr_block', models.TextField(blank=True, db_comment='The IPv4 CIDR block used for the destination match.', null=True)),
                ('destination_ipv6_cidr_block', models.TextField(blank=True, db_comment='The IPv6 CIDR block used for the destination match.', null=True)),
                ('carrier_gateway_id', models.TextField(blank=True, db_comment='The ID of the carrier gateway.', null=True)),
                ('destination_prefix_list_id', models.TextField(blank=True, db_comment='The prefix of the AWS service.', null=True)),
                ('egress_only_internet_gateway_id', models.TextField(blank=True, db_comment='The ID of the egress-only internet gateway.', null=True)),
                ('gateway_id', models.TextField(blank=True, db_comment='The ID of a gateway attached to your VPC.', null=True)),
                ('instance_id', models.TextField(blank=True, db_comment='The ID of a NAT instance in your VPC.', null=True)),
                ('instance_owner_id', models.TextField(blank=True, db_comment='The AWS account ID of the owner of the instance.', null=True)),
                ('local_gateway_id', models.TextField(blank=True, db_comment='The ID of the local gateway.', null=True)),
                ('nat_gateway_id', models.TextField(blank=True, db_comment='The ID of a NAT gateway.', null=True)),
                ('network_interface_id', models.TextField(blank=True, db_comment='The ID of the network interface.', null=True)),
                ('transit_gateway_id', models.TextField(blank=True, db_comment='The ID of a transit gateway.', null=True)),
                ('vpc_peering_connection_id', models.TextField(blank=True, db_comment='The ID of a VPC peering connection.', null=True)),
                ('origin', models.TextField(blank=True, db_comment='Describes how the route was created. CreateRouteTable - The route was automatically created when the route table was created. CreateRoute - The route was manually added to the route table. EnableVgwRoutePropagation - The route was propagated by route propagation.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_route',
                'db_table_comment': 'AWS VPC Route',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcRouteTable',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('route_table_id', models.TextField(blank=True, db_comment='Contains the ID of the route table.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The ID of the VPC.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='The ID of the AWS account that owns the route table.', null=True)),
                ('associations', models.JSONField(blank=True, db_comment='Contains the associations between the route table and one or more subnets or a gateway.', null=True)),
                ('routes', models.JSONField(blank=True, db_comment='A list of routes in the route table.', null=True)),
                ('propagating_vgws', models.JSONField(blank=True, db_comment='A list of virtual private gateway (VGW) propagating routes.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are attached to the route table.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_route_table',
                'db_table_comment': 'AWS VPC Route table',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcSecurityGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('group_name', models.TextField(blank=True, db_comment='The friendly name that identifies the security group.', null=True)),
                ('group_id', models.TextField(blank=True, db_comment='Contains the unique ID to identify a security group.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the security group.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the security group.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='The ID of the VPC for the security group.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='Contains the AWS account ID of the owner of the security group.', null=True)),
                ('ip_permissions', models.JSONField(blank=True, db_comment='A list of inbound rules associated with the security group', null=True)),
                ('ip_permissions_egress', models.JSONField(blank=True, db_comment='A list of outbound rules associated with the security group', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are attached to the security group', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_security_group',
                'db_table_comment': 'AWS VPC Security Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcSecurityGroupRule',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('security_group_rule_id', models.TextField(blank=True, db_comment='The ID of the security group rule.', null=True)),
                ('group_name', models.TextField(blank=True, db_comment='[DEPRECATED] This column has been deprecated and will be removed in a future release. The name of the security group to which rule belongs.', null=True)),
                ('group_id', models.TextField(blank=True, db_comment='The ID of the security group to which rule belongs.', null=True)),
                ('is_egress', models.BooleanField(blank=True, db_comment='Indicates whether the security group rule is an outbound rule.', null=True)),
                ('type', models.TextField(blank=True, db_comment='Type of the rule ( ingress | egress).', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='[DEPRECATED] This column has been deprecated and will be removed in a future release. The ID of the VPC for the security group.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='[DEPRECATED] This column has been deprecated and will be removed in a future release, use group_owner_id instead. The AWS account ID of the owner of the security group to which rule belongs.', null=True)),
                ('group_owner_id', models.TextField(blank=True, db_comment='The ID of the Amazon Web Services account that owns the security group.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The security group rule description.', null=True)),
                ('ip_protocol', models.TextField(blank=True, db_comment='The IP protocol name (tcp, udp, icmp, icmpv6) or number [see Protocol Numbers ](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). Use -1 to specify all protocols. When authorizing security group rules, specifying -1 or a protocol number other than tcp, udp, icmp, or icmpv6 allows traffic on all ports, regardless of any port range specified. For tcp, udp, and icmp, a port range is specified. For icmpv6, the port range is optional. If port range is omitted, traffic for all types and codes is allowed.', null=True)),
                ('from_port', models.BigIntegerField(blank=True, db_comment='The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of -1 indicates all ICMP/ICMPv6 types.', null=True)),
                ('to_port', models.BigIntegerField(blank=True, db_comment='The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of -1 indicates all ICMP/ICMPv6 codes.', null=True)),
                ('cidr_ip', models.TextField(blank=True, db_comment='[DEPRECATED] This column has been deprecated and will be removed in a future release, use cidr_ipv4 instead. The IPv4 CIDR range.', null=True)),
                ('cidr_ipv4', models.TextField(blank=True, db_comment='The IPv4 CIDR range.', null=True)),
                ('cidr_ipv6', models.TextField(blank=True, db_comment='The IPv6 CIDR range.', null=True)),
                ('pair_group_id', models.TextField(blank=True, db_comment='[DEPRECATED] This column has been deprecated and will be removed in a future release, use referenced_group_id instead. The ID of the referenced security group.', null=True)),
                ('referenced_group_id', models.TextField(blank=True, db_comment='The ID of the referenced security group.', null=True)),
                ('pair_group_name', models.TextField(blank=True, db_comment='[DEPRECATED] This column has been deprecated and will be removed in a future release. The name of the referenced security group.', null=True)),
                ('pair_peering_status', models.TextField(blank=True, db_comment='[DEPRECATED] This column has been deprecated and will be removed in a future release, use referenced_peering_status instead. Please use the referenced_peering_status column instead. The status of a VPC peering connection, if applicable.', null=True)),
                ('referenced_peering_status', models.TextField(blank=True, db_comment='The status of a VPC peering connection, if applicable.', null=True)),
                ('pair_user_id', models.TextField(blank=True, db_comment='[DEPRECATED] This column has been deprecated and will be removed in a future release, use referenced_user_id instead. The ID of an AWS account. For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned.', null=True)),
                ('referenced_user_id', models.TextField(blank=True, db_comment='The ID of an AWS account. For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned.', null=True)),
                ('pair_vpc_id', models.TextField(blank=True, db_comment='[DEPRECATED] This column has been deprecated and will be removed in a future release, use referenced_vpc_id instead. The ID of the VPC for the referenced security group, if applicable.', null=True)),
                ('referenced_vpc_id', models.TextField(blank=True, db_comment='The ID of the VPC for the referenced security group, if applicable.', null=True)),
                ('pair_vpc_peering_connection_id', models.TextField(blank=True, db_comment='[DEPRECATED] This column has been deprecated and will be removed in a future release, use referenced_vpc_peering_connection_id instead. The ID of the VPC peering connection, if applicable.', null=True)),
                ('referenced_vpc_peering_connection_id', models.TextField(blank=True, db_comment='The ID of the VPC peering connection, if applicable.', null=True)),
                ('prefix_list_id', models.TextField(blank=True, db_comment='The ID of the prefix list.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_security_group_rule',
                'db_table_comment': 'AWS VPC Security Group Rule',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcSubnet',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('subnet_id', models.TextField(blank=True, db_comment='Contains the unique ID to specify a subnet.', null=True)),
                ('subnet_arn', models.TextField(blank=True, db_comment='Contains the Amazon Resource Name (ARN) of the subnet.', null=True)),
                ('vpc_id', models.TextField(blank=True, db_comment='ID of the VPC, the subnet is in.', null=True)),
                ('cidr_block', models.TextField(blank=True, db_comment='Contains the IPv4 CIDR block assigned to the subnet.', null=True)),
                ('state', models.TextField(blank=True, db_comment='Current state of the subnet.', null=True)),
                ('owner_id', models.TextField(blank=True, db_comment='Contains the AWS account that own the subnet.', null=True)),
                ('assign_ipv6_address_on_creation', models.BooleanField(blank=True, db_comment='Indicates whether a network interface created in this subnet (including a network interface created by RunInstances) receives an IPv6 address.', null=True)),
                ('available_ip_address_count', models.BigIntegerField(blank=True, db_comment='The number of unused private IPv4 addresses in the subnet. The IPv4 addresses for any stopped instances are considered unavailable.', null=True)),
                ('availability_zone', models.TextField(blank=True, db_comment='The Availability Zone of the subnet.', null=True)),
                ('availability_zone_id', models.TextField(blank=True, db_comment='The AZ ID of the subnet.', null=True)),
                ('customer_owned_ipv4_pool', models.TextField(blank=True, db_comment='The customer-owned IPv4 address pool associated with the subnet.', null=True)),
                ('default_for_az', models.BooleanField(blank=True, db_comment='Indicates whether this is the default subnet for the Availability Zone.', null=True)),
                ('map_customer_owned_ip_on_launch', models.BooleanField(blank=True, db_comment='Indicates whether a network interface created in this subnet (including a network interface created by RunInstances) receives a customer-owned IPv4 address.', null=True)),
                ('map_public_ip_on_launch', models.BooleanField(blank=True, db_comment='Indicates whether instances launched in this subnet receive a public IPv4 address.', null=True)),
                ('outpost_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the Outpost. Available only if subnet is on an outpost.', null=True)),
                ('ipv6_cidr_block_association_set', models.JSONField(blank=True, db_comment='A list of IPv6 CIDR blocks associated with the subnet.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are attached to the subnet.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_subnet',
                'db_table_comment': 'AWS VPC Subnet',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcVerifiedAccessEndpoint',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('verified_access_endpoint_id', models.TextField(blank=True, db_comment='The ID of the AWS verified access endpoint.', null=True)),
                ('verified_access_group_id', models.TextField(blank=True, db_comment='The ID of the AWS verified access group.', null=True)),
                ('verified_access_instance_id', models.TextField(blank=True, db_comment='The ID of the AWS verified access instance.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The creation time.', null=True)),
                ('status_code', models.TextField(blank=True, db_comment='The endpoint status code. Possible values are pending, active, updating, deleting or deleted.', null=True)),
                ('application_domain', models.TextField(blank=True, db_comment='The DNS name for users to reach your application.', null=True)),
                ('attachment_type', models.TextField(blank=True, db_comment='The type of attachment used to provide connectivity between the AWS verified access endpoint and the application.', null=True)),
                ('deletion_time', models.DateTimeField(blank=True, db_comment='The deletion time.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description for the AWS verified access endpoint.', null=True)),
                ('device_validation_domain', models.TextField(blank=True, db_comment='Returned if endpoint has a device trust provider attached.', null=True)),
                ('domain_certificate_arn', models.TextField(blank=True, db_comment='The ARN of a public TLS/SSL certificate imported into or created with ACM.', null=True)),
                ('endpoint_domain', models.TextField(blank=True, db_comment='A DNS name that is generated for the endpoint..', null=True)),
                ('endpoint_type', models.TextField(blank=True, db_comment='The type of AWS verified access endpoint. Incoming application requests will be sent to an IP address, load balancer or a network interface depending on the endpoint type specified. Possible values are load-balancer or network-interface.', null=True)),
                ('last_updated_time', models.DateTimeField(blank=True, db_comment='The last updated time.', null=True)),
                ('load_balancer_options', models.JSONField(blank=True, db_comment='The load balancer details if creating the AWS verified access endpoint as load-balancertype.', null=True)),
                ('network_interface_options', models.JSONField(blank=True, db_comment='The options for network-interface type endpoint.', null=True)),
                ('status', models.JSONField(blank=True, db_comment='The endpoint status.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_verified_access_endpoint',
                'db_table_comment': 'AWS VPC verified access Endpoint',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcVerifiedAccessGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('verified_access_group_id', models.TextField(blank=True, db_comment='The ID of the verified access group.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The ARN of the verified access group.', null=True)),
                ('verified_access_instance_id', models.TextField(blank=True, db_comment='The ID of the AWS Verified Access instance.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The creation time.', null=True)),
                ('deletion_time', models.DateTimeField(blank=True, db_comment='The deleteion time.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description for the AWS verified access group.', null=True)),
                ('last_updated_time', models.DateTimeField(blank=True, db_comment='The last updated time.', null=True)),
                ('owner', models.TextField(blank=True, db_comment='The AWS account number that owns the group.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_verified_access_group',
                'db_table_comment': 'AWS VPC Verified Access Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcVerifiedAccessInstance',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('verified_access_instance_id', models.TextField(blank=True, db_comment='The ID of the AWS Verified Access instance.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The creation time.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description for the AWS Verified Access instance.', null=True)),
                ('last_updated_time', models.DateTimeField(blank=True, db_comment='The last updated time.', null=True)),
                ('verified_access_trust_providers', models.JSONField(blank=True, db_comment='The IDs of the AWS Verified Access trusted providers.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_verified_access_instance',
                'db_table_comment': 'AWS VPC Verified Access Instance',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcVerifiedAccessTrustProvider',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('verified_access_trust_provider_id', models.TextField(blank=True, db_comment='The ID of the AWS Verified Access trust provider.', null=True)),
                ('creation_time', models.DateTimeField(blank=True, db_comment='The creation time.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description for the AWS Verified Access trust provider.', null=True)),
                ('device_trust_provider_type', models.TextField(blank=True, db_comment='The type of device-based trust provider.', null=True)),
                ('last_updated_time', models.DateTimeField(blank=True, db_comment='The last updated time.', null=True)),
                ('policy_reference_name', models.TextField(blank=True, db_comment='The identifier to be used when working with policy rules.', null=True)),
                ('trust_provider_type', models.TextField(blank=True, db_comment='The type of Verified Access trust provider.', null=True)),
                ('user_trust_provider_type', models.TextField(blank=True, db_comment='The type of user-based trust provider.', null=True)),
                ('oidc_options', models.JSONField(blank=True, db_comment='The OpenID Connect details for an oidc-type, user-identity based trust provider.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_verified_access_trust_provider',
                'db_table_comment': 'AWS VPC Verified Access Trust Provider',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcVpnConnection',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('vpn_connection_id', models.TextField(blank=True, db_comment='The ID of the VPN connection.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) specifying the VPN connection.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The current state of the VPN connection.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of VPN connection.', null=True)),
                ('category', models.TextField(blank=True, db_comment='The category of the VPN connection. A value of VPN indicates an AWS VPN connection.', null=True)),
                ('vpn_gateway_id', models.TextField(blank=True, db_comment='The ID of the virtual private gateway at the AWS side of the VPN connection.', null=True)),
                ('customer_gateway_id', models.TextField(blank=True, db_comment='The ID of the customer gateway at your end of the VPN connection.', null=True)),
                ('customer_gateway_configuration', models.TextField(blank=True, db_comment="The configuration information for the VPN connection's customer gateway.", null=True)),
                ('transit_gateway_id', models.TextField(blank=True, db_comment='The ID of the transit gateway associated with the VPN connection.', null=True)),
                ('options', models.JSONField(blank=True, db_comment='The VPN connection options.', null=True)),
                ('routes', models.JSONField(blank=True, db_comment='The static routes associated with the VPN connection.', null=True)),
                ('vgw_telemetry', models.JSONField(blank=True, db_comment='Information about the VPN tunnel.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are attached to VPN gateway.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_vpn_connection',
                'db_table_comment': 'AWS VPC VPN Connection',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsVpcVpnGateway',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('vpn_gateway_id', models.TextField(blank=True, db_comment='The ID of the virtual private gateway.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The current state of the virtual private gateway.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of VPN connection the virtual private gateway supports.', null=True)),
                ('amazon_side_asn', models.BigIntegerField(blank=True, db_comment='The private Autonomous System Number (ASN) for the Amazon side of a BGP session.', null=True)),
                ('availability_zone', models.TextField(blank=True, db_comment='The Availability Zone where the virtual private gateway was created, if applicable. This field may be empty or not returned.', null=True)),
                ('vpc_attachments', models.JSONField(blank=True, db_comment='Any VPCs attached to the virtual private gateway.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags that are attached to VPN gateway.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_vpc_vpn_gateway',
                'db_table_comment': 'AWS VPC VPN Gateway',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWafRateBasedRule',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name for the rule.', null=True)),
                ('rule_id', models.TextField(blank=True, db_comment='The ID of the Rule.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name or description for the metrics for a RateBasedRule.', null=True)),
                ('rate_key', models.TextField(blank=True, db_comment='The field that AWS WAF uses to determine if requests are likely arriving from single source and thus subject to rate monitoring.', null=True)),
                ('rate_limit', models.BigIntegerField(blank=True, db_comment='The maximum number of requests, which have an identical value in the field specified by the RateKey, allowed in a five-minute period.', null=True)),
                ('predicates', models.JSONField(blank=True, db_comment='The Predicates object contains one Predicate element for each ByteMatchSet, IPSet or SqlInjectionMatchSet object that you want to include in a RateBasedRule.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the Rule.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_waf_rate_based_rule',
                'db_table_comment': 'AWS WAF Rate Based Rule',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWafregionalRule',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The friendly name or description for the Rule.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='Amazon Resource Name (ARN) of the Rule.', null=True)),
                ('rule_id', models.TextField(blank=True, db_comment='A unique identifier for a Rule.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='A friendly name or description for the metrics for this Rule.', null=True)),
                ('predicates', models.JSONField(blank=True, db_comment='The Predicates object contains one Predicate element for each ByteMatchSet,IPSet, or SqlInjectionMatchSet object that you want to include in a Rule.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wafregional_rule',
                'db_table_comment': 'AWS WAF Regional Rule',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWafregionalRuleGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the rule group.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the entity.', null=True)),
                ('rule_group_id', models.TextField(blank=True, db_comment='A unique identifier for the rule group.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='A friendly name or description for the metrics for this RuleGroup.', null=True)),
                ('activated_rules', models.JSONField(blank=True, db_comment='A list of activated rules associated with the resource.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wafregional_rule_group',
                'db_table_comment': 'AWS WAF Regional Rule Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWafregionalWebAcl',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the Web ACL. You cannot change the name of a Web ACL after you create it.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the entity.', null=True)),
                ('web_acl_id', models.TextField(blank=True, db_comment='The unique identifier for the Web ACL.', null=True)),
                ('default_action', models.TextField(blank=True, db_comment='The action to perform if none of the Rules contained in the WebACL match.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='A friendly name or description for the metrics for this WebACL.', null=True)),
                ('logging_configuration', models.JSONField(blank=True, db_comment='The logging configuration for the web ACL.', null=True)),
                ('resources', models.JSONField(blank=True, db_comment='An array of ARNs (Amazon Resource Names) of the resources associated with the web ACL.', null=True)),
                ('rules', models.JSONField(blank=True, db_comment='The Rule statements used to identify the web requests that you want to allow, block, or count.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wafregional_web_acl',
                'db_table_comment': 'AWS WAF Regional Web ACL',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWafRule',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name for the rule.', null=True)),
                ('rule_id', models.TextField(blank=True, db_comment='The ID of the Rule.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='The name of the metric for the Rule.', null=True)),
                ('predicates', models.JSONField(blank=True, db_comment='The Predicates object contains one Predicate element for each ByteMatchSet,IPSet, or SqlInjectionMatchSet object that you want to include in a Rule.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags assigned to the Rule.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_waf_rule',
                'db_table_comment': 'AWS WAF Rule',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWafRuleGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the rule group.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the entity.', null=True)),
                ('rule_group_id', models.TextField(blank=True, db_comment='A unique identifier for the rule group.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='A friendly name or description for the metrics for this RuleGroup.', null=True)),
                ('activated_rules', models.JSONField(blank=True, db_comment='A list of activated rules associated with the resource.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_waf_rule_group',
                'db_table_comment': 'AWS WAF Rule Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWafv2IpSet',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the IP set.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the entity.', null=True)),
                ('id', models.TextField(blank=True, db_comment='A unique identifier for the IP set.', primary_key=True, serialize=False)),
                ('scope', models.TextField(blank=True, db_comment="Specifies the scope of the IP Set. Possible values are: 'REGIONAL' and 'CLOUDFRONT'.", null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the IP set that helps with identification.', null=True)),
                ('ip_address_version', models.TextField(blank=True, db_comment="Specifies the IP address type. Possible values are: 'IPV4' and 'IPV6'.", null=True)),
                ('lock_token', models.TextField(blank=True, db_comment='A token used for optimistic locking.', null=True)),
                ('addresses', models.JSONField(blank=True, db_comment='An array of strings that specify one or more IP addresses or blocks of IP addresses in Classless Inter-Domain Routing (CIDR) notation.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wafv2_ip_set',
                'db_table_comment': 'AWS WAFv2 IP Set',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWafv2RegexPatternSet',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the Regex Pattern set.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the entity.', null=True)),
                ('id', models.TextField(blank=True, db_comment='A unique identifier for the Regex Pattern set.', null=True)),
                ('scope', models.TextField(blank=True, db_comment="Specifies the scope of the Regex Pattern Set. Possible values are: 'REGIONAL' and 'CLOUDFRONT'.", null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the Regex Pattern set that helps with identification.', null=True)),
                ('lock_token', models.TextField(blank=True, db_comment='A token used for optimistic locking.', null=True)),
                ('regular_expressions', models.JSONField(blank=True, db_comment='The list of regular expression patterns in the set.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wafv2_regex_pattern_set',
                'db_table_comment': 'AWS WAFv2 Regex Pattern Set',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWafv2RuleGroup',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the rule group.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the entity.', null=True)),
                ('id', models.TextField(blank=True, db_comment='A unique identifier for the rule group.', null=True)),
                ('scope', models.TextField(blank=True, db_comment="Specifies the scope of the rule group. Possible values are: 'REGIONAL' and 'CLOUDFRONT'.", null=True)),
                ('capacity', models.BigIntegerField(blank=True, db_comment='The web ACL capacity units (WCUs) required for this rule group.', null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the rule group that helps with identification.', null=True)),
                ('lock_token', models.TextField(blank=True, db_comment='A token used for optimistic locking.', null=True)),
                ('rules', models.JSONField(blank=True, db_comment='The Rule statements used to identify the web requests that you want to allow, block, or count.', null=True)),
                ('visibility_config', models.JSONField(blank=True, db_comment='Defines and enables Amazon CloudWatch metrics and web request sample collection.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wafv2_rule_group',
                'db_table_comment': 'AWS WAFv2 Rule Group',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWafv2WebAcl',
            fields=[
                ('name', models.TextField(blank=True, db_comment='The name of the Web ACL. You cannot change the name of a Web ACL after you create it.', primary_key=True, serialize=False)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the entity.', null=True)),
                ('id', models.TextField(blank=True, db_comment='The unique identifier for the Web ACL.', null=True)),
                ('scope', models.TextField(blank=True, db_comment="Specifies the scope of the Web ACL. Possibles values are: 'REGIONAL' and 'CLOUDFRONT'.", null=True)),
                ('description', models.TextField(blank=True, db_comment='A description of the Web ACL that helps with identification.', null=True)),
                ('capacity', models.BigIntegerField(blank=True, db_comment='The Web ACL capacity units(WCUs) currently being used by this resource.', null=True)),
                ('lock_token', models.TextField(blank=True, db_comment='A token used for optimistic locking.', null=True)),
                ('managed_by_firewall_manager', models.BooleanField(blank=True, db_comment='Indicates whether this web ACL is managed by AWS Firewall Manager.', null=True)),
                ('associated_resources', models.JSONField(blank=True, db_comment='The array of Amazon Resource Names (ARNs) of the associated resources.', null=True)),
                ('default_action', models.JSONField(blank=True, db_comment='The action to perform if none of the Rules contained in the Web ACL match.', null=True)),
                ('logging_configuration', models.JSONField(blank=True, db_comment='The logging configuration for the specified web ACL.', null=True)),
                ('pre_process_firewall_manager_rule_groups', models.JSONField(blank=True, db_comment='The first set of rules for AWS WAF to process in the web ACL.', null=True)),
                ('post_process_firewall_manager_rule_groups', models.JSONField(blank=True, db_comment='The last set of rules for AWS WAF to process in the web ACL.', null=True)),
                ('rules', models.JSONField(blank=True, db_comment='The Rule statements used to identify the web requests that you want to allow, block, or count.', null=True)),
                ('visibility_config', models.JSONField(blank=True, db_comment='Defines and enables Amazon CloudWatch metrics and web request sample collection.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wafv2_web_acl',
                'db_table_comment': 'AWS WAFv2 Web ACL',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWafWebAcl',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, db_comment='The name of the Web ACL. You cannot change the name of a Web ACL after you create it.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the entity.', null=True)),
                ('web_acl_id', models.TextField(blank=True, db_comment='The unique identifier for the Web ACL.', null=True)),
                ('default_action', models.TextField(blank=True, db_comment='The action to perform if none of the Rules contained in the WebACL match.', null=True)),
                ('metric_name', models.TextField(blank=True, db_comment='A friendly name or description for the metrics for this WebACL.', null=True)),
                ('logging_configuration', models.JSONField(blank=True, db_comment='The logging configuration for the specified web ACL.', null=True)),
                ('rules', models.JSONField(blank=True, db_comment='The Rule statements used to identify the web requests that you want to allow, block, or count.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='A list of tags associated with the resource.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_waf_web_acl',
                'db_table_comment': 'AWS WAF Web ACL',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWellarchitectedAnswer',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('question_id', models.TextField(blank=True, db_comment='The ID of the question.', null=True)),
                ('lens_alias', models.TextField(blank=True, db_comment='The alias of the lens.', null=True)),
                ('workload_id', models.TextField(blank=True, db_comment='The ID assigned to the workload.', null=True)),
                ('helpful_resource_display_text', models.TextField(blank=True, db_comment='The helpful resource text to be displayed.', null=True)),
                ('helpful_resource_url', models.TextField(blank=True, db_comment='The helpful resource URL for a question.', null=True)),
                ('improvement_plan_url', models.TextField(blank=True, db_comment='The improvement plan URL for a question. This value is only available if the question has been answered.', null=True)),
                ('is_applicable', models.BooleanField(blank=True, db_comment='Defines whether this question is applicable to a lens review.', null=True)),
                ('lens_arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the lens.', null=True)),
                ('milestone_number', models.BigIntegerField(blank=True, db_comment='The milestone number.', null=True)),
                ('notes', models.TextField(blank=True, db_comment='The notes associated with the workload.', null=True)),
                ('pillar_id', models.TextField(blank=True, db_comment='The ID used to identify a pillar, for example, security. A pillar is identified by its PillarReviewSummary$PillarId.', null=True)),
                ('question_description', models.TextField(blank=True, db_comment='The description of the question.', null=True)),
                ('question_title', models.TextField(blank=True, db_comment='The title of the question.', null=True)),
                ('reason', models.TextField(blank=True, db_comment='The reason why the question is not applicable to your workload.', null=True)),
                ('risk', models.TextField(blank=True, db_comment='The risk for a given workload, lens review, pillar, or question.', null=True)),
                ('choice_answers', models.JSONField(blank=True, db_comment='A list of selected choices to a question in your workload.', null=True)),
                ('choices', models.JSONField(blank=True, db_comment='List of choices available for a question.', null=True)),
                ('selected_choices', models.JSONField(blank=True, db_comment='List of selected choice IDs in a question answer. The values entered replace the previously selected choices.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wellarchitected_answer',
                'db_table_comment': 'AWS Well-Architected Answer',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWellarchitectedCheckDetail',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('choice_id', models.TextField(blank=True, db_comment='The ID of a choice.', null=True)),
                ('description', models.TextField(blank=True, db_comment='Trusted Advisor check description.', null=True)),
                ('flagged_resources', models.BigIntegerField(blank=True, db_comment='Count of flagged resources associated to the check.', null=True)),
                ('lens_arn', models.TextField(blank=True, db_comment='Well-Architected Lens ARN associated to the check.', null=True)),
                ('name', models.TextField(blank=True, db_comment='Trusted Advisor check name.', null=True)),
                ('owner_account_id', models.TextField(blank=True, db_comment='An Amazon Web Services account ID.', null=True)),
                ('pillar_id', models.TextField(blank=True, db_comment='The ID used to identify a pillar, for example, security. A pillar is identified by its PillarReviewSummary$PillarId.', null=True)),
                ('provider', models.TextField(blank=True, db_comment='Provider of the check related to the best practice.', null=True)),
                ('question_id', models.TextField(blank=True, db_comment='The ID of the question.', null=True)),
                ('reason', models.TextField(blank=True, db_comment='Reason associated to the check.', null=True)),
                ('status', models.TextField(blank=True, db_comment='Status associated to the check.', null=True)),
                ('updated_at', models.DateTimeField(blank=True, db_comment='The date and time recorded.', null=True)),
                ('workload_id', models.TextField(blank=True, db_comment='The ID of the workload.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wellarchitected_check_detail',
                'db_table_comment': 'AWS Well-Architected Check Detail',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWellarchitectedCheckSummary',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('choice_id', models.TextField(blank=True, db_comment='The ID of a choice.', null=True)),
                ('description', models.TextField(blank=True, db_comment='Trusted Advisor check description.', null=True)),
                ('lens_arn', models.TextField(blank=True, db_comment='Well-Architected Lens ARN associated to the check.', null=True)),
                ('name', models.TextField(blank=True, db_comment='Trusted Advisor check name.', null=True)),
                ('pillar_id', models.TextField(blank=True, db_comment='The ID used to identify a pillar, for example, security. A pillar is identified by its PillarReviewSummary$PillarId.', null=True)),
                ('provider', models.TextField(blank=True, db_comment='Provider of the check related to the best practice.', null=True)),
                ('question_id', models.TextField(blank=True, db_comment='The ID of the question.', null=True)),
                ('status', models.TextField(blank=True, db_comment='Status associated to the check.', null=True)),
                ('updated_at', models.DateTimeField(blank=True, db_comment='The date and time recorded.', null=True)),
                ('workload_id', models.TextField(blank=True, db_comment='The ID of the workload.', null=True)),
                ('account_summary', models.JSONField(blank=True, db_comment='Account summary associated to the check.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wellarchitected_check_summary',
                'db_table_comment': 'AWS Well-Architected Check Summary',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWellarchitectedConsolidatedReport',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('workload_name', models.TextField(blank=True, db_comment='The name of the workload.', null=True)),
                ('workload_arn', models.TextField(blank=True, db_comment='The ARN for the workload.', null=True)),
                ('workload_id', models.TextField(blank=True, db_comment='The ID assigned to the workload.', null=True)),
                ('include_shared_resources', models.BooleanField(blank=True, db_comment='Set to true to have shared resources included in the report.', null=True)),
                ('base64_string', models.JSONField(blank=True, db_comment='The Base64-encoded string representation of a lens review report. This data can be used to create a PDF file. Only returned by GetConsolidatedReport when PDF format is requested.', null=True)),
                ('lenses_applied_count', models.BigIntegerField(blank=True, db_comment='The total number of lenses applied to the workload.', null=True)),
                ('metric_type', models.TextField(blank=True, db_comment='The metric type of a metric in the consolidated report. Currently only WORKLOAD metric types are supported.', null=True)),
                ('updated_at', models.DateTimeField(blank=True, db_comment='The date and time when the consolidated report was updated.', null=True)),
                ('lenses', models.JSONField(blank=True, db_comment='The metrics for the lenses in the workload.', null=True)),
                ('risk_counts', models.JSONField(blank=True, db_comment='A map from risk names to the count of how many questions have that rating.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wellarchitected_consolidated_report',
                'db_table_comment': 'AWS Well-Architected Consolidated Report',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWellarchitectedLens',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('lens_name', models.TextField(blank=True, db_comment='The full name of the lens.', null=True)),
                ('lens_alias', models.TextField(blank=True, db_comment='The alias of the lens.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The Amazon Resource Name (ARN) of the lens.', null=True)),
                ('created_at', models.DateTimeField(blank=True, db_comment='The date and time when the lens was created.', null=True)),
                ('updated_at', models.DateTimeField(blank=True, db_comment='The date and time when the lens was last updated.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description of the lens.', null=True)),
                ('lens_status', models.TextField(blank=True, db_comment='The status of the lens.', null=True)),
                ('lens_type', models.TextField(blank=True, db_comment='The type of the lens.', null=True)),
                ('lens_version', models.TextField(blank=True, db_comment='The version of the lens.', null=True)),
                ('owner', models.TextField(blank=True, db_comment='An Amazon Web Services account ID.', null=True)),
                ('share_invitation_id', models.TextField(blank=True, db_comment='The ID assigned to the shared invitation.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wellarchitected_lens',
                'db_table_comment': 'AWS Well-Architected Lens',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWellarchitectedLensReview',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('lens_name', models.TextField(blank=True, db_comment='The full name of the lens.', null=True)),
                ('lens_arn', models.TextField(blank=True, db_comment='The ARN for the lens.', null=True)),
                ('lens_alias', models.TextField(blank=True, db_comment='The alias of the lens.', null=True)),
                ('workload_id', models.TextField(blank=True, db_comment='The ID assigned to the workload.', null=True)),
                ('lens_status', models.TextField(blank=True, db_comment='The status of the lens.', null=True)),
                ('lens_version', models.TextField(blank=True, db_comment='The version of the lens.', null=True)),
                ('milestone_number', models.BigIntegerField(blank=True, db_comment='The milestone number. A workload can have a maximum of 100 milestones.', null=True)),
                ('notes', models.TextField(blank=True, db_comment='The notes associated with the workload.', null=True)),
                ('updated_at', models.DateTimeField(blank=True, db_comment='The date and time of the last update.', null=True)),
                ('pillar_review_summaries', models.JSONField(blank=True, db_comment='A map from risk names to the count of how questions have that rating.', null=True)),
                ('risk_counts', models.JSONField(blank=True, db_comment='A map from risk names to the count of how questions have that rating.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wellarchitected_lens_review',
                'db_table_comment': 'AWS Well-Architected Lens Review',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWellarchitectedLensReviewImprovement',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('lens_alias', models.TextField(blank=True, db_comment='The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens. Each lens is identified by its LensSummary$LensAlias.', null=True)),
                ('lens_arn', models.TextField(blank=True, db_comment='The ARN for the lens.', null=True)),
                ('workload_id', models.TextField(blank=True, db_comment='The ID assigned to the workload.', null=True)),
                ('milestone_number', models.BigIntegerField(blank=True, db_comment='The milestone number. A workload can have a maximum of 100 milestones.', null=True)),
                ('improvement_plan_url', models.TextField(blank=True, db_comment='The improvement plan URL for a question. This value is only available if the question has been answered.', null=True)),
                ('pillar_id', models.TextField(blank=True, db_comment='The ID used to identify a pillar, for example, security. A pillar is identified by its PillarReviewSummary$PillarId.', null=True)),
                ('question_id', models.TextField(blank=True, db_comment='The ID of the question.', null=True)),
                ('question_title', models.TextField(blank=True, db_comment='The title of the question.', null=True)),
                ('risk', models.TextField(blank=True, db_comment='The risk for a given workload, lens review, pillar, or question.', null=True)),
                ('improvement_plans', models.JSONField(blank=True, db_comment='The improvement plan details.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wellarchitected_lens_review_improvement',
                'db_table_comment': 'AWS Well-Architected Lens Review Improvement',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWellarchitectedLensReviewReport',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('lens_alias', models.TextField(blank=True, db_comment='The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens. Each lens is identified by its LensSummary$LensAlias.', null=True)),
                ('lens_arn', models.TextField(blank=True, db_comment='The ARN for the lens.', null=True)),
                ('workload_id', models.TextField(blank=True, db_comment='The ID assigned to the workload.', null=True)),
                ('milestone_number', models.BigIntegerField(blank=True, db_comment='The milestone number. A workload can have a maximum of 100 milestones.', null=True)),
                ('base64_string', models.TextField(blank=True, db_comment='The Base64-encoded string representation of a lens review report. This data can be used to create a PDF file.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wellarchitected_lens_review_report',
                'db_table_comment': 'AWS Well-Architected Lens Review Report',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWellarchitectedMilestone',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('milestone_name', models.TextField(blank=True, db_comment='The name of the milestone in a workload. Milestone names must be unique within a workload.', null=True)),
                ('milestone_number', models.BigIntegerField(blank=True, db_comment='The milestone number. A workload can have a maximum of 100 milestones.', null=True)),
                ('recorded_at', models.DateTimeField(blank=True, db_comment='The date and time recorded.', null=True)),
                ('workload_id', models.TextField(blank=True, db_comment='The ID assigned to the workload.', null=True)),
                ('workload', models.JSONField(blank=True, db_comment='A workload return object.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wellarchitected_milestone',
                'db_table_comment': 'AWS Well-Architected Milestone',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWellarchitectedNotification',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('current_lens_version', models.TextField(blank=True, db_comment='The current version of the lens.', null=True)),
                ('latest_lens_version', models.TextField(blank=True, db_comment='The latest version of the lens.', null=True)),
                ('lens_alias', models.TextField(blank=True, db_comment='The alias of the lens.', null=True)),
                ('lens_arn', models.TextField(blank=True, db_comment='The ARN of the lens.', null=True)),
                ('type', models.TextField(blank=True, db_comment='The type of notification.', null=True)),
                ('workload_id', models.TextField(blank=True, db_comment='The ID assigned to the workload.', null=True)),
                ('workload_name', models.TextField(blank=True, db_comment='The name of the workload.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wellarchitected_notification',
                'db_table_comment': 'AWS Well-Architected Notification',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWellarchitectedShareInvitation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('lens_arn', models.TextField(blank=True, db_comment='The ARN for the lens.', null=True)),
                ('lens_name', models.TextField(blank=True, db_comment='The full name of the lens.', null=True)),
                ('permission_type', models.TextField(blank=True, db_comment='Permission granted on a workload share.', null=True)),
                ('share_invitation_id', models.TextField(blank=True, db_comment='The ID assigned to the share invitation.', null=True)),
                ('share_resource_type', models.TextField(blank=True, db_comment='The resource type of the share invitation.', null=True)),
                ('shared_by', models.TextField(blank=True, db_comment='An Amazon Web Services account ID.', null=True)),
                ('shared_with', models.TextField(blank=True, db_comment='The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.', null=True)),
                ('workload_name', models.TextField(blank=True, db_comment='The name of the workload.', null=True)),
                ('workload_id', models.TextField(blank=True, db_comment='The ID assigned to the workload.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wellarchitected_share_invitation',
                'db_table_comment': 'AWS Well-Architected Share Invitation',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWellarchitectedWorkload',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('workload_name', models.TextField(blank=True, db_comment='The name of the workload.', null=True)),
                ('workload_arn', models.TextField(blank=True, db_comment='The ARN for the workload.', null=True)),
                ('workload_id', models.TextField(blank=True, db_comment='The ID assigned to the workload.', null=True)),
                ('architectural_design', models.TextField(blank=True, db_comment='The URL of the architectural design for the workload.', null=True)),
                ('description', models.TextField(blank=True, db_comment='The description for the workload.', null=True)),
                ('environment', models.TextField(blank=True, db_comment='The environment for the workload.', null=True)),
                ('improvement_status', models.TextField(blank=True, db_comment='The improvement status for a workload.', null=True)),
                ('industry', models.TextField(blank=True, db_comment='The industry for the workload.', null=True)),
                ('industry_type', models.TextField(blank=True, db_comment='The industry type for the workload.', null=True)),
                ('is_review_owner_update_acknowledged', models.BooleanField(blank=True, db_comment='Flag indicating whether the workload owner has acknowledged that the review owner field is required.', null=True)),
                ('notes', models.TextField(blank=True, db_comment='The notes associated with the workload.', null=True)),
                ('owner', models.TextField(blank=True, db_comment='An AWS account ID.', null=True)),
                ('review_owner', models.TextField(blank=True, db_comment='The review owner of the workload.', null=True)),
                ('review_restriction_date', models.DateTimeField(blank=True, db_comment='The date and time recorded.', null=True)),
                ('share_invitation_id', models.TextField(blank=True, db_comment='The ID assigned to the share invitation.', null=True)),
                ('updated_at', models.DateTimeField(blank=True, db_comment='The date and time recorded.', null=True)),
                ('account_ids', models.JSONField(blank=True, db_comment='The list of AWS account IDs associated with the workload.', null=True)),
                ('aws_regions', models.JSONField(blank=True, db_comment='The list of AWS Regions associated with the workload, for example, us-east-2, or ca-central-1.', null=True)),
                ('lenses', models.JSONField(blank=True, db_comment='The list of lenses associated with the workload. Each lens is identified by its LensSummary$LensAlias.', null=True)),
                ('non_aws_regions', models.JSONField(blank=True, db_comment='The list of non-AWS Regions associated with the workload.', null=True)),
                ('pillar_priorities', models.JSONField(blank=True, db_comment='The priorities of the pillars, which are used to order items in the improvement plan. ', null=True)),
                ('risk_counts', models.JSONField(blank=True, db_comment='A map from risk names to the count of how questions have that rating.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wellarchitected_workload',
                'db_table_comment': 'AWS Well-Architected Workload',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWellarchitectedWorkloadShare',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('workload_id', models.TextField(blank=True, db_comment='The ID assigned to the workload.', null=True)),
                ('permission_type', models.TextField(blank=True, db_comment='Permission granted on a workload share.', null=True)),
                ('share_id', models.TextField(blank=True, db_comment='The ID associated with the workload share.', null=True)),
                ('shared_with', models.TextField(blank=True, db_comment='The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.', null=True)),
                ('status', models.TextField(blank=True, db_comment='The status of a workload share.', null=True)),
                ('status_message', models.TextField(blank=True, db_comment='Optional message to compliment the Status field.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_wellarchitected_workload_share',
                'db_table_comment': 'AWS Well-Architected Workload Share',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWorkspacesDirectory',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('directory_id', models.TextField(blank=True, db_comment='The directory identifier.', null=True)),
                ('name', models.TextField(blank=True, db_comment='The name of the directory.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The arn of the directory.', null=True)),
                ('alias', models.TextField(blank=True, db_comment='The directory alias.', null=True)),
                ('certificate_based_auth_properties', models.JSONField(blank=True, db_comment='The certificate-based authentication properties used to authenticate SAML 2.0 Identity Provider (IdP) user identities to Active Directory for WorkSpaces login.', null=True)),
                ('customer_user_name', models.TextField(blank=True, db_comment='The user name for the service account.', null=True)),
                ('directory_type', models.TextField(blank=True, db_comment='The directory type.', null=True)),
                ('dns_ip_addresses', models.JSONField(blank=True, db_comment='The IP addresses of the DNS servers for the directory.', null=True)),
                ('iam_role_id', models.TextField(blank=True, db_comment='The identifier of the IAM role. This is the role that allows Amazon WorkSpaces to make calls to other services, such as Amazon EC2, on your behalf.', null=True)),
                ('ip_group_ids', models.TextField(blank=True, db_comment='The identifiers of the IP access control groups associated with the directory.', null=True)),
                ('registration_code', models.TextField(blank=True, db_comment='The registration code for the directory. This is the code that users enter in their Amazon WorkSpaces client application to connect to the directory.', null=True)),
                ('saml_properties', models.JSONField(blank=True, db_comment='Describes the enablement status, user access URL, and relay state parameter name that are used for configuring federation with an SAML 2.0 identity provider.', null=True)),
                ('selfservice_permissions', models.JSONField(blank=True, db_comment='The default self-service permissions for WorkSpaces in the directory.', null=True)),
                ('state', models.TextField(blank=True, db_comment="The state of the directory's registration with Amazon WorkSpaces.", null=True)),
                ('subnet_ids', models.JSONField(blank=True, db_comment='The identifiers of the subnets used with the directory.', null=True)),
                ('tenancy', models.TextField(blank=True, db_comment='Specifies whether the directory is dedicated or shared.', null=True)),
                ('workspace_access_properties', models.JSONField(blank=True, db_comment='The devices and operating systems that users can use to access WorkSpaces.', null=True)),
                ('workspace_creation_properties', models.JSONField(blank=True, db_comment='The default creation properties for all WorkSpaces in the directory.', null=True)),
                ('workspace_security_group_id', models.TextField(blank=True, db_comment='The identifier of the security group that is assigned to new WorkSpaces.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The list of tags for the directory.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_workspaces_directory',
                'db_table_comment': 'AWS Workspaces Directory',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AwsWorkspacesWorkspace',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('workspace_id', models.TextField(blank=True, db_comment='The id of the WorkSpace.', null=True)),
                ('name', models.TextField(blank=True, db_comment='The name of the WorkSpace.', null=True)),
                ('arn', models.TextField(blank=True, db_comment='The arn of the WorkSpace.', null=True)),
                ('bundle_id', models.TextField(blank=True, db_comment='The identifier of the bundle used to create the WorkSpace.', null=True)),
                ('directory_id', models.TextField(blank=True, db_comment='The identifier of the AWS Directory Service directory for the WorkSpace.', null=True)),
                ('state', models.TextField(blank=True, db_comment='The operational state of the WorkSpace.', null=True)),
                ('error_code', models.TextField(blank=True, db_comment='The error code that is returned if the WorkSpace cannot be created.', null=True)),
                ('error_message', models.TextField(blank=True, db_comment='The text of the error message that is returned if the WorkSpace cannot be created.', null=True)),
                ('ip_address', models.GenericIPAddressField(blank=True, db_comment='The IP address of the WorkSpace.', null=True)),
                ('root_volume_encryption_enabled', models.BooleanField(blank=True, db_comment='Indicates whether the data stored on the root volume is encrypted.', null=True)),
                ('subnet_id', models.TextField(blank=True, db_comment='The identifier of the subnet for the WorkSpace.', null=True)),
                ('user_name', models.TextField(blank=True, db_comment='The user for the WorkSpace.', null=True)),
                ('user_volume_encryption_enabled', models.BooleanField(blank=True, db_comment='Indicates whether the data stored on the user volume is encrypted.', null=True)),
                ('volume_encryption_key', models.TextField(blank=True, db_comment='The symmetric AWS KMS customer master key (CMK) used to encrypt data stored on your WorkSpace. Amazon WorkSpaces does not support asymmetric CMKs.', null=True)),
                ('modification_states', models.JSONField(blank=True, db_comment='The modification states of the WorkSpace.', null=True)),
                ('workspace_properties', models.JSONField(blank=True, db_comment='The properties of the WorkSpace.', null=True)),
                ('tags_src', models.JSONField(blank=True, db_comment='The list of tags for the WorkSpace.', null=True)),
                ('title', models.TextField(blank=True, db_comment='Title of the resource.', null=True)),
                ('tags', models.JSONField(blank=True, db_comment='A map of tags for the resource.', null=True)),
                ('akas', models.JSONField(blank=True, db_comment='Array of globally unique identifier strings (also known as) for the resource.', null=True)),
                ('partition', models.TextField(blank=True, db_comment='The AWS partition in which the resource is located (aws, aws-cn, or aws-us-gov).', null=True)),
                ('region', models.TextField(blank=True, db_comment='The AWS Region in which the resource is located.', null=True)),
                ('account_id', models.TextField(blank=True, db_comment='The AWS Account ID in which the resource is located.', null=True)),
                ('sp_connection_name', models.TextField(blank=True, db_comment='Steampipe connection name.', null=True)),
                ('sp_ctx', models.JSONField(blank=True, db_comment='Steampipe context in JSON form.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form.', null=True)),
            ],
            options={
                'db_table': 'aws_workspaces_workspace',
                'db_table_comment': 'AWS Workspaces',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='DjangoAdminLog',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('action_time', models.DateTimeField()),
                ('object_id', models.TextField(blank=True, null=True)),
                ('object_repr', models.CharField(max_length=200)),
                ('action_flag', models.SmallIntegerField()),
                ('change_message', models.TextField()),
            ],
            options={
                'db_table': 'django_admin_log',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='DjangoContentType',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('app_label', models.CharField(max_length=100)),
                ('model', models.CharField(max_length=100)),
            ],
            options={
                'db_table': 'django_content_type',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='DjangoMigrations',
            fields=[
                ('id', models.BigAutoField(primary_key=True, serialize=False)),
                ('app', models.CharField(max_length=255)),
                ('name', models.CharField(max_length=255)),
                ('applied', models.DateTimeField()),
            ],
            options={
                'db_table': 'django_migrations',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='DjangoSession',
            fields=[
                ('session_key', models.CharField(max_length=40, primary_key=True, serialize=False)),
                ('session_data', models.TextField()),
                ('expire_date', models.DateTimeField()),
            ],
            options={
                'db_table': 'django_session',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='IniKeyValue',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('path', models.TextField(blank=True, db_comment='Specifies the path of the INI file.', null=True)),
                ('section', models.TextField(blank=True, db_comment='Specifies the name of the section.', null=True)),
                ('key', models.TextField(blank=True, db_comment='The name of the key.', null=True)),
                ('value', models.TextField(blank=True, db_comment='The value of corresponding key.', null=True)),
                ('comment', models.TextField(blank=True, db_comment='The short notes used to describe the key.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form, e.g. connection_name.', null=True)),
            ],
            options={
                'db_table': 'ini_key_value',
                'db_table_comment': 'Table representation of an INI file.',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='IniSection',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('path', models.TextField(blank=True, db_comment='Specifies the path of the INI file.', null=True)),
                ('section', models.TextField(blank=True, db_comment='Specifies the name of the section.', null=True)),
                ('comment', models.TextField(blank=True, db_comment='The short notes used to describe the key.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form, e.g. connection_name.', null=True)),
            ],
            options={
                'db_table': 'ini_section',
                'db_table_comment': 'Retrieves a list of sections and subsections defined in a INI file.',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='JsonFile',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('path', models.TextField(blank=True, db_comment='Specifies the path of the JSON file.', null=True)),
                ('content', models.JSONField(blank=True, db_comment='Specifies the file content.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form, e.g. connection_name.', null=True)),
            ],
            options={
                'db_table': 'json_file',
                'db_table_comment': 'Represents the JSON file content.',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='JsonKeyValue',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('path', models.TextField(blank=True, db_comment='Specifies the path of the JSON file.', null=True)),
                ('key_path', models.TextField(blank=True, db_comment='Specifies full path of a key in JSON file.', null=True)),
                ('value', models.TextField(blank=True, db_comment='Specifies the value of the corresponding key.', null=True)),
                ('keys', models.JSONField(blank=True, db_comment='The array representation of path of a key.', null=True)),
                ('start_line', models.BigIntegerField(blank=True, db_comment='Specifies the line number where the value is located.', null=True)),
                ('start_column', models.BigIntegerField(blank=True, db_comment='Specifies the starting column of the value.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form, e.g. connection_name.', null=True)),
            ],
            options={
                'db_table': 'json_key_value',
                'db_table_comment': 'List all key value pairs from given JSON file.',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='SteampipeConnection',
            fields=[
                ('name', models.TextField(primary_key=True, serialize=False)),
                ('state', models.TextField(blank=True, null=True)),
                ('type', models.TextField(blank=True, null=True)),
                ('connections', models.TextField(blank=True, null=True)),
                ('import_schema', models.TextField(blank=True, null=True)),
                ('error', models.TextField(blank=True, null=True)),
                ('plugin', models.TextField(blank=True, null=True)),
                ('plugin_instance', models.TextField(blank=True, null=True)),
                ('schema_mode', models.TextField(blank=True, null=True)),
                ('schema_hash', models.TextField(blank=True, null=True)),
                ('comments_set', models.BooleanField(blank=True, null=True)),
                ('connection_mod_time', models.DateTimeField(blank=True, null=True)),
                ('plugin_mod_time', models.DateTimeField(blank=True, null=True)),
                ('file_name', models.TextField(blank=True, null=True)),
                ('start_line_number', models.IntegerField(blank=True, null=True)),
                ('end_line_number', models.IntegerField(blank=True, null=True)),
            ],
            options={
                'db_table': 'steampipe_connection',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='SteampipeConnectionState',
            fields=[
                ('name', models.TextField(primary_key=True, serialize=False)),
                ('state', models.TextField(blank=True, null=True)),
                ('type', models.TextField(blank=True, null=True)),
                ('connections', models.TextField(blank=True, null=True)),
                ('import_schema', models.TextField(blank=True, null=True)),
                ('error', models.TextField(blank=True, null=True)),
                ('plugin', models.TextField(blank=True, null=True)),
                ('plugin_instance', models.TextField(blank=True, null=True)),
                ('schema_mode', models.TextField(blank=True, null=True)),
                ('schema_hash', models.TextField(blank=True, null=True)),
                ('comments_set', models.BooleanField(blank=True, null=True)),
                ('connection_mod_time', models.DateTimeField(blank=True, null=True)),
                ('plugin_mod_time', models.DateTimeField(blank=True, null=True)),
                ('file_name', models.TextField(blank=True, null=True)),
                ('start_line_number', models.IntegerField(blank=True, null=True)),
                ('end_line_number', models.IntegerField(blank=True, null=True)),
            ],
            options={
                'db_table': 'steampipe_connection_state',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='SteampipePlugin',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('plugin_instance', models.TextField(blank=True, null=True)),
                ('plugin', models.TextField()),
                ('memory_max_mb', models.IntegerField(blank=True, null=True)),
                ('limiters', models.JSONField(blank=True, null=True)),
                ('file_name', models.TextField(blank=True, null=True)),
                ('start_line_number', models.IntegerField(blank=True, null=True)),
                ('end_line_number', models.IntegerField(blank=True, null=True)),
            ],
            options={
                'db_table': 'steampipe_plugin',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='SteampipePluginLimiter',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField(blank=True, null=True)),
                ('plugin', models.TextField(blank=True, null=True)),
                ('plugin_instance', models.TextField(blank=True, null=True)),
                ('source_type', models.TextField(blank=True, null=True)),
                ('status', models.TextField(blank=True, null=True)),
                ('bucket_size', models.IntegerField(blank=True, null=True)),
                ('fill_rate', models.FloatField(blank=True, null=True)),
                ('max_concurrency', models.IntegerField(blank=True, null=True)),
                ('scope', models.JSONField(blank=True, null=True)),
                ('where', models.TextField(blank=True, null=True)),
                ('file_name', models.TextField(blank=True, null=True)),
                ('start_line_number', models.IntegerField(blank=True, null=True)),
                ('end_line_number', models.IntegerField(blank=True, null=True)),
            ],
            options={
                'db_table': 'steampipe_plugin_limiter',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='SteampipeScanMetadata',
            fields=[
                ('id', models.BigIntegerField(blank=True, primary_key=True, serialize=False)),
                ('table', models.TextField(blank=True, null=True)),
                ('cache_hit', models.BooleanField(blank=True, null=True)),
                ('rows_fetched', models.BigIntegerField(blank=True, null=True)),
                ('hydrate_calls', models.BigIntegerField(blank=True, null=True)),
                ('start_time', models.DateTimeField(blank=True, null=True)),
                ('duration', models.FloatField(blank=True, null=True)),
                ('columns', models.JSONField(blank=True, null=True)),
                ('limit', models.BigIntegerField(blank=True, null=True)),
                ('quals', models.TextField(blank=True, null=True)),
            ],
            options={
                'db_table': 'steampipe_scan_metadata',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='SteampipeServerSettings',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('start_time', models.DateTimeField()),
                ('steampipe_version', models.TextField()),
                ('fdw_version', models.TextField()),
                ('cache_max_ttl', models.IntegerField()),
                ('cache_max_size_mb', models.IntegerField()),
                ('cache_enabled', models.BooleanField()),
            ],
            options={
                'db_table': 'steampipe_server_settings',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='YmlFile',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('path', models.TextField(blank=True, db_comment='Specifies the path of the YML file.', null=True)),
                ('content', models.JSONField(blank=True, db_comment='Specifies the file content in JSON format.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form, e.g. connection_name.', null=True)),
            ],
            options={
                'db_table': 'yml_file',
                'db_table_comment': 'Represents the YML file content into JSON format.',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='YmlKeyValue',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('path', models.TextField(blank=True, db_comment='Specifies the path of the YML file.', null=True)),
                ('key_path', models.TextField(blank=True, db_comment='Specifies full path of a key in YML file.', null=True)),
                ('value', models.TextField(blank=True, db_comment='Specifies the value of the corresponding key.', null=True)),
                ('keys', models.JSONField(blank=True, db_comment='The array representation of path of a key.', null=True)),
                ('tag', models.TextField(blank=True, db_comment='Specifies the data type of the value.', null=True)),
                ('start_line', models.BigIntegerField(blank=True, db_comment='Specifies the line number where the value is located.', null=True)),
                ('start_column', models.BigIntegerField(blank=True, db_comment='Specifies the starting column of the value.', null=True)),
                ('pre_comments', models.JSONField(blank=True, db_comment='Specifies the comments added above a key.', null=True)),
                ('head_comment', models.TextField(blank=True, db_comment='Specifies the comment in the lines preceding the node and not separated by an empty line.', null=True)),
                ('line_comment', models.TextField(blank=True, db_comment='Specifies the comment at the end of the line where the node is in.', null=True)),
                ('foot_comment', models.TextField(blank=True, db_comment='Specifies the comment following the node and before empty lines.', null=True)),
                ('field_ctx', models.JSONField(blank=True, db_column='_ctx', db_comment='Steampipe context in JSON form, e.g. connection_name.', null=True)),
            ],
            options={
                'db_table': 'yml_key_value',
                'db_table_comment': 'List all key value pairs from given YML file.',
                'managed': False,
            },
        ),
    ]
